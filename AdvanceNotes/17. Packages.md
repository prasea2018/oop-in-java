# ğŸ“˜ **What are Packages**

## **1. What Is a Package? (Definition)**

A **package** in Java is:

> **A collection of classes, interfaces, and sub-packages, grouped together to organize a Java project.**

### âœ” Why use packages?

* To **organize** large projects that contain many classes and interfaces
* To **group related files** together
* To **avoid naming conflicts**
* To **control access** (public, protected, default)

---

## **2. Package = Folder (Simple Understanding)**

In Java:

| Concept       | Meaning                                                                   |
| ------------- | ------------------------------------------------------------------------- |
| **Class**     | Stored as a `.class` file after compilation                               |
| **Interface** | Also becomes a `.class` file after compilation                            |
| **Package**   | A **folder** that contains `.class` files or other folders (sub-packages) |

### Example:

```
src/
 â””â”€â”€ com/
      â””â”€â”€ bank/
           â”œâ”€â”€ Loan.java
           â”œâ”€â”€ Customer.java
           â””â”€â”€ util/
                â””â”€â”€ Validator.java
```

Here:

* `com.bank` is a package
* `com.bank.util` is a **sub-package**

---

## **3. How Java Stores Its Own Packages (JDK Source Example)**

Inside your JDK installation:

```
C:\Program Files\Java\jdk-xx\lib\src.zip
```

This file contains:

* all built-in **Java packages**
* all **Java source code** (.java files)

If you open `src.zip`, you will see folders like:

```
java
javax
jdk
com
```

These are **packages**.

Example:

```
java/lang
       â”œâ”€â”€ String.java
       â”œâ”€â”€ Boolean.java
       â”œâ”€â”€ Integer.java
       â”œâ”€â”€ Runnable.java (interface)
       â””â”€â”€ ...
```

### âœ” Key point:

All built-in Java classes (like String, Integer, Runnable) are stored inside **packages** as `.java` or `.class` files.

---

## **4. Understanding `java.lang` Package**

You used the `java.lang` package from your very first Java program.

It contains:

* `String`
* `Math`
* `System`
* `Runnable`
* `Integer`
* `Exception`
* etc.

### âœ” Automatically imported

`java.lang` is automatically available in every Java program.

So you can write:

```java
String s = "Hello";
```

without importing anything.

---

## **5. Importing Packages in Java**

There are **three ways** to use a class from a package.

---

### **5.1 Method 1 â†’ Import entire package using `*`**

```java
import java.lang.*;
```

This loads:

* String
* Math
* Runnable
* etc.

Good when you need **many classes** from the package.

---

### **5.2 Method 2 â†’ Import only a specific class**

```java
import java.lang.String;
```

Works when you need **only one class**.

This is faster for the compiler, cleaner for the project.

---

### **5.3 Method 3 â†’ Do NOT import; use fully-qualified name**

```java
java.lang.String s = new java.lang.String("Hello");
```

You explicitly write the **full package path**.

Useful when:

* class names clash (e.g., `Date` from two packages)
* you want complete control

---

## **6. Example Program: Using Packages**

```java
import java.lang.String;       // importing a single class
import java.lang.Runnable;     // importing an interface

class MyTest {
    public static void main(String[] args) {

        // Using the imported String class
        String s = new String("Hello World");

        // Without importing:
        java.lang.String str = new java.lang.String("Hi Again");

        System.out.println(s);
        System.out.println(str);
    }
}
```

---

## **7. Summary â€” Key Points to Remember**

### âœ” **Package = folder**

Stores classes, interfaces, and sub-packages.

### âœ” Classes & interfaces become `.class` files

After compilation.

### âœ” Java's built-in packages are stored inside `src.zip`

### âœ” Three ways to access a class from a package:

1. `import package.*;`
2. `import package.ClassName;`
3. Fully-qualified name: `package.ClassName`

### âœ” `java.lang` is automatically imported

---


# ğŸ“˜ **Creating a Package**

## ğŸ¯ **Learning Objectives**

After studying this section, you will be able to:

* Understand how to **create your own packages**.
* Compile Java code *into* a package using `javac -d`.
* Add multiple classes to the same package.
* Create **sub-packages (nested packages)**.
* Use custom packages inside another Java program using `import`.
* Understand how class files get organized in folders.

---

## ğŸ“Œ **1. What is a Package (Quick Recap)?**

A **package = folder**
A **class/interface = file (.class)**

A package groups related Java classes.

---

## ğŸ“Œ **2. Creating Our Own Package**

### ğŸ“ **Step 1 â€“ Write a class and specify a package**

Write `Demo.java`:

```java
package mypack1;

public class Demo {
    public void display() {
        System.out.println("Welcome to Demo");
    }
}
```

âš ï¸ The `package` statement **must be the first line** of the file.

---

### ğŸ“ **Step 2 â€“ Save the file**

Save as:

```
Demo.java
```

in a folder:

```
C:\myJava\
```

---

### ğŸ“ **Step 3 â€“ Compile WITH package creation**

Use:

```
javac -d . Demo.java
```

Where:

* `-d .` = create package folders in the current directory

After compiling, you'll see:

```
C:\myJava\mypack1\Demo.class
```

âœ”ï¸ A folder **mypack1** is automatically created
âœ”ï¸ `Demo.class` is inside that folder

---

## ğŸ“Œ **3. Adding More Classes to the Same Package**

Create `Demo2.java`:

```java
package mypack1;

public class Demo2 {
    public void display() {
        System.out.println("Welcome to Demo2");
    }
}
```

Compile:

```
javac -d . Demo2.java
```

Now the folder contains:

```
mypack1\Demo.class
mypack1\Demo2.class
```

Both now belong to the **same package**.

---

## ğŸ“Œ **4. Creating a Sub-Package**

Create `Demo3.java`:

```java
package mypack1.inner;

public class Demo3 {
    public void display() {
        System.out.println("Welcome to Demo3");
    }
}
```

Compile:

```
javac -d . Demo3.java
```

New folder structure:

```
mypack1\
    Demo.class
    Demo2.class
    inner\
        Demo3.class
```

âœ”ï¸ You created a sub-package: `mypack1.inner`

---

## ğŸ“Œ **5. Using Your Custom Packages**

Create a new file `Test.java`:

```java
import mypack1.Demo;
import mypack1.Demo2;
import mypack1.inner.Demo3;

class Test {
    public static void main(String[] args) {

        Demo d1 = new Demo();
        d1.display();

        Demo2 d2 = new Demo2();
        d2.display();

        Demo3 d3 = new Demo3();
        d3.display();
    }
}
```

---

## ğŸ“ **Compile & Run**

### Compile

```
javac Test.java
```

### Run

```
java Test
```

### Output

```
Welcome to Demo
Welcome to Demo2
Welcome to Demo3
```

âœ”ï¸ You successfully imported and used your own packages!

---

## ğŸ“Œ **6. Key Points to Remember**

### âœ” `package` statement must be the **first line**

### âœ” `javac -d <path>` creates folders for packages

Example:

```
javac -d . Demo.java
```

### âœ” Package = folder

### âœ” Sub-package = sub-folder

### âœ” Use `import` to access classes from packages

### âœ” If not importing, you must use full path:

```
mypack1.Demo d = new mypack1.Demo();
```

---

## ğŸ§  **Memory Boost Summary**

| Concept        | Meaning                                        |
| -------------- | ---------------------------------------------- |
| Package        | Folder that contains .class files              |
| Sub-package    | Folder inside another folder                   |
| `javac -d`     | Creates package folders automatically          |
| `import`       | Allows using classes without full package name |
| Class Location | Must match the package structure               |

---

## âœï¸ **Practice Exercises**

Try these on your own:

### **1)** Create a package `bank.loan` with:

* `LoanCalculator.java` class â†’ prints â€œLoan Calculatedâ€
* `EMICalc.java` class â†’ prints â€œEMI Calculatedâ€

### **2)** Make a `Main.java` to import them and call both methods.

### **3)** Create a sub-package `bank.loan.secured` with another class.

---


# ğŸ“˜ **Access Modifiers in Java**

Access modifiers determine **visibility** of class members (variables, methods, constructors, inner classes) and control **who can access them**.

There are **four types**:

1. **private**
2. **default** (no modifier)
3. **protected**
4. **public**

---

## 1ï¸âƒ£ **Where access modifiers can be applied**

| Modifier  | Can be applied to                                                |
| --------- | ---------------------------------------------------------------- |
| All       | Variables, Methods, Inner Classes                                |
| **Class** | Only `default` and `public` (cannot be `private` or `protected`) |

---

## 2ï¸âƒ£ **Ways to use a class**

* **By creating an object** â†’ *has-a* relationship
* **By inheritance (extends)** â†’ *is-a* relationship

**Examples:**

```java
class Test
{
    public static void main(String[] args) {
        Demo1 d = new Demo1(); // Test has-a Demo1
    }
}

class Demo2 extends Demo1 {} // Demo2 is-a Demo1
```
* Non-subclass in the **same package**
* Subclass in the **same package**
- Package [mypack1]
```java
class P1 {} 
class P2 extends P2 {}
```

* Non-subclass in a **different package**
* Subclass in a **different package**
- Package [mypack2]
```java
class Q2 {
    P1 p = new P1();
} 
class Q2 extends P2 {}
```

---

## 3ï¸âƒ£ **Access Modifier Rules**

### 3.1 **Same Class**

* **All members** are accessible (`private`, `default`, `protected`, `public`)

---

### 3.2 **Same Package**

* **Subclass or non-subclass:**

  * Accessible: `default`, `protected`, `public`
  * Not accessible: `private`

---

### 3.3 **Different Package**

| Member Type | Subclass         | Non-Subclass     |
| ----------- | ---------------- | ---------------- |
| `private`   | âŒ Not accessible | âŒ Not accessible |
| `default`   | âŒ Not accessible | âŒ Not accessible |
| `protected` | âœ… Accessible     | âŒ Not accessible |
| `public`    | âœ… Accessible     | âœ… Accessible     |

**Key:**

* `protected` allows access **only in subclass** across packages.
* `default` is package-private, accessible **only within same package**.

---

## 4ï¸âƒ£ **Quick Memory Tips**

* **private:** Only inside **same class**
* **default:** Only **within same package**
* **protected:** Not accessible in Non-Subclass of another package 
* **public:** Everywhere

---

## 5ï¸âƒ£ **Summary Table**

| Modifier  | Same Class | Same Package | Subclass (Different Package) | Non-Subclass (Different Package) |
| --------- | ---------- | ------------ | ---------------------------- | -------------------------------- |
| private   | âœ…          | âŒ            | âŒ                            | âŒ                                |
| default   | âœ…          | âœ…            | âŒ                            | âŒ                                |
| protected | âœ…          | âœ…            | âœ…                            | âŒ                                |
| public    | âœ…          | âœ…            | âœ…                            | âœ…                                |

---

## 6ï¸âƒ£ **Tips to Remember**

1. Start with **private â†’ most restrictive**
2. **public â†’ least restrictive**
3. Default = **package-only**
4. Protected = **like public for subclasses**, package-only otherwise
5. Always think in terms of **same class, same package, subclass, non-subclass**

---

## 7ï¸âƒ£ **Practical Example**

```java
package mypack1;

public class P1 {
    private int a = 10;
    int b = 20; // default
    protected int c = 30;
    public int d = 40;
}

package mypack1;

public class P2 extends P1 {
    public void show() {
        System.out.println(b); // default, accessible
        System.out.println(c); // protected, accessible
        System.out.println(d); // public, accessible
        // System.out.println(a); // private, NOT accessible
    }
}
```

* Subclass in the **same package** can access **default, protected, public**, but **not private**.

---


# ğŸ“˜ **Java Package Naming Conventions**

Packages are used to **group related classes and interfaces**. Proper naming is important to **avoid conflicts** and **maintain clarity**, especially in large projects.

---

## 1ï¸âƒ£ **Why Naming Conventions Matter**

* Prevent **class name conflicts**.
  Example: Two classes named `Account` in a university system:

  * `LibraryAccount`
  * `FeeAccount`

  If both classes are in **different packages**, no conflict occurs.

* Make packages **globally unique** by incorporating **domain names**.

* Group classes logically based on **functionality or module** (academics, admissions, loans, etc.).

---

## 2ï¸âƒ£ **Recommended Convention**

* Use your **organizationâ€™s Internet domain name in reverse** as the **base package**.

  Example:

  * University domain: `www.univ.com`

    * Base package: `com.univ`
  * Bank domain: `www.citi.com`

    * Base package: `com.citi`

---

### 2.1 **Organizing Modules**

Add sub-packages for specific modules:

**University Example:**

| Sub-package           | Classes it contains                 |
| --------------------- | ----------------------------------- |
| `com.univ.academics`  | `Student`, `Faculty`, `Examination` |
| `com.univ.admissions` | `AdmissionAccount`, `Enrollment`    |

**Bank Example:**

| Sub-package         | Classes it contains                |
| ------------------- | ---------------------------------- |
| `com.citi.accounts` | `SavingsAccount`, `CurrentAccount` |
| `com.citi.loans`    | `HomeLoan`, `EducationLoan`        |

---

## 3ï¸âƒ£ **Benefits**

1. **Avoids naming conflicts**

   * Class `Account` in different packages can coexist:

     ```java
     com.univ.admissions.Account
     com.univ.library.Account
     ```
2. **Organized project structure**

   * Easier to maintain, understand, and scale large projects.
3. **Universally unique classes**

   * Using domain-based packages ensures global uniqueness.

---

## 4ï¸âƒ£ **Example**

```java
package com.univ.academics;

public class Student {
    // fields, methods
}
```

* **Directory structure after compilation**:

```
myJavaFolder/
â””â”€â”€ com/
    â””â”€â”€ univ/
        â””â”€â”€ academics/
            â””â”€â”€ Student.class
```

* This shows that the **package structure matches the directory hierarchy**.

---

âœ… **Key Points to Remember**

* Use **reverse domain name** as base package (`com.univ`, `com.citi`).
* Add **sub-packages** for modules or logical groups (`academics`, `accounts`).
* Avoid class name conflicts by putting classes with similar names in **different packages**.
* Compiled `.class` files follow the **package folder structure**.

---

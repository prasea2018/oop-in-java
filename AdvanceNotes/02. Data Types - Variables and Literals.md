
# **Java Data Types, Variables, and Literals — Simplified Notes**

Data is the most important part of any program.
A program **processes data**, and while it runs, this data must be stored **temporarily in memory (RAM)** — not permanently on disk.
To hold this temporary data, Java provides **variables**.

---

# ⭐ 1. **Variables**

A **variable** is a named memory location used to store data while the program runs.

Before using a variable, Java requires two steps:

1. **Declare the variable** (tell Java what type of data it will store)
2. **Store a value** in it

Example:

```java
int age;
age = 25;
```

Here:

* `int` → data type
* `age` → variable name
* `25` → value stored

To know what kind of data a variable can store, we need **data types**.

---

# ⭐ 2. **Data Types in Java**

Java has many data types, but the most basic ones are called **primitive data types**.
They are built into the language and represent simple values.

Primitive data types are divided into:

1. **Integral (whole numbers)**
2. **Floating-point (decimal numbers)**
3. **Character**
4. **Boolean**

---

# ⭐ 3. Integral Types (whole numbers, no decimal)**

| Type    | Size    | Range                    |
| ------- | ------- | ------------------------ |
| `byte`  | 1 byte  | -128 to 127              |
| `short` | 2 bytes | -32768 to 32767          |
| `int`   | 4 bytes | approx. ±2 billion       |
| `long`  | 8 bytes | very large whole numbers |

**When to use which?**

* Use `byte` or `short` → small numbers, memory-saving
* Use `int` → most common
* Use `long` → very large numbers

Example:

```java
long population = 8000000000L;
```

(You must add **L** for long literals.)

---

# ⭐ 4. Floating-Point Types (numbers with decimal values)**

| Type     | Size    | Precision             |
| -------- | ------- | --------------------- |
| `float`  | 4 bytes | ~6–7 decimal digits   |
| `double` | 8 bytes | ~15–16 decimal digits |

**When to use?**

* `float` → less precision
* `double` → more accurate (most commonly used)

Example:

```java
double price = 99.99;
```

---

# ⭐ 5. Character Type (`char`)

Used to store a **single character**.

Size: **2 bytes**

Java uses **Unicode**, so it supports many languages:
English, Nepali, Hindi, Chinese, Japanese, Arabic, etc.

Example:

```java
char letter = 'A';
char nepaliChar = 'अ';
```

Range: `0` to `65535` (Unicode values)

---

# ⭐ 6. Boolean Type (`boolean`)

Stores only **true** or **false**.

Example:

```java
boolean isAdult = true;
```

Unlike C/C++,

* `true` ≠ 1
* `false` ≠ 0
  They are actual keywords.

Java does not fix how many bytes a boolean uses.
It usually takes at least **1 bit**, but JVM may allocate 1 byte or more internally.

---

# ⭐ 7. Default Values of Primitive Types

| Type                   | Default Value             |
| ---------------------- | ------------------------- |
| byte, short, int, long | 0                         |
| float, double          | 0.0                       |
| char                   | `\u0000` (null character) |
| boolean                | false                     |

---

# ⭐ 8. Literals in Java

A **literal** is the actual fixed value written in the code.

Examples:

```java
10        → integer literal  
10.5      → floating literal  
'A'       → character literal  
"Hello"   → string literal  
true      → boolean literal
```

Every value you assign to a variable is a literal.

### Special cases:

✔ **Long literal** → add `L`

```java
long x = 12345678900L;
```

✔ **Float literal** → add `F`

```java
float pi = 3.14F;
```

✔ **Character literal** must be in single quotes `'A'`

✔ **String literal** uses double quotes `"Java"`

---

# ⭐ 9. How to Choose a Data Type?

* Whole numbers → byte, short, int, long
* Decimal numbers → float, double
* Single character → char
* True/false → boolean

Choose based on:

* Size of value
* Required precision
* Memory optimization (if needed)

---

# ⭐ Final Summary

* A **variable** stores data in memory during program execution.
* **Primitive data types** specify what kind of data can be stored.
* Java supports:

  * Integral: byte, short, int, long
  * Floating-point: float, double
  * Character: char (Unicode, 2 bytes)
  * Boolean: true/false
* **Literals** are the fixed values written in the program (numbers, characters, booleans, strings).
* Choose a data type based on the size and nature of your data.


---

# **2. Java Data Type Sizes and Ranges Using Wrapper Classes**

In the previous lesson, we discussed **primitive data types** and their ranges.
Here, we’ll learn **how to programmatically find the range and size** of any data type using Java’s built-in classes.

---

## 1. **Wrapper Classes**

* For each primitive data type, Java provides a **wrapper class**.
* A wrapper class is a **class representation of a primitive**.
* These classes contain **useful constants** and methods such as:

  * Minimum value
  * Maximum value
  * Number of bytes

**Examples:**

| Primitive | Wrapper Class |
| --------- | ------------- |
| `int`     | `Integer`     |
| `byte`    | `Byte`        |
| `short`   | `Short`       |
| `long`    | `Long`        |
| `float`   | `Float`       |
| `double`  | `Double`      |
| `char`    | `Character`   |
| `boolean` | `Boolean`     |

> Boolean is special: it only has `true` and `false`, and **does not have min/max or fixed size**.

---

## 2. **Important Members of Wrapper Classes**

Most wrapper classes have **three important constants**:

| Constant    | Meaning                                      |
| ----------- | -------------------------------------------- |
| `MIN_VALUE` | Minimum value the data type can store        |
| `MAX_VALUE` | Maximum value the data type can store        |
| `BYTES`     | Number of bytes the data type uses in memory |

**Example for `int`:**

```java
System.out.println("Integer min value: " + Integer.MIN_VALUE);
System.out.println("Integer max value: " + Integer.MAX_VALUE);
System.out.println("Integer size in bytes: " + Integer.BYTES);
```

**Output:**

```
Integer min value: -2147483648
Integer max value: 2147483647
Integer size in bytes: 4
```

---

## 3. **Other Primitive Types**

**Byte**

```java
System.out.println("Byte min: " + Byte.MIN_VALUE);
System.out.println("Byte max: " + Byte.MAX_VALUE);
System.out.println("Byte size in bytes: " + Byte.BYTES);
```

* Min: -128
* Max: 127
* Size: 1 byte

**Short**

```java
System.out.println("Short min: " + Short.MIN_VALUE);
System.out.println("Short max: " + Short.MAX_VALUE);
System.out.println("Short size in bytes: " + Short.BYTES);
```

* Min: -32,768
* Max: 32,767
* Size: 2 bytes

**Float**

```java
System.out.println("Float min: " + Float.MIN_VALUE);
System.out.println("Float max: " + Float.MAX_VALUE);
System.out.println("Float size in bytes: " + Float.BYTES);
```

* Size: 4 bytes
* Handles decimal numbers

**Double**

```java
System.out.println("Double min: " + Double.MIN_VALUE);
System.out.println("Double max: " + Double.MAX_VALUE);
System.out.println("Double size in bytes: " + Double.BYTES);
```

* Size: 8 bytes
* More precise than float

**Character**

```java
System.out.println("Char min: " + (int) Character.MIN_VALUE);
System.out.println("Char max: " + (int) Character.MAX_VALUE);
System.out.println("Char size in bytes: " + Character.BYTES);
```

* Size: 2 bytes (Unicode)
* Stores single characters

**Boolean**

* Only has `true` and `false`
* No fixed size, cannot use MIN_VALUE or MAX_VALUE

---

## 4. **Why Wrapper Classes Are Useful**

* You can **programmatically check the range and size** instead of memorizing all values.
* Useful for **validating input** or **preventing overflow**.
* Acts as a bridge when **primitive types need to be treated like objects**.

---

## 5. **Summary Table (Common Primitives)**

| Type    | Size (bytes) | Min Value                  | Max Value                 |
| ------- | ------------ | -------------------------- | ------------------------- |
| byte    | 1            | -128                       | 127                       |
| short   | 2            | -32,768                    | 32,767                    |
| int     | 4            | -2,147,483,648             | 2,147,483,647             |
| long    | 8            | -9,223,372,036,854,775,808 | 9,223,372,036,854,775,807 |
| float   | 4            | 1.4E-45                    | 3.4028235E38              |
| double  | 8            | 4.9E-324                   | 1.7976931348623157E308    |
| char    | 2            | 0                          | 65535                     |
| boolean | -            | -                          | -                         |

---

### ✅ Key Points to Remember

1. Primitive data types have **fixed ranges and sizes** except boolean.
2. **Wrapper classes** provide `MIN_VALUE`, `MAX_VALUE`, and `BYTES`.
3. Always use wrapper classes to **check ranges programmatically**.
4. Boolean only has **true/false** and no size constants.

---


Here’s a **clear, structured summary** of your explanation about **variables in Java**:

---

# **Java Variables: Introduction and Usage**

## 1. **What is a Variable?**

* A variable is a **name given to a memory location** that stores data.
* Variables allow the program to **store, access, and modify data** during execution.
* Every variable must have a **data type**, which defines:

  * The **kind of data** it can hold (integer, decimal, character, etc.)
  * The **size of memory** it occupies

**Example:**

```java
byte b = 5;   // 'b' is a variable of type byte storing value 5
```

* `b` is the variable name.
* `byte` is the data type.
* `5` is the value stored.

---

## 2. **Declaration and Initialization**

### **Declaration**

* Before using a variable, it **must be declared**.
* Syntax:

```java
dataType variableName;
```

* Example:

```java
int i; // variable declared but not initialized
```

* Default value is assigned by Java if not initialized:

  * For numeric types → `0`
  * For char → `'\u0000'`
  * For boolean → `false`

### **Initialization**

* Assigning an initial value to a variable:

```java
int i = 75;  // declaration + initialization
```

---

## 3. **Changing Variable Values**

* Variables are **mutable**, meaning their value can change during program execution:

```java
b = 25;  // updates the value stored in 'b'
```

---

## 4. **Choosing Data Types**

* Select the data type **based on the value you want to store**:
  | Value Type              | Use Data Type       |
  |-------------------------|------------------|
  | Small integer (-128 to 127) | byte             |
  | Larger integer (-32,768 to 32,767) | short          |
  | Larger integer | int / long       |
  | Decimal number | float / double  |
  | Single character | char          |

* Example:

```java
byte b = 127;       // maximum for byte
short s = 32000;
int i = 100000;
float f = 25.3f;
double d = 1234567.89;
char c = 'A';
```

---

## 5. **Memory Allocation**

* When a variable is declared, **memory is reserved** for it based on its data type:
  | Data Type | Memory Size |
  |-----------|------------|
  | byte      | 1 byte     |
  | short     | 2 bytes    |
  | int       | 4 bytes    |
  | long      | 8 bytes    |
  | float     | 4 bytes    |
  | double    | 8 bytes    |
  | char      | 2 bytes    |
  | boolean   | 1 bit (approx.) |

* Example:

```java
int i = 75; // reserves 4 bytes in memory to store value 75
```

---

## 6. **Type Limits**

* A variable **cannot store values beyond its data type range**:

```java
byte b;
b = 130;  // Error: possible lossy conversion, max for byte is 127
b = 127;  // OK
```

* Always **choose a data type large enough** to hold your expected values.

---

## 7. **Practical Example**

```java
byte b = 5;
short s = 3000;
int i = 100000;
float f = 25.3f;
double d = 1234567.89;
char c = 'A';

System.out.println("Byte b: " + b);
System.out.println("Short s: " + s);
System.out.println("Integer i: " + i);
System.out.println("Float f: " + f);
System.out.println("Double d: " + d);
System.out.println("Char c: " + c);
```

**Output:**

```
Byte b: 5
Short s: 3000
Integer i: 100000
Float f: 25.3
Double d: 1234567.89
Char c: A
```

---

### ✅ **Key Points**

1. **Declare** a variable before using it.
2. **Initialize** before using it to avoid errors.
3. **Select data type** based on the value to store and memory requirement.
4. **Variables occupy memory**, and memory size depends on the data type.
5. **Cannot store values beyond the data type’s range**.

---

Next, you will learn about **rules for naming variables in Java**, which is essential for writing correct and readable code.

---

# **Rules for Declaring Variable Names in Java**

When programming in Java, choosing proper variable names is important, especially in large projects where you may have hundreds of variables. Java has **rules and guidelines** for naming variables.

---

## **1. Case Sensitivity**

* Variable names are **case-sensitive**.
* `amount` and `Amount` are **two different variables**.
* This gives flexibility to use similar names with different cases.

**Example:**

```java
int amount = 100;
int Amount = 200;  // Different variable
```

---

## **2. Allowed Characters**

* Variable names can contain:

  * **Alphabets** (a–z, A–Z)
  * **Numbers** (0–9)
  * **Special symbols** `_` (underscore) and `$` (dollar sign)
* **Spaces and other special characters are not allowed**.

**Example:**

```java
int total_amount = 500;   // Underscore is allowed
int $totalAmount = 600;   // Dollar sign is allowed
```

---

## **3. Starting Character**

* A variable name **must start with**:

  * An alphabet (a–z, A–Z)
  * `_` (underscore)
  * `$` (dollar sign)
* It **cannot start with a number**.

**Example:**

```java
int _count = 10;   // Allowed
int $value = 20;   // Allowed
int 1stNumber = 30; // Not allowed
```

---

## **4. Cannot Use Keywords**

* Java **keywords** (reserved words) cannot be used as variable names.
* Examples of keywords: `int`, `float`, `if`, `for`, `new`, `class`, etc.

**Example:**

```java
int new = 10;     // Not allowed
float class = 5;  // Not allowed
```

---

## **5. Avoid Using Class Names**

* Variables **should not use existing class names**.
* It can lead to confusion, even if allowed by the compiler.

**Example:**

```java
int String = 100; // Technically allowed, but not recommended
```

---

## **6. Length of Variable Names**

* No limit on the **length of a variable name**.
* Names can be **short or long**, depending on readability.

**Example:**

```java
int n;  // Short name
int numberOfStudentsInClass = 50;  // Long but readable
```

---

## **7. CamelCase Convention**

* **Recommended style** for readability:

  * Start with a lowercase letter.
  * Capitalize the first letter of each subsequent word.
* Avoid underscores and dollar signs unless necessary.

**Example:**

```java
int averageMarksOfClass = 85;  // CamelCase
```

---

## **8. Summary of Allowed Variable Names**

| Start Character | Allowed Characters                | Examples             |
| --------------- | --------------------------------- | -------------------- |
| Alphabet        | a–z, A–Z, 0–9, _, $               | `age`, `totalAmount` |
| _ (underscore)  | a–z, A–Z, 0–9, _, $               | `_count`, `_total`   |
| $ (dollar)      | a–z, A–Z, 0–9, _, $               | `$value`, `$total`   |
| Number          | Not allowed as starting character | `1stNumber` ❌        |

**Not Allowed:**

* Keywords: `if`, `for`, `new`, `class`
* Spaces or special symbols other than `_` and `$`
* Starting with a number

---

## **Practical Examples**

```java
int x;              // simple, allowed
int X;              // different from 'x'
int total_amount;   // allowed with underscore
int $salary;        // allowed
int _count;         // allowed
int averageMarksOfClass; // recommended CamelCase style

// Invalid examples:
int 1stNumber;     // starts with number ❌
int new;           // keyword ❌
int student name;  // space ❌
```

---

### ✅ **Key Takeaways**

1. Java variables are **case-sensitive**.
2. Allowed characters: letters, numbers, `_`, `$`.
3. Cannot start with a number.
4. Avoid using keywords or class names.
5. CamelCase is recommended for readability.
6. Variable names can be **any length**, but make them meaningful.

---

Next, you will learn about **literals** in Java—fixed values that variables can hold.

---

Here’s a **structured summary** of your explanation about **Java literals** with important points and examples:

------

# **Java Literals**

**Literals** are **constant values used directly in a program**. Unlike variables, literals **do not change** during program execution.

**Example:**

```java
int x = 25;  // 25 is a literal
int a = 5 + 7; // 5 and 7 are literals
```

------

## **1. Literals Have Data Types**

- Just like variables, **literals also have a data type**.
- The type of literal is determined by its **format**:

| Literal Example | Type                       |
| --------------- | -------------------------- |
| `5`, `7`, `25`  | Integer literal            |
| `3.142`         | Double literal             |
| `'A'`           | Character literal          |
| `"Hello"`       | String literal             |
| `true`, `false` | Boolean literal            |
| `6.5F`          | Float literal (F/f suffix) |
| `125L`          | Long literal (L/l suffix)  |

**Rules:**

- Decimal numbers without a suffix → **int** by default
- Decimal numbers with a point → **double** by default
- `F`/`f` suffix → **float**
- `L`/`l` suffix → **long**
- Single quotes `' '` → **char**
- Double quotes `" "` → **String**
- Boolean → `true` or `false`

------

## **2. Integer Literals in Different Number Systems**

Integer literals can be written in **different number systems**:

| Number System | Prefix / Format    | Example  |
| ------------- | ------------------ | -------- |
| Decimal       | No prefix          | `10`     |
| Binary        | `0b` or `0B`       | `0b1010` |
| Octal         | `0` (leading zero) | `012`    |
| Hexadecimal   | `0x` or `0X`       | `0xA`    |

**Example in Java:**

```java
byte b1 = 10;      // decimal
byte b2 = 0b1010;  // binary
byte b3 = 012;     // octal
byte b4 = 0xA;     // hexadecimal

System.out.println(b1); // prints 10
System.out.println(b2); // prints 10
System.out.println(b3); // prints 10
System.out.println(b4); // prints 10
```

> All these represent the **same numeric value**, just written differently.

------

## **3. Long Literals**

- Integer values larger than `int` must be marked with `L` or `l`.
- Example:

```java
long bigNum = 12345678901L;  // L suffix for long
```

- Assigning a literal without `L` that exceeds `int` range → **compilation error**.

------

## **4. Float and Double Literals**

- Decimal numbers without suffix → **double** by default.
- To assign to a `float` variable, use **F/f suffix**.

```java
float f = 12.56F; // correct
double d = 12.56; // correct
float g = 12.56;  // ❌ error: possible lossy conversion
```

------

## **5. Character and String Literals**

- **Character:** Single quotes `'A'`
- **String:** Double quotes `"Hello World"`

------

## **6. Boolean Literals**

- Only two values: `true` or `false`

```java
boolean flag = true;
```

------

## **7. Using Underscores for Readability**

- You can use **underscores `_`** to separate digits in numeric literals for better readability.

```java
int million = 1_000_000;
float largeFloat = 123_456.78F;
```

- **Cannot** place `_` at the start, end, or next to a decimal point:

```java
int invalid = _1000;  // ❌
float invalid2 = 12_.34F;  // ❌
```

------

## **Key Points**

1. Literals represent **constant values** in code.
2. They have **types** just like variables.
3. Integer literals can be **decimal, binary, octal, or hexadecimal**.
4. Floating-point literals are **double by default**, use `F` for float.
5. Use **underscores** for readability in large numbers.

------

# **Viewing Binary Representation of Numbers in Java**

## **1. Integer Storage in Memory**

- When you store an integer (like `5`) in memory, it is stored in **binary form** (sequence of 0s and 1s).
- Example: `5` in binary is `101`.
- Even if you don’t understand binary deeply, it’s important to know that **every integer occupies memory in bits**:
  - `byte` → 8 bits
  - `short` → 16 bits
  - `int` → 32 bits
  - `long` → 64 bits

------

## **2. Converting Integer to Binary String**

- Java provides a **built-in method** in the `java.lang.Integer` class:

```java
int x = 5;
System.out.println(Integer.toBinaryString(x)); // prints 101
```

- **Explanation:**
  - `Integer.toBinaryString(x)` converts the integer `x` to its **binary representation** as a `String`.
  - Leading zeros are **not shown** by default.

------

## **3. Negative Numbers and Two’s Complement**

- Negative numbers are stored using **two’s complement** representation.

- Example: `-5` in binary (32-bit integer) is:

  ```
  11111111111111111111111111111011
  ```

- You can print it the same way:

```java
int y = -5;
System.out.println(Integer.toBinaryString(y));
```

- **Note:**
  - Integer in Java always occupies **32 bits**.
  - For byte or short, you can **convert to int first** to use `toBinaryString()`.

------

## **4. Limitations**

- This method is **specific to integers** (`int` or `Integer`).

- **Byte and short** can be converted by casting to int:

  ```java
  byte b = 5;
  System.out.println(Integer.toBinaryString(b & 0xFF)); // masks byte to 8 bits
  ```

- **Float, double, boolean, char**: No direct built-in method to see binary bits in Java.

------

## **Key Takeaways**

1. **Integer values in memory** are stored in binary (bits).
2. **`Integer.toBinaryString()`** is used to view the binary form.
3. **Negative integers** use **two’s complement**.
4. For `byte` and `short`, **convert to int first**.
5. Floating-point numbers (`float`/`double`) do not have a simple direct method to view bits.

------



# **ðŸ“˜What is Multiprogramming**

## **Learning Objectives**

After studying this material, you will be able to:

1. Understand **multiprogramming**, **multi-user systems**, **multitasking**, and **multi-threading**.
2. Recognize the **differences between multi-user and multitasking environments**.
3. Comprehend the **motivation behind multi-threading** in Java.
4. Visualize **how CPU utilization drives multi-program execution**.
5. Understand the **role of operating systems in scheduling multiple programs**.

---

## **Key Concepts**

1. **Multiprogramming**

   * Definition: Running multiple programs on a **single computer** simultaneously.
   * Goal: **Increase CPU utilization** by keeping it busy when one program is idle.
   * Forms:

     * **Multi-user:** Multiple users share a single computer, each running programs.
     * **Multitasking:** A single user runs multiple tasks/programs concurrently.

2. **Multi-User System**

   * Multiple users connect to a single high-configuration computer.
   * Users interact via terminals (monitor + keyboard, no personal CPU).
   * CPU executes **one program at a time**, switching rapidly among users.
   * Example OS: Unix/Linux (timesharing systems).
   * Mechanism: Round-robin scheduling creates **illusion of simultaneous execution**.

3. **Multitasking & Multi-Threading**

   * **Multitasking:** Single user performs multiple tasks simultaneously.
   * **Multi-threading:** A type of multitasking where a single program contains multiple threads.
   * Difference with multi-user:

     | Feature | Multi-User   | Multitasking/Multi-Threading |
     | ------- | ------------ | ---------------------------- |
     | Users   | Multiple     | Single                       |
     | Tasks   | One per user | Multiple for same user       |

4. **CPU Utilization Concept**

   * CPU is **idle most of the time** in single-task programs.
   * Examples:

     * Browsing internet: CPU processes data briefly; most time spent waiting for data.
     * Typing in MS Word: CPU used minimally (e.g., spellcheck), but user actively types.
   * **Solution:** Run multiple programs concurrently to keep CPU busy.

5. **Operating System Role**

   * Manages CPU scheduling for multiple programs/tasks.
   * Ensures **fair execution** using mechanisms like round-robin or priority scheduling.
   * Creates **illusion of simultaneous execution** for users and tasks.

---

## **Detailed Breakdown**

### 1. **Multiprogramming**

* Key idea: Multiple programs share the same CPU to reduce idle time.
* CPU switches between programs when one program waits for I/O operations.

### 2. **Multi-User Systems**

* Early high-performance computers supported multiple users.
* Users accessed the computer via terminals (no personal CPU).
* OS schedules programs so all users feel like they have their own machine.

### 3. **Multitasking**

* Modern personal computers support **single-user multitasking**.
* User can run several applications (e.g., browser + IDE + media player).
* Multi-threading is a deeper level: multiple **threads within one program** execute concurrently.

### 4. **CPU Utilization Example**

* Single program execution wastes CPU cycles.
* Multi-programming keeps CPU busy by switching tasks.
* Improves **overall system efficiency**.

### 5. **Role of Operating Systems**

* Schedules tasks across CPU efficiently.
* Provides time slices to each program/thread (round-robin).
* Handles multitasking seamlessly in modern OS.

---

## **Summary**

* Multiprogramming: Run multiple programs on one CPU â†’ better CPU utilization.
* Multi-user: Multiple users share a high-performance computer.
* Multitasking: Single user runs multiple tasks.
* Multi-threading: Multiple threads inside a single program â†’ advanced multitasking.
* CPU is underutilized in single-task programs â†’ multi-threading maximizes efficiency.
* OS ensures smooth execution and fair resource sharing.

---

## **Practical Applications**

1. **Java Multi-Threading** allows:

   * Background tasks while main program runs (e.g., GUI responsiveness).
   * Parallel computation for improved performance.
   * Resource sharing among threads efficiently.
2. **System Design**: Servers handle multiple client requests using threads.
3. **Modern Software**: Games, simulations, and real-time applications use multi-threading.

---

## **Self-Assessment Questions**

1. What is the difference between **multi-user** and **multitasking**?
2. How does **multiprogramming improve CPU utilization**?
3. Explain **round-robin scheduling** in multi-user systems.
4. Why is **multi-threading considered a type of multitasking**?
5. Give an example of a situation where **multi-threading improves application performance**.

---

# **ðŸ“˜What is Multitasking**

## **Learning Objectives**

After studying this material, you will be able to:

1. Distinguish **multitasking** from **multi-threading**.
2. Understand how **threads work within a single application**.
3. Identify practical use cases of multithreading in **applications, games, animations, and web servers**.
4. Visualize **how CPU executes threads alternatively but gives an illusion of simultaneity**.
5. Explain the **concept of control flow** in multi-threaded programs.

---

## **Key Concepts**

1. **Multitasking (Single User)**

   * Definition: Running **more than one task/program** for a single user simultaneously.
   * Mechanism: CPU executes programs **alternatively at high speed**, creating the illusion of simultaneous execution.
   * Examples:

     * MS Word typing + Chrome browser video playing.
     * Multiple applications open on a PC.
   * Supported OS: Windows, MacOS, Linux.

2. **Multi-Threading (Inside a Single Application)**

   * Definition: **Multiple threads of execution within a single program**.
   * Threads are **lightweight** compared to full processes.
   * Mechanism: CPU executes threads **alternatively**, but due to processor speed, users perceive them as simultaneous.
   * Example: Chrome application:

     * Thread 1: Video playback
     * Thread 2: Advertisement rotation
     * Thread 3: User comments interaction

3. **Differences Between Multitasking and Multithreading**

   | Feature            | Multitasking                  | Multithreading                  |
   | ------------------ | ----------------------------- | ------------------------------- |
   | Scope              | Multiple programs             | Multiple threads within program |
   | User               | Single user                   | Single application user         |
   | Execution illusion | CPU switches between programs | CPU switches between threads    |
   | Lightweight?       | No (process heavy)            | Yes (thread light)              |

4. **CPU Execution**

   * CPU executes one program/thread at a time but **switches rapidly**.
   * High-speed switching creates **illusion of parallel execution**.
   * Threads improve **responsiveness** and **efficiency**.

---

## **Detailed Examples of Multi-Threading**

1. **Animations**

   * Example: Bouncing balls on screen.
   * Each ball can be controlled by its own thread â†’ independent movement.
   * Threads allow **smooth and simultaneous animations**.

2. **Games**

   * Example: Car racing game.
   * Each car (or player) controlled by its own thread.
   * Threads allow **simultaneous user actions** in real-time multiplayer environments.

3. **Multimedia Applications**

   * Example: Orchestra simulator with piano, guitar, and drums.
   * Each instrument is controlled by a separate thread â†’ simultaneous sound playback.

4. **Web Servers**

   * Example: Handling multiple users on a website.
   * Each user request handled by a **separate thread**.
   * Thread fetches user-specific data from database â†’ **responsive web service**.
   * Real-world example: Udemy server serving personalized content to multiple users concurrently.

---

## **Flow of Control in Multi-Threading**

* Single-threaded program: Control flows sequentially.
* Multi-threaded program: Control flows **simultaneously in multiple threads**, each handling a specific task.
* CPU **switches between threads rapidly**, giving perception of simultaneous execution.

---

## **Summary**

* **Multitasking:** Multiple programs/tasks for a single user.
* **Multi-threading:** Multiple threads inside a single application.
* **Threads:** Lightweight, responsive, enable parallel operations inside programs.
* **Applications:** Animation, games, multimedia, web servers.
* CPU executes **alternatively**, OS ensures scheduling â†’ illusion of simultaneity.

---

## **Practical Applications**

1. Animation software and games (independent object movement).
2. Web servers handling multiple users (threads per request).
3. Multimedia applications (simultaneous instrument playback).
4. Real-time data processing (e.g., stock tickers, live feeds).
5. UI applications for responsiveness (video + background tasks).

---

## **Self-Assessment Questions**

1. Explain multitasking with a real-world example.
2. What makes threads â€œlightweightâ€ compared to full processes?
3. How does CPU switching create an illusion of simultaneous execution?
4. Give three examples where multithreading improves performance.
5. In a web server scenario, why is multithreading important?

---



# **ðŸ“˜Control Flow of a Program**

## **Learning Objectives**

After studying this section, you will be able to:

1. Explain **control flow** in a single-threaded program.
2. Understand **why a single-threaded program cannot handle multiple infinite loops simultaneously**.
3. Recognize the need for **multiple threads** to achieve concurrent execution.
4. Visualize **how multi-threading creates multiple flows of control** in Java programs.

---

## **Key Concepts**

1. **Control Flow in Single-Threaded Program**

   * A **single program has one control flow** (main thread).
   * Execution steps:

     1. Program starts at `main()` method.
     2. Calls other methods sequentially (e.g., `display()`).
     3. Control returns to the calling method after method completion.
   * Analogy: Reading a book with references to other pages â€“ you go to a page, read it, then return to the main page.

2. **Limitations of Single Control Flow**

   * **Infinite loop problem:** If a method contains an infinite loop, main thread is blocked.
   * Example:

```java
class Test {
  static void display() {
    int i = 1;
    while(true) {
      System.out.println(i + " Hello");
      i++;
    }
  }

  public static void main(String[] args) {
    display();
    int j = 1;
    while(true) {
      System.out.println(j + " World");
      j++;
  }
}
```
   * In this example, the `main()` method never reaches the second infinite loop because control is stuck in `display()`.

3. **Need for Multiple Flows of Control**

   * Goal: Run **two infinite loops simultaneously** (`Hello` loop and `World` loop).
   * Solution: **Convert `display()` into a separate thread**.
   * Result: Two concurrent flows of control â†’ `Hello` and `World` printed alternately.

4. **Threads as Separate Control Flows**

   * **Main thread:** Original program flow starting from `main()`.
   * **Child thread(s):** Additional flows executing concurrently with main thread.
   * Each thread has its **own execution context**, allowing multiple tasks to progress simultaneously.

---

## **Detailed Breakdown**

### Single-Threaded Execution

* One flow of control â†’ statements executed sequentially.
* Infinite loop blocks remaining code â†’ **cannot achieve simultaneous execution**.

### Multi-Threaded Execution

* Convert methods or tasks into threads.
* Main thread continues execution **while child threads run independently**.
* CPU alternates execution between threads â†’ users perceive **simultaneous execution**.

### Analogy

* Single-thread: One finger reading pages sequentially.
* Multi-thread: Multiple fingers (threads) reading multiple pages at the same time.

---

## **Practical Example Scenario**

| Task                           | Thread Type                | Execution                             |
| ------------------------------ | -------------------------- | ------------------------------------- |
| Print "Hello" in infinite loop | Child thread (`display()`) | Runs independently                    |
| Print "World" in infinite loop | Main thread                | Runs simultaneously with child thread |

* Output on console:

  ```
  1 Hello
  1 World
  2 Hello
  2 World
  ...
  ```

* CPU executes alternately â†’ creates **illusion of parallel execution**.

---

## **Summary**

* Single-threaded programs have **one control flow** â†’ sequential execution.
* Infinite loops in a single thread **block further statements**.
* Multi-threading introduces **multiple flows of control** â†’ tasks can run concurrently.
* In Java, threads allow **independent execution of methods** while main thread continues.

---

## **Practical Applications**

1. **Simultaneous UI updates:** Background tasks and user interaction at the same time.
2. **Concurrent computations:** Separate threads for different calculations.
3. **Server requests:** Each client request handled by its own thread.
4. **Real-time monitoring applications:** Display live data while performing calculations.

---

## **Self-Assessment Questions**

1. Explain control flow in a single-threaded program.
2. Why does an infinite loop in a method block the main thread?
3. How does multi-threading solve the infinite loop blocking problem?
4. In the example program, how do the `Hello` and `World` loops execute simultaneously?
5. What is the difference between a main thread and a child thread?


---

# **ðŸ“˜Java Multi-Threading: Using Thread Class**

## **Learning Objectives**

After studying this section, you will be able to:

1. Identify the **Java classes and interfaces for multi-threading**.
2. Implement multi-threading using the **`Thread` class**.
3. Understand the **role of `run()` and `start()` methods** in threads.
4. Compare **different approaches** to writing multi-threaded programs.
5. Recognize when to use **`Thread` class vs `Runnable` interface**.

---

## **Key Concepts**

1. **Classes and Interfaces for Multi-Threading in Java**

   * **`Thread` class**: Contains the actual mechanism for multi-threading. Mandatory to create threads.
   * **`Runnable` interface**: Defines a single method `run()`. Classes implementing Runnable can be executed by a Thread.
   * **Design consideration:**

     * Use **`Thread` class** if your class does not extend any other class.
     * Use **`Runnable` interface** if your class already extends another class (Java allows single inheritance but multiple interfaces).

2. **Thread Life Cycle**

   * **Main thread:** Execution starts from `main()` method.
   * **User-defined thread:** Execution starts from `run()` method.
   * **`start()` method:** Initiates a new thread and calls the `run()` method internally.
   * **`run()` method:** Contains the logic of the thread. Similar to `main()` for programs, `run()` is the entry point for a thread.

3. **Implementing Multi-Threading Using `Thread` Class**

   * **Step 1:** Create a class that extends `Thread`.
   * **Step 2:** Override `public void run()` method with the thread logic. `run()` is starting point of thread just like `main()` is starting point of program.
   * **Step 3:** In `main()`, create an object of your class.
   * **Step 4:** Call `start()` on the object to start the thread. The `start()` calls `run()` as thread. 

### **Example 1: Using Two Classes**

```java
class MyThread extends Thread {
  public void run() {
    int i = 1;
    while(true) {
      System.out.println(i + " Hello");
      i++;
    }
  }
}

public class Test {
  public static void main(String[] args) {
    MyThread t = new MyThread(); // Step 3: Create thread
    t.start();                   // Step 4: Start thread

    int j = 1;
    while(true) {
      System.out.println(j + " World"); // Main thread execution
      j++;
    }
  }
}
```

**Explanation:**

* `MyThread` is a user-defined thread.
* `t.start()` begins execution of `run()` in a separate thread.
* Main thread continues printing "World" simultaneously.

---

### **Example 2: Single-Class Implementation**

```java
public class Test extends Thread {
  public void run() {
    int i = 1;
    while(true) {
      System.out.println(i + " Hello");
      i++;
    }
  }

  public static void main(String[] args) {
    Test t = new Test(); // Thread object
    t.start();           // Starts run() in separate thread

    int j = 1;
    while(true) {
      System.out.println(j + " World"); // Main thread
      j++;
    }
  }
}
```

**Explanation:**

* Same functionality as previous example but uses a **single class**.
* Thread logic in `run()`, main thread logic in `main()`.
* Both loops run **simultaneously** using separate flows of control.

---

### **Key Points**

1. **Do not call `run()` directly** â†’ it executes in main thread, not a separate thread.
2. **Always call `start()`** â†’ it internally invokes `run()` and creates a new control flow.
3. **Thread scheduling** is handled by JVM â†’ CPU alternates between threads giving **illusion of simultaneous execution**.
4. **Infinite loops** in separate threads do not block main thread.



---

## **Summary**

* Multi-threading in Java is **achieved using Thread class or Runnable interface**.
* `Thread` class provides **all mechanisms**, `Runnable` is an **interface for flexible design**.
* `start()` initiates **new thread**, `run()` contains **thread logic**.
* Multiple flows of control allow **concurrent execution of tasks** in the same program.

---

## **Practical Applications**

1. **UI and background processing:** Update GUI while performing calculations.
2. **Games:** Simultaneous control of characters or objects.
3. **Servers:** Handle multiple client requests simultaneously.
4. **Simulations and animations:** Each moving object controlled by its own thread.

---

## **Self-Assessment Questions**

1. What is the difference between `start()` and `run()` in Java threads?
2. When should you use `Runnable` instead of extending `Thread`?
3. Explain the steps to create a thread using the `Thread` class.
4. How do multiple threads achieve the illusion of simultaneous execution?
5. Modify the example program to print numbers along with "Hello" and "World" alternately up to 10.

---


# **ðŸ“˜Java Multi-Threading: Using Runnable Interface**

## **Key Concepts**

1. **Runnable Interface**

   * `Runnable` is a **functional interface** with a single method:

     ```java
     public void run()
     ```
   * Any class implementing `Runnable` must **override `run()`**.
   * Implementing `Runnable` **does not make the class a thread**. It only provides **thread-capable behavior**.

2. **Running a Runnable**

   * Since a `Runnable` object **cannot run by itself**, you must attach it to a **Thread object**.
   * Example analogy:

     * **Thread = horse (executes logic)**
     * **Runnable object = cart (holds the logic to run)**
     * Start the thread â†’ horse runs â†’ cart logic executes.

3. **Steps to Implement Runnable**

   1. Create a class implementing `Runnable`.
   2. Override `public void run()` with your thread logic.
   3. Create an object of your class:

      ```java
      MyRunnable m = new MyRunnable();
      ```
   4. Attach it to a Thread object:

      ```java
      Thread t = new Thread(m);
      ```
   5. Start the thread:

      ```java
      t.start();
      ```

---

## **Example 1: Runnable with Two Classes**

```java
class My implements Runnable {
  public void run() {
    int i = 1;
    while(true) {
      System.out.println(i + " Hello");
      i++;
    }
  }
}

public class Test {
  public static void main(String[] args) {
    My m = new My();          // Step 3: Create Runnable object
    Thread t = new Thread(m); // Step 4: Attach to Thread
    t.start();                // Step 5: Start thread

    int j = 1;
    while(true) {
      System.out.println(j + " World"); // Main thread
      j++;
    }
  }
}
```

**Explanation:**

* `My` implements Runnable â†’ thread logic in `run()` method.
* `Thread t = new Thread(m)` â†’ `Runnable` object attached to thread.
* `t.start()` begins execution of `run()` in a **separate thread**.
* Main thread prints "World" simultaneously.

---

## **Example 2: Runnable in a Single Class**

```java
public class Test implements Runnable {
  public void run() {
    int i = 1;
    while(true) {
      System.out.println(i + " Hello");
      i++;
    }
  }

  public static void main(String[] args) {
    Test t1 = new Test();       // Create Runnable object
    Thread t = new Thread(t1);  // Attach to Thread
    t.start();                  // Start thread

    int j = 1;
    while(true) {
      System.out.println(j + " World"); // Main thread
      j++;
    }
  }
}
```

**Key Points:**

* Same functionality as previous example.
* Demonstrates a **single-class implementation** using Runnable.
* Thread and main method execute **simultaneously** using separate flows of control.

---

## **Comparison: Thread Class vs Runnable Interface**

| Feature            | Extending `Thread`             | Implementing `Runnable`                                      |
| ------------------ | ------------------------------ | ------------------------------------------------------------ |
| Class type         | Must extend `Thread`           | Can extend another class                                     |
| Method to override | `run()`                        | `run()`                                                      |
| Object creation    | `MyThread t = new MyThread();` | `MyRunnable m = new MyRunnable(); Thread t = new Thread(m);` |
| Flexibility        | Less flexible                  | More flexible (supports inheritance)                         |
| Use case           | Simple programs                | When class already extends another class                     |

---

## **Summary**

* `Runnable` separates **task logic** from **thread mechanism**.
* Threads are created **by attaching Runnable objects** to Thread instances.
* Both `Thread` class and `Runnable` can achieve multi-threading.
* Implementation choice depends on **class design and inheritance requirements**.
* **Control flow:** Main thread + Runnable thread = simultaneous execution.

---

## **Practice Recommendations**

1. Implement both **Thread class** and **Runnable interface** examples on your computer.
2. Modify loops to **print numbers 1â€“10** instead of infinite loops for testing.
3. Observe **mixed output**: â€œHelloâ€ and â€œWorldâ€ printed simultaneously.
4. Experiment with **two Runnable threads** running together.


---

# **ðŸ“˜Demo Multithreading using Thread and Runnable**

---

## **1. Using Thread Class (Two Classes)**

**Steps:**

1. Create a class `MyThread` that **extends `Thread`**.
2. Override the `run()` method to define thread logic:

```java
class MyThread extends Thread 
{
  public void run() {
    int i = 1;
    while(true) {
      System.out.println(i + " Hello");
      i++;
    }
  }
}
```
3. In the main class `ThreadTest`:

   * Create an object of `MyThread`:

     ```java
     MyThread t = new MyThread();
     ```
   * Start the thread:

     ```java
     t.start();
     ```
   * Main method prints `"World"` in its own infinite loop:

     ```java
     int j = 1;
     while(true) {
        System.out.println(j + " World");
        j++;
     }
     ```

**Key Observations:**

* Two threads run **simultaneously**:

  * `MyThread` â†’ prints "Hello"
  * Main thread â†’ prints "World"
* The output order is **non-deterministic** because CPU allocates time slices dynamically.
* Both loops are infinite; must stop manually.

---

## **2. Using Thread Class (Single Class)**

**Modification:**

* Make **main application class** `ThreadTest` extend `Thread`.
* Override `run()` method inside the same class.
* In main method, create object of `ThreadTest` and start thread:

  ```java
  ThreadTest t = new ThreadTest();
  t.start();
  ```
* Main method continues with printing `"World"`.

**Observation:**

* Works the same as two-class version.
* Shows **single-class approach** for multi-threading.

---

## **3. Using Runnable Interface (Single Class or Separate Class)**

**Steps:**

1. Create a class implementing `Runnable`:

   ```java
   class MyRunnable implements Runnable {
       public void run() {
           int i = 1;
           while(true) {
               System.out.println(i + " Hello");
               i++;
           }
       }
   }
   ```
2. In main method:

   * Create object of `MyRunnable`:

     ```java
     MyRunnable r = new MyRunnable();
     ```
   * Attach it to a thread:

     ```java
     Thread t = new Thread(r);
     ```
   * Start thread:

     ```java
     t.start();
     ```
   * Main thread prints `"World"` simultaneously.

**Key Notes:**

* `Runnable` object **cannot run by itself**; it needs a Thread object.
* Useful when class **already extends another class**.
* Minimal changes in code convert **Thread class implementation** to **Runnable implementation**.

---

## **4. Observations Across All Methods**

* Output is **non-deterministic**:

  * Number of `"Hello"` and `"World"` prints varies each run.
* Both threads run **simultaneously** due to CPU time-slicing.
* Choice of **Thread class vs Runnable interface** depends on:

  * Inheritance requirements.
  * Design preferences (single class or multiple classes).

---

# **ðŸ“˜Java Thread States**

---


Threads, like objects or real-world things, have **states** representing their current situation. For example:

* A person: standing, sitting
* A car: running, parked
 
Similarly, a thread can be in different states during its life cycle.

---

## **1. New State**

* **When it occurs:** When a thread object is created.
* **How to enter:** `Thread t = new Thread();`
* **Meaning:** Thread exists but has **not started yet**.

---

## **2. Runnable / Ready State**

* **When it occurs:** After calling `start()` on a thread.
* **Meaning:** Thread is **ready to run** and waiting for CPU scheduling.
* **Transition:** The JVM schedules it to run.

---

## **3. Running State**

* **When it occurs:** JVM calls the `run()` method.
* **Meaning:** Thread is **actively executing its task**.

---

## **4. Terminated / Dead State**

* **When it occurs:** Thread completes execution of `run()`.
* **Meaning:** Thread has **finished its task**.
* **Important:** A terminated thread **cannot be restarted**. To run the same task again, you must create a **new thread object**.

---

## **5. Waiting State**

* **When it occurs:** Thread is waiting for another thread to notify it for for a resource. Waiting to acquire resource.
* **How:** Using `wait()` method.
* **Meaning:** Thread is **inactive but not terminated**, waiting for a condition or signal.

---

## **6. Timed Waiting / Sleep State**

* **When it occurs:** Thread is made to **pause for a specified time**.
* **How:** Using `sleep(milliseconds)` or `join(milliseconds)`.
* **Meaning:** Thread is temporarily inactive, then resumes automatically after the time expires.
* **Use Case:** Animations, controlling speed of operations, etc.

---

## **7. Blocked State**

* **When it occurs:** Thread is **trying to access a resource** that is locked by another thread.
* **Meaning:** Thread is waiting to **acquire a lock or monitor**.
* **Transition:** Once the resource is available, the thread continues execution.

---

## **Example Scenario: Synchronization**

* **Resource:** A file or printer.
* **Threads:** Two threads trying to use the same resource.
* **Coordination:**

  * One thread accesses the resource.
  * The other thread waits (`waiting/blocked state`) until it is notified (`notify()`).
* **Real-world analogy:** One printer, multiple employeesâ€”only one uses it at a time, others wait their turn.

---

## **State Diagram Flow**

```
New -> Runnable -> Running -> Terminated
       |          |
       |       Waiting/Timed Waiting/Blocked
       |          |
       +----------+
```

* **Key Notes:**

  * `wait()` â†’ waiting state
  * `notify()` â†’ moves thread from waiting to runnable
  * `sleep()` â†’ timed waiting, resumes automatically
  * Resource access â†’ may cause blocked state

This is the **introduction to thread states**. Later, synchronization concepts like **locks, monitors, wait, notify** are explored in detail.

---

# **ðŸ“˜Java Thread Priorities**

---


Threads in Java can have **priorities**, which help the **scheduler** decide which thread should get more CPU time.

---

## **1. Ready Queue and Scheduler**

* All threads ready to run are placed in a **ready queue** by the JVM scheduler.
* **CPU executes only one thread at a time**.
* **Time sharing**: CPU time is divided among threads in slices (e.g., 1 second per thread in round-robin fashion).

---

## **2. Concept of Priority**

* Each thread can have a **priority value** from **1 to 10**.

  * **MIN_PRIORITY** = 1
  * **NORM_PRIORITY** = 5 (default)
  * **MAX_PRIORITY** = 10

* **Higher priority threads** get preference:

  * May be executed first.
  * May receive a **larger time slice**.
  * Lower priority threads may have to wait longer (**starvation** can occur if not managed properly).

---

## **3. Practical Examples**

1. **MS Word**

   * **Input thread** (typing) â†’ High priority
   * **Spell-check thread** â†’ High priority
   * **Auto-save thread** â†’ Low priority
   * **Reason:** User input should not be delayed due to auto-saving.

2. **Web Browser (Chrome, IE)**

   * **Data fetching thread** â†’ High priority
   * **Rendering thread** â†’ Lower priority
   * **Reason:** Data must arrive first before rendering it on the screen.

---

## **4. Key Points**

* Thread priorities help **decide CPU allocation**, not guarantee exact execution order.
* Javaâ€™s **JVM scheduler** manages threads; it may use the OS scheduler but **does not depend entirely on it**.
* Developers must **carefully assign priorities** to ensure smooth program execution.

---

# **ðŸ“˜Java Thread Class Overview**

The **Thread class** in Java provides methods and constructors to create and manage threads. Knowing the constructors, getter/setter methods, instance methods, and static methods is important for practical multi-threading.

---

## **1. Constructors**

1. **Default constructor**

   * `Thread t = new Thread();`
   * Thread gets a **unique ID** assigned by JVM.
   * No name or target specified.

2. **Constructor with Runnable target**

   * `Thread t = new Thread(Runnable r);`
   * If a class implements **Runnable**, it cannot run by itself. It needs Thread.
   * Thread object runs the `run()` method of the Runnable class.

3. **Constructor with Runnable and Name**

   * `Thread t = new Thread(Runnable r, String name);`
   * Allows naming the thread for identification.

4. **Constructor with Name only**

   * `Thread t = new Thread(String name);`
   * Thread with a custom name, no Runnable object.

5. **Constructor with Thread Group**

   * `Thread t = new Thread(ThreadGroup g, Runnable r, String name);`
   * Allows **grouping threads** for easier management.
   * Example: Stopping all threads in an animation together.

---

## **2. Getter Methods**

* `getId()` â†’ Returns thread ID.
* `getName()` â†’ Returns thread name.
* `getPriority()` â†’ Returns current priority.
* `getState()` â†’ Returns thread state (`NEW`, `RUNNABLE`, `RUNNING`, `WAITING`, `BLOCKED`, `TERMINATED`).
* `getThreadGroup()` â†’ Returns the threadâ€™s group.

---

## **3. Setter Methods**

* `setName(String name)` â†’ Change thread name.
* `setPriority(int priority)` â†’ Change thread priority.
* `setDaemon(boolean)` â†’ Set thread as **daemon** (background thread, low priority).
  * Example of Daemon Thread: Garbage collector, autosave threads in MsWord.

---

## **4. Inquiry Methods**

* `isAlive()` â†’ Checks if thread is running.
* `isDaemon()` â†’ Checks if thread is a daemon.
* `isInterrupted()` â†’ Checks if thread has been interrupted. 

---

## **5. Important Instance Methods**

1. **`start()`**

   * Initiates a new thread, which calls `run()` internally.

2. **`run()`**

   * Contains the actual code executed by the thread.

3. **`interrupt()`**

   * Interrupts a thread (e.g., stops sleeping or waiting).
   * If a Thread is waiting/sleeping, you can interrupt it and stop it from waiting/sleeping.


4. **`join()`**

   * Makes the calling thread wait until the target thread completes.
   * If main() completes, program terminates even if thread is running.
   * Variants: `join()` (wait until finished), `join(milliseconds)` (wait for limited time).

---

## **6. Static Methods**

1. **`activeCount()`**

   * Returns the number of active threads in the current thread group.

2. **`currentThread()`**

   * Returns the reference to the currently running thread.

3. **`yield()`**

   * Suggests the scheduler **pause current thread** to allow lower priority threads to execute.
   * Prevents **starvation** of low-priority threads.

4. **`dumpStack()`**

   * Prints the **call stack** of the current thread.
   * Helps in debugging and understanding method call sequence.

---

## **7. Key Concepts**

* **Daemon Thread:** Background thread, low priority, no user interaction.
* **Thread Priorities:** `MIN_PRIORITY (1)`, `NORM_PRIORITY (5)`, `MAX_PRIORITY (10)`.
* **Starvation:** High-priority thread monopolizes CPU time.
* **Yield:** Helps give CPU time to lower-priority threads.
* **Join:** Ensures main thread or other threads wait for completion of a thread.

This forms the **core understanding of Java Thread class** for practical multi-threading.

---

# **ðŸ“˜Java Thread Class: Constructors and Methods**

---


## **1. Creating Threads**

### **1.1 Non-parameterized Constructor**

```java
public class ThreadTest
{
  public static void main(String[] args) throws Exception 
  {
    Thread t = new Thread("MyThread1);
    //t.setName("MyThread1");
  }
}
```

* Creates a thread object.
* Thread can be identified using a **name**.

---

### **1.2 Using Runnable Interface**

```java
class MyRun implements Runnable {
  public void run() { /* code */ }
}

public class ThreadTest
{
  public static void main(String[] args) throws Exception 
  {
    Thread t = new Thread(new MyRun(), "RunnableThread");
  }
}

```

* Pass a **Runnable object** to the Thread constructor. Anonymous object !
* Can also pass a **name** along with the Runnable.

---

### **1.3 Extending Thread Class**

```java
class MyThread extends Thread {
  public MyThread(String name) {
    super(name); // call super class constructor
  }
}
public class ThreadTest
{
  public static void main(String[] args) throws Exception 
  {
    MyThread t = new MyThread("My Thread");
  }
}
```

* Pass thread **name** to **super constructor**.
* Allows naming threads created from extended Thread class.

---

## **2. Common Thread Methods (Demo)**

### **2.1 Get Methods**

```java
class MyThread extends Thread {
  public MyThread(String name) {
    super(name); // call super class constructor
  }
}
public class ThreadTest
{
  public static void main(String[] args) throws Exception 
  {
    MyThread t = new MyThread("My Thread");
    System.out.println("ID: " + t.getId());
    System.out.println("Name: " + t.getName());
    System.out.println("Priority: " + t.getPriority());
    System.out.println("State: " + t.getState());
    System.out.println("IsAlive: " + t.isAlive());
  }
}

```

* **getId()** â†’ Thread ID (assigned by JVM)
* **getName()** â†’ Thread name
* **getPriority()** â†’ Priority (1â€“10, default 5)
* **getState()** â†’ Current state (NEW, RUNNABLE, BLOCKED, TERMINATED, etc.)
* **isAlive()** â†’ True if thread is still running

---

### **2.2 Start Thread**

```java
MyThread t = new MyThread("My Thread");
System.out.println("State: " + t.getState());
t.start();
System.out.println("State: " + t.getState());
```

* Changes thread state from **NEW â†’ RUNNABLE**.
* Thread scheduler decides when to execute it.

---

### **2.3 Set Priority**

```java
t.setPriority(Thread.MAX_PRIORITY); // 10
t.setPriority(Thread.MIN_PRIORITY); // 1
t.setPriority(Thread.MIN_PRIORITY + 2); // 3
```

* Priority affects CPU scheduling.
* Helps in **multi-threading fairness** (avoiding starvation).
```java 
class MyThread extends Thread {
  public MyThread(String name) {
    super(name); // call super class constructor
    setPriority(Thread.MAX_PRIORITY); // 10
    setPriority(Thread.MIN_PRIORITY); // 1
    setPriority(Thread.MIN_PRIORITY + 2); // 3
  }
}
```
---

### **2.4 Sleep Method**

```java
class MyThread extends Thread {
  public MyThread(String name) {
    super(name); // call super class constructor
  }
  public void run()
  {
    int count = 1; 
    while(true) {
      System.out.println(count++);
      try {
        Thread.sleep(100); // milliseconds
      } catch (InterruptedException e) {
        System.out.println(e);
      }
    }
  }
}
public class ThreadTest
{
  public static void main(String[] args) throws Exception 
  {
    MyThread t = new MyThread("My Thread");
  }
}
```

* Pauses thread execution temporarily.
* Can control speed of execution (e.g., slow printing or animation).

---

### **2.5 Interrupt**

```java
class MyThread extends Thread {
  public MyThread(String name) {
    super(name); // call super class constructor
  }
  public void run()
  {
    int count = 1; 
    while(true) {
      System.out.println(count++);
      try {
        Thread.sleep(100); // milliseconds
      } catch (InterruptedException e) {
        System.out.println(e);
      }
    }
  }
}
public class ThreadTest
{
  public static void main(String[] args) throws Exception 
  {
    MyThread t = new MyThread("My Thread");
    t.interrupt();
  }
}
```

* Interrupts a sleeping or waiting thread.
* Causes **InterruptedException** to be thrown.
* Can be used to stop waiting threads or handle early termination.

---

## **3. Thread State Observation**

* **Before start()** â†’ NEW
* **After start()** â†’ RUNNABLE
* Use `t.getState()` to check current state.

---

### **4. Demo Example Flow**

1. Create a thread object (extend Thread or use Runnable).
2. Set **name**, **priority** if required.
3. Start thread using `start()`.
4. Control speed with `sleep()`.
5. Interrupt thread if needed with `interrupt()`.
6. Observe thread details with get methods (`getState()`, `isAlive()`, etc.).

---

âœ… **Key Takeaways**

* Thread constructors allow **flexibility in naming and grouping**.
* `sleep()` slows down execution; `interrupt()` can stop sleeping threads.
* Get methods help **debugging and monitoring threads**.
* JVM assigns **ID** automatically; priorities influence scheduling.

---


# **ðŸ“˜Java Thread Methods: Daemon, Join, and Yield**

---

## **1. Daemon Threads**

* **Definition:**
  Daemon threads are **background threads** that depend on the main thread.
  When the main application terminates, daemon threads also terminate automatically.

* **Demo Example:**

```java
class MyThread extends Thread {
  public MyThread(String name) {
    super(name); // call super class constructor
  }
  public void run()
  {
    int count = 1; 
    while(true) {
      System.out.println(count++);
      try {
        Thread.sleep(100); // milliseconds
      } catch (InterruptedException e) {
        System.out.println(e);
      }
    }
  }
}
public class ThreadTest
{
  public static void main(String[] args) throws Exception 
  {
    MyThread t = new MyThread("My Thread");
    t.setDaemon(true); // set thread as daemon
    t.start();
  }
}
```

* **Observation:**

  * Without `sleep` in `main()`, the daemon thread may terminate immediately when `main()` ends.
  * Adding a short sleep allows the daemon thread to execute briefly:

```java
class MyThread extends Thread {
  public MyThread(String name) {
    super(name); // call super class constructor
  }
  public void run()
  {
    int count = 1; 
    while(true) {
      System.out.println(count++);
      try {
        Thread.sleep(100); // milliseconds
      } catch (InterruptedException e) {
        System.out.println(e);
      }
    }
  }
}
public class ThreadTest
{
  public static void main(String[] args) throws Exception 
  {
    MyThread t = new MyThread("My Thread");
    t.setDaemon(true); // set thread as daemon
    t.start();
    try {
      Thread.sleep(100); // main thread sleeps
    } catch(Exception e) {}
  }
}
```

* **Key Point:** Daemon threads cannot prevent the JVM from exiting.

**Use Cases:** Garbage collector, background autosave, periodic logging, etc.

---

## **2. Join Method**

* **Definition:**
  Makes one thread wait for another thread to complete before continuing execution.

* **Demo Example:**

```java
class MyThread extends Thread {
  public MyThread(String name) {
    super(name); // call super class constructor
  }
  public void run()
  {
    int count = 1; 
    while(true) {
      System.out.println(count++);
    }
  }
}
public class ThreadTest
{
  public static void main(String[] args) throws Exception 
  {
    MyThread t = new MyThread("My Thread");
    t.setDaemon(true); // set thread as daemon
    t.start();

    Thread mainThread = Thread.currentThread(); // get reference to main thread
    mainThread.join(); // wait for other threads to complete
  }
}
```

* **Observations:**

  * Even a daemon thread can continue executing if the main thread **joins** it.
  * Join ensures proper synchronization and orderly termination.

* **Key Use:**

  * Waiting for a thread to finish before proceeding.
  * Can be used on main or any other thread.

---

## **3. Yield Method**

* **Definition:**
  Causes the **currently executing thread to give up the CPU** temporarily, allowing other threads to execute.

* **Demo Example:**

```java
class MyThread extends Thread {
  public MyThread(String name) {
    super(name); // call super class constructor
  }
  public void run()
  {
    int count = 1; 
    while(true) {
      System.out.println(count++ + "My thread");
    }
  }
}
public class ThreadTest
{
  public static void main(String[] args) throws Exception 
  {
    MyThread t = new MyThread("My Thread");
    t.setDaemon(true); // set thread as daemon
    t.start();
    
    int count = 1; 
    while(true) {
      System.out.println(count++ + "Main");
    }
  }
}
```

* **Usage:**
`Thread.yield(); // hint to scheduler`

  * Inside an infinite loop:

```java
class MyThread extends Thread {
  public MyThread(String name) {
    super(name); // call super class constructor
  }
  public void run()
  {
    int count = 1; 
    while(true) {
      System.out.println(count++ + "My thread");
    }
  }
}
public class ThreadTest
{
  public static void main(String[] args) throws Exception 
  {
    MyThread t = new MyThread("My Thread");
    t.setDaemon(true); // set thread as daemon
    t.start();
    
    int count = 1; 
    while(true) {
      System.out.println(count++ + "Main");
      Thread.yield(); // allow other threads to run
    }
  }
}
```

* **Observation:**

  * Thread calling `yield()` temporarily pauses to let other threads get CPU time.
  * Example:

  ```
  With yield: MyThread printed more times than main thread.
  Without yield: Both threads printed roughly same amount.
  ```

* **Key Points:**

  * `yield()` is a **hint**, not a guarantee; scheduler decides execution.
  * Helps prevent **CPU starvation** for lower-priority threads.

---

## **4. Combined Observations (Demo)**

* **Daemon Thread:** Ends automatically if main thread terminates.

* **Join:** Forces main thread to wait for other threads.

* **Yield:** Gives CPU time to other threads temporarily.

* **Demo Flow Summary:**

  1. Start `MyThread` (infinite loop).
  2. Set as daemon to observe behavior when main ends.
  3. Use `sleep()` to allow daemon thread execution.
  4. Use `join()` to make main wait for other threads.
  5. Use `yield()` to allow CPU sharing between threads.

---

âœ… **Key Takeaways**

* **Daemon Threads:** Background threads; terminate with main thread.
* **Join Method:** Synchronizes threads; waits for completion.
* **Yield Method:** Allows fair CPU sharing among threads; prevents starvation.
* Combined usage helps **control multi-threaded applications** efficiently.

---


# **ðŸ“˜Java Multithreading: Synchronization Concepts**

---

## **1. Importance of Concepts**

* Understanding **multithreading and synchronization concepts** is more important than syntax.
* Once you know concepts in Java, you can apply them to other languages with minimal syntax learning.
* **Focus:** Understanding or co-ordination in between two entities. Resource sharing, critical section, mutual exclusion, and mechanisms like mutex, semaphore, and monitor.

---

## **2. Key Terms**

### **2.1 Resource Sharing**

* **Definition:** When multiple threads access the same resource (file, printer, data object, network connection).
* **Example:** An object in the heap is accessible by multiple threads.
* **Memory Note:** Each thread has its **own stack**, but object in **heap is shared**.

---

### **2.2 Critical Section**

* **Definition:** The piece of code that **accesses the shared resource** is called a critical section.
* **Example:** If a shared file is accessed by lines 10â€“20 of Thread 1 and lines 15â€“25 of Thread 2, these lines are **critical sections**.

---

### **2.3 Mutual Exclusion (Mutex)**

* **Definition:** Only one thread should access a shared resource at a time. Both should not be using the same object simultaneously.
Mutual Exclusion means happening of one prevents happening of another.
* **Purpose:** Prevents data corruption due to concurrent access.
* **Example:**

  * Two people sending print jobs to the same printer: Without coordination, printouts mix up.
  * With mutual exclusion, only **one thread uses the printer** at a time.

---

## **3. Achieving Synchronization**


### **3.1 Locking/Mutex**

* Each thread checks a **mutex variable** before accessing a shared resource. CPU executes threads in queue in time-sharing or round robin fashion. Suppose there are 2 threads and both requires **Shared Object**

* **Example Flow:**

  1. Thread 1 sees `mutex = 0` â†’ locks it â†’ uses resource â†’ releases lock.
  2. Thread 2 sees `mutex = 1` â†’ waits â†’ tries again later.

So, Thread themeself will try to achieve Synchronization. It is like two people co-ordinating to access same thing. 

* **Problem:**

  * If a thread checks the mutex find it to be free (mutex = 0) but is preempted(time slice over) from CPU queue before locking, another thread may also start using the resource â†’ **race condition**.

Two people saw that washroom is free. They are unaware. So both are using same washroom.

With mutex, two threads are coordinating by just one variable. They may fight. So we need some system. In olden days before Java, OS was supposed to take care of it.


---

### **3.2 Semaphore**

* **Definition:** OS-level mechanism to control access to shared resources.

* **Methods:** `wait()` (acquire), `signal()` (release) are provided by OS

* **How it works:**

  1. Thread calls `wait()` â†’ if resource is free, it locks it.
  2. If resource is busy, thread moves to a **blocked queue** from **ready queue**
  3. When thread finishes use of resource, it is released by calling `signal()` methods and that blocked thread moves back to the **ready queue**.

- Blocked Queue is maintained by Semaphore and contains Threads waiting to access shared resource. 
- Ready Queue contains Threads waiting to access CPU

* **Example:**

  * ATM analogy: Security person ensures **only one person enters at a time**; others wait in queue.
  * Thread 1 uses resource â†’ signal â†’ Thread 2 from blocked queue gets resource.

* **Advantages:** Solves race conditions present with simple mutex.

---

### **3.3 Monitor (Modern OOP Approach)**

* Monitors were introduced for **object-oriented multithreading**.
* Java uses **monitors** to synchronize access to shared objects (via `synchronized` keyword).
* Conceptually, a monitor is like a **watchman for shared resources**, ensuring **mutual exclusion and coordination** automatically.

---

## **4. Summary of Synchronization Concepts**

| Concept          | Definition                            | Example                               |
| ---------------- | ------------------------------------- | ------------------------------------- |
| Resource Sharing | Multiple threads access same resource | Shared object in heap                 |
| Critical Section | Code accessing shared resource        | Lines of code modifying shared object |
| Mutual Exclusion | Only one thread accesses at a time    | Printer/ATM analogy                   |
| Mutex            | Simple variable lock                  | Thread sets `mutex=1` before using    |
| Semaphore        | OS-level queue system                 | `wait()` and `signal()` methods       |
| Monitor          | Modern OOP synchronization            | Java `synchronized` methods/blocks    |

---

## **5. Key Takeaways**

* Synchronization prevents **race conditions** and ensures **data consistency**.
* Manual locks (mutex) are simple but **error-prone**.
* Semaphores introduce **OS-level blocking and signaling** for safe access.
* Monitors in Java provide **automatic, safer synchronization** in multithreading.


---

#  **What is Monitor in Java (via Mutex & Semaphore Comparison)**

### 1. Learning Objectives

By the end of this lesson, a learner should be able to:

* Explain **mutual exclusion** and **critical section**
* Differentiate between **Mutex**, **Semaphore**, and **Monitor**
* Understand **how Java implements monitors using `synchronized`**
* Identify **who is responsible** for locking, unlocking, and coordination in each mechanism
* Conceptually map monitors to **object-oriented programming**

---

### 2. Prerequisite Knowledge

Learners should already understand:

* Threads and shared data
* Race conditions
* Mutex (lock/unlock)
* Semaphore (wait/signal)

---

### 3. Conceptual Progression

---

## A. Mutex (Thread-Controlled Synchronization)

### Core Idea

* **Threads themselves manage synchronization**
* Locking and unlocking is **explicit**
* Critical section is **inside the thread**

### Structure

* Suppose there is Shared data 
* A Mutex (lock) is maintained
* Threads explicitly do:

  ```
  lock()
  read()
  write()
  unlock()
  ```

### Responsibility

| Task             | Responsible Entity |
| ---------------- | ------------------ |
| Locking          | Thread             |
| Unlocking        | Thread             |
| Read/Write logic | Thread             |
| Mutual Exclusion | Thread             |

### Key Insight

* High responsibility on the programmer
* Easy to make mistakes (forget unlock, deadlock)

---

## B. Semaphore (OS-Controlled Synchronization)

### Core Idea

* **Operating System assists synchronization**
* Threads request access using `wait()` and `signal()`

### Structure

* Shared data
* Semaphore
* OS-managed **blocking queue**

### Flow

1. Thread calls `wait()`
2. OS checks availability
3. If unavailable â†’ thread waits in queue
4. On `signal()`, OS wakes next thread

### Responsibility

| Task             | Responsible Entity |
| ---------------- | ------------------ |
| Locking          | Operating System   |
| Unlocking        | Operating System   |
| Queue management | Operating System   |
| Read/Write logic | Thread             |

### Key Insight

* Safer than mutex
* Still **procedural**, not object-oriented

---

## C. Monitor (Object-Oriented Synchronization)

### Core Idea

> **Synchronization is built into the object itself**

This is where **Java shines**.

---

### What is a Monitor?

A **monitor** is:

* A shared **object**
* That contains:

  * Data
  * Methods (read/write)
  * Lock/Mutex
  * Waiting queue
* And enforces **mutual exclusion automatically**

---

### Structure

Everything is bundled inside **one object**:

```
Object (Monitor)
 â”œâ”€â”€ Data
 â”œâ”€â”€ Synchronized methods - read() & write()
 â”œâ”€â”€ Lock (implicit)
 â””â”€â”€ Queue (implicit)
```

---

### How Threads Interact

Threads **do not**:

* Lock
* Unlock
* Manage queues
* Know synchronization logic

Threads simply:

```java
sd.read();
sd.write();
```

The **object decides**:

* Who enters
* Who waits
* When to allow access

---

### Responsibility

| Task             | Responsible Entity |
| ---------------- | ------------------ |
| Locking          | Object             |
| Unlocking        | Object             |
| Queue management | Object             |
| Mutual Exclusion | Object             |
| Thread behavior  | Just call methods  |

---

### Java Implementation

Java provides monitors via:

```java
synchronized
```

Example:

```java
class SharedData {
    synchronized void read() {
        // critical section
    }

    synchronized void write() {
        // critical section
    }
}
```

âž¡ Java automatically:

* Creates a lock
* Manages entry
* Blocks waiting threads
* Releases lock on method exit

---

## D. Intuitive Analogy: Barber Shop ðŸª’

| Monitor Concept | Barber Shop Analogy |
| --------------- | ------------------- |
| Object          | Barber shop         |
| Method call     | Asking for service  |
| Lock            | Barber chair        |
| Queue           | Waiting customers   |
| Thread          | Customer            |

* If chair is free â†’ get service
* If not â†’ wait in queue
* Customer doesnâ€™t manage queue or chair

---

## E. Comparison Summary

| Feature       | Mutex  | Semaphore  | Monitor            |
| ------------- | ------ | ---------- | ------------------ |
| Lock location | Thread | OS         | Object             |
| Queue         | No     | OS-managed | Object-managed     |
| OOP support   | âŒ      | âŒ          | âœ…                  |
| Ease of use   | Hard   | Medium     | Easy               |
| Java native   | âŒ      | âŒ          | âœ… (`synchronized`) |

---

### 4. Common Confusion Points (Clarified)

* **Monitor â‰  OS feature**
  â†’ Monitor is a **language-level (Java) abstraction**

* **Threads do NOT manage locks in monitors**

* **`synchronized` automatically creates a monitor**

* **Read/write logic belongs to the object, not the thread**

---

### 5. Quality & Accuracy Notes

âœ” Conceptually correct
âœ” Matches standard OS & Java definitions
âš  Simplification note: JVM still uses OS primitives internally, but **this is abstracted away** from the programmer (good abstraction, not an error)

---

## Summary (Quick Revision)

* **Mutex**: Threads handle everything manually
* **Semaphore**: OS helps with locking and waiting
* **Monitor**: Object handles everything
* Java implements monitors using the `synchronized` keyword
* Monitors align naturally with **object-oriented programming**
* Threads only call methods â€” synchronization is automatic



---

# **MultiThreading using Montior**

---

## **1. Problem Statement**

* **Objective:** Two threads share a single object and call a method to print strings letter by letter.
* **Example Strings:**

  * Thread 1 â†’ `"Hello World"`
  * Thread 2 â†’ `"Welcome"`
* **Without synchronization:** Letters from both strings can interleave, producing **mixed output** like `"HeWel llo"`.

---

## **2. Program Structure**

### **2.1 Shared Object**

* **Class:** `MyData`
* **Method:** `display(String str)`

  * Prints letters of a string **one by one**.
  * Shared between both threads.
```java 
class MyData {
  void display(String str) {
    for(int i=0;i<str.length();i++) {
      System.out.println(str.charAt(i));
    }
  }
}
```

### **2.2 Threads**

* **Class:** `MyThread1 extends Thread`

  * Has a **reference to `MyData` object**.
  * `run()` method calls `d.display("Hello World")`.
* **Class:** `MyThread2 extends Thread`

  * Similar to `MyThread1`, calls `d.display("Welcome")`.
```java 
class MyThread1 extends Thread {
  MyData d; 
  MyThread1(MyData data) {
    d = data;
  } 
  public void run() {
    d.display("Hello World");
  }
}
class MyThread2 extends Thread {
  MyData d; 
  MyThread2(MyData data) {
    d = data;
  } 
  public void run() {
    d.display("Welcome");
  }
}



```
### **2.3 Main Method**

* Create **single `MyData` object**.
* Create **two thread objects** passing the same `MyData` reference.
* Start both threads using `start()`.
```java 
public class Test 
{
  public static void main(String[] args) {
    MyData d = new MyData();
    MyThread1 t1 = new MyThread1(d);
    MyThread2 t2 = new MyThread2(d);
    t1.start();
    t2.start();
  }
}
```
---

## **3. Problem Without Synchronization**

* Both threads may call `display()` simultaneously.
* Letters from both strings **can interleave**.
* Example output (unsynchronized):

  ```
  HWele llocom
  ```
* This demonstrates the need for **monitor-based synchronization**.

---

## **4. Synchronization Using Monitor**

### **4.1 Method 1: Synchronized Block**

```java
class MyData {
  void display(String str) {
    synchronized(this) {  // 'this' refers to the shared object
      for(int i = 0; i < str.length(); i++) {
        System.out.print(str.charAt(i));
      }
      System.out.println();
    }
  }
}
```

* Only **one thread can enter the synchronized block** at a time.
* Ensures **letters from a single thread are printed completely** before another thread enters.

### **4.2 Method 2: Synchronized Method**

```java
class MyData {
  synchronized void display(String str) {
    for(int i = 0; i < str.length(); i++) {
      System.out.print(str.charAt(i));
    }
    System.out.println();
  }
}
```

* Entire method is treated as **critical section**.
* Simplest and most common way in Java.

---

## **5. Key Points**

1. **Monitor** ensures **mutual exclusion** automatically.
2. Java handles **waiting queue and notifications** internally.
3. Threads simply **call the method**:

   * If free â†’ allowed
   * If busy â†’ waits automatically
4. Two ways to implement:

   * **Synchronized block** â†’ part of method
   * **Synchronized method** â†’ whole method

---

## **6. Output With Synchronization**

* Letters from a single thread are printed **sequentially**.
* Example:

  ```
  Hello World
  Welcome
  ```
* No interleaving occurs.

---

How **Javaâ€™s monitors** provide **easy, thread-safe access** to shared objects.

---


# **ðŸ“˜Java Monitors Example â€“ Synchronization**

---

## **1. Problem Overview**

* **Goal:** Two threads share a single object and call a method to display strings **letter by letter**.
* **Example Strings:**

  * Thread 1 â†’ `"Hello World"`
  * Thread 2 â†’ `"Welcome"`
* **Without synchronization:** Letters may interleave:

  ```
  HeWel llo
  ```
* **Desired behavior:** Only **one thread at a time** should access the shared object. Full string prints sequentially.

---

## **2. Program Components**

### **2.1 Shared Object**

* **Class:** `MyData`
* **Method:** `display(String str)`

  * Prints the string **one character at a time**.
  * Shared between both threads.

### **2.2 Threads**

* **Thread Classes:**

  * `MyThread1` â†’ prints `"Hello World"`
  * `MyThread2` â†’ prints `"Welcome"`
* Both extend `Thread` and **contain a reference** to the shared `MyData` object.
* **Constructor:** Accepts the shared `MyData` object.
* **run() method:** Calls `display()` on the shared object.

### **2.3 Main Method**

* **Create objects:**

  1. Shared object: `MyData d = new MyData();`
  2. Thread 1: `MyThread1 t1 = new MyThread1(d);`
  3. Thread 2: `MyThread2 t2 = new MyThread2(d);`
* **Start threads:** `t1.start(); t2.start();`

---

## **3. Problem Without Synchronization**

* Threads access `display()` simultaneously.
* Output letters are **mixed**, showing no control over sequence.

---

## **4. Synchronization Using Monitor**

### **4.1 Method 1: Synchronized Block**

```java
void display(String str) {
  synchronized(this) {  // 'this' refers to shared object
    for(int i = 0; i < str.length(); i++) {
      System.out.print(str.charAt(i));
    }
    System.out.println();
  }
}
```

* Only **one thread at a time** can enter the synchronized block.
* Ensures **complete printing of one string** before another thread starts.

### **4.2 Method 2: Synchronized Method**

```java
synchronized void display(String str) {
  for(int i = 0; i < str.length(); i++) {
    System.out.print(str.charAt(i));
  }
  System.out.println();
}
```

* Entire method is a **critical section**.
* Simplest way to enforce **mutual exclusion** in Java.

---

## **5. Key Points**

1. **Monitor** ensures mutual exclusion automatically.
2. Java handles **waiting queue** and **notification** internally.
3. Threads simply **call the method**:

   * If free â†’ allowed
   * If busy â†’ waits automatically
4. Two approaches:

   * **Synchronized block** â†’ part of method
   * **Synchronized method** â†’ entire method

---

## **6. Output With Synchronization**

* Letters from one thread print completely before the next thread:

  ```
  Hello World
  Welcome
  ```

---

âœ… **Summary:**

* Monitors in Java are used to **control access to shared resources**.
* Java provides simple syntax with `synchronized` keyword to ensure **one thread at a time** can execute a method/block of code.
* Conceptually, the shared object itself acts as the **monitor**, controlling access without requiring explicit OS intervention.

---

# **ðŸ“˜ATM Synchronization Example**

---

## **1. Problem Statement**

* **Scenario:**

  * One ATM in the locality.
  * Multiple customers want to use it.
  * Only **one customer can use the ATM at a time**.
* **Operations:**

  * `checkBalance(customerName)` â†’ prints a message that the customer is checking balance.
  * `withdraw(customerName, amount)` â†’ prints a message that the customer is withdrawing a specific amount.
* **Goal:** Implement **synchronization** so only one customer uses ATM at a time, even with delays (`Thread.sleep()`).

---

## **2. Classes and Structure**

### **2.1 ATM Class**

* **Methods:**

  * `checkBalance(String name)` â†’ prints `name + " checking balance"`, with sleep to simulate delay.
  * `withdraw(String name, int amount)` â†’ prints `name + " withdrawing " + amount`, with sleep.
* **Synchronization:**

  * Add `synchronized` keyword to methods to make them **thread-safe**, ensuring only one customer uses ATM at a time.

  ```java
  public synchronized void checkBalance(String name) { ... }
  public synchronized void withdraw(String name, int amount) { ... }
  ```

### **2.2 Customer Class**

* Extends `Thread` to implement multithreading.
* **Properties:**

  * `String name` â†’ Customer name
  * `int amount` â†’ Amount to withdraw
  * `ATM atm` â†’ Reference to the shared ATM object
* **Constructor:** Initializes the above properties.
* **Method:** `useATM()`

  * Calls `atm.checkBalance(name)`
  * Calls `atm.withdraw(name, amount)`
* **Thread Execution:**

  * Override `run()` â†’ call `useATM()`

  ```java
  @Override
  public void run() {
    useATM();
  }
  ```

### **2.3 Main Method**

* Create **one ATM object**:

  ```java
  ATM atm = new ATM();
  ```
* Create **multiple customers**, passing the **same ATM object**:

  ```java
  Customer c1 = new Customer("Smith", 100, atm);
  Customer c2 = new Customer("John", 200, atm);
  ```
* Start threads:

  ```java
  c1.start();
  c2.start();
  ```

---
```java 
class ATM
{
    
  public void checkBalance(String name)
  {
    System.out.print(name + " Checking ");
    
    try{Thread.sleep(1000);}catch(Exception e){}
    
    System.out.println("Balance");
  }
  
  public void withdraw(String name,int amount)
  {
    System.out.print(name + " withdrawing "); 
    
    try{Thread.sleep(1000);}catch(Exception e){}
    
    System.out.println(amount);      
  }
}

class Customer extends Thread
{
  String name;
  int amount;
  ATM atm;
  
  Customer(String n,ATM a,int amt)
  {
    name=n;
    atm=a;
    amount=amt;
  }
  public void useATM()
  { 
    atm.checkBalance(name);
    atm.withdraw(name, amount);
  }
  public void run()
  {
    useATM();
  }
}

public class TestThread 
{
  public static void main(String[] args) 
  {
    ATM atm=new ATM(); //Shared Object
    Customer c1=new Customer("Smith",atm,100);
    Customer c2=new Customer("John",atm,200);
    c1.start();
    c2.start();     
  }   
}
```

## **3. Behavior Without Synchronization**

* Both threads can access ATM simultaneously.
* Output may be **interleaved**:

  ```
  John checking
  Smith checking
  John balance
  Smith balance
  John withdrawing
  Smith withdrawing
  ```
* Messages mix because `sleep()` gives other threads CPU time.

---

## **4. Achieving Synchronization**

* Add `synchronized` to ATM methods:

  ```java
  public synchronized void checkBalance(String name) { ... }
  public synchronized void withdraw(String name, int amount) { ... }
  ```

* **Effect:**

  * One thread enters the method.
  * Other threads **wait** until the current thread finishes.
  * Prevents **simultaneous access** and interleaving.

* Output after synchronization:

  ```
  Smith checking balance
  Smith balance
  Smith withdrawing 100
  John checking balance
  John balance
  John withdrawing 200
  ```

---

## **5. Key Concepts**

* **Monitor:** The ATM object acts as a monitor. Only one thread can execute its synchronized methods at a time.
* **Critical Section:** The part of code (`checkBalance` + `withdraw`) that must not be concurrently executed.
* **Thread.sleep()** does not break synchronization; other threads cannot enter until the monitor is released.

---

âœ… **Summary:**

* One shared object (`ATM`) â†’ acts as a monitor.
* Multiple threads (`Customer`) â†’ reference same ATM object.
* `synchronized` keyword â†’ ensures only one thread uses ATM at a time.
* Demonstrates **real-life synchronization** scenario using Java multithreading.

---

# **ðŸ“˜Synchronization: Interthread Communication & Race Conditions**

---

## **1. Interthread Communication (Producer-Consumer Example)**

### **Scenario**

* Shared object (`data`) accessed by two threads:

  1. **Producer** â†’ writes data to shared object.
  2. **Consumer** â†’ reads data from shared object.

* Goal: Ensure **coordinated access** so:

  * Producer writes only if consumer has read previous data.
  * Consumer reads only if producer has written new data.

---

### **Mechanism**

* Use a **flag** to control turns:

  * `true` â†’ Producerâ€™s turn
  * `false` â†’ Consumerâ€™s turn
* Steps:

  1. Producer checks flag â†’ if `true`, produces data and sets flag to `false`.
  2. Consumer checks flag â†’ if `false`, consumes data and sets flag to `true`.
* Ensures orderly **communication between threads**.

---

### **Diagrammatic Understanding**

* Producer writes â†’ Consumer waits in Blocked Queue
* Producer finishes â†’ Consumer reads â†’ Producer waits in Blocked Queue
* Process repeats in turns

---

## **2. Race Conditions**

### **Scenario**

* One producer, **multiple consumers** (e.g., 3 consumers).
* Instead of flag we'll make use of **count**. 
  - Initially when count=0, then producer will write() and make count=1. 
  - Then consumer 1 will read() and make count=2. 
  - Then consumer 2 will read() and make count=3. 
  - Then consumer 3 will read() and reset count=0. 
* Shared object is accessed by multiple threads in an uncontrolled manner.

### **Problem**
* Producer will write() in shared object and wait in Blocked Queue. 
* Consumer 1 will read() from shared object and notify() which can wake up any thread from Blocked Queue
* Threads may **wake up simultaneously** after a `notify()`.
* **Race condition** occurs if:

  * Multiple consumers or producer and consumers try to access shared resource at the same time.
  * Access order is not controlled â†’ may violate intended sequence.

---

### **Illustration**

* Producer writes data â†’ notifies all waiting threads.
* Any thread may wake up â†’ **unpredictable access** order.
* Example:

  * Producer should wait until **all consumers have consumed**.
  * If producer wakes up too early â†’ violates expected sequence.

---

### **Solution**

* Use a **counter variable** (`count`) to track turns:

  * `count = 0` â†’ Producerâ€™s turn
  * `count = 1,2,3` â†’ Consumer 1,2,3 turn
* Steps:

  1. Producer produces â†’ sets `count = 1`
  2. Consumer 1 consumes â†’ `count = 2`
  3. Consumer 2 consumes â†’ `count = 3`
  4. Consumer 3 consumes â†’ resets `count = 0` â†’ back to Producer
* Ensures **strict order of execution** â†’ avoids race conditions.

---

### **Key Concepts**

1. **Interthread Communication:**

   * Threads coordinate with each other using shared flags or counters.
   * Example: Producer signals consumer after producing.
2. **Race Condition:**

   * Occurs when multiple threads compete to access a shared resource.
   * Can lead to **incorrect or inconsistent results**.
   * Solution: Use counters, flags, or other mechanisms to enforce order.
3. **notify() and wait():**

   * `wait()` â†’ thread waits for its turn.
   * `notify()` â†’ wakes up waiting thread.
   * Race conditions occur if **any thread can wake up and access** without checking turn.

---

### **Analogy**

* **Producer:** Teacher writing on board
* **Consumers:** Students copying from board
* **Rule:** Teacher waits until all students have copied; students wait until teacher writes next.

---

âœ… **Summary:**

* Basic synchronization ensures **mutual exclusion** (like ATM example).
* Interthread communication allows **ordered coordination** (Producer-Consumer).
* Race conditions occur when **order of access is uncontrolled**, especially with multiple consumers or threads.
* Flags or counters enforce **correct turn-taking** to prevent race conditions.

---
# **ðŸ“˜Producer-Consumer Interthread Communication Example**

---

## **1. Problem Recap**

* **Shared object**: `MyData` contains a single integer value.
* **Producer thread**: Writes values into `MyData`.
* **Consumer thread**: Reads values from `MyData`.
* Goal: Make Producer and Consumer work **hand in hand**, one by one.
* Without proper communication:

  * Consumer may read the same value multiple times.
  * Producer may overwrite values before consumer reads them.
* **Solution**: Use a **flag variable** + `wait()` and `notify()` methods.

---

## **2. Shared Object Class: MyData**

```java
class MyData {
  private int value = 0;
  private boolean flag = true; // true = Producer's turn, false = Consumer's turn

  // Producer writes value
  public synchronized void set(int v) {
    while(flag != true) {
      try { wait(); } catch(Exception e) {}
    }
    value = v;      // Set value
    flag = false;   // Switch turn to consumer
    notify();       // Wake up consumer
  }

  // Consumer reads value
  public synchronized int get() {
    while(flag != false) {
      try { wait(); } catch(Exception e) {}
    }
    int x = value;  // Get value
    flag = true;    // Switch turn to producer
    notify();       // Wake up producer
    return x;
  }
}
```

---

## **3. Producer Thread**

```java
class Producer extends Thread {
  MyData data;

  public Producer(MyData d) { data = d; }

  public void run() {
    int count = 1;
    while(true) {
      data.set(count);  // Set value in shared object
      System.out.println("Producer produced: " + count);
      count++;
    }
  }
}
```

---

## **4. Consumer Thread**

```java
class Consumer extends Thread {
  MyData data;

  public Consumer(MyData d) { data = d; }

  public void run() {
    while(true) {
      int value = data.get();   // Get value from shared object
      System.out.println("Consumer consumed: " + value);
    }
  }
}
```

---

## **5. Main Method**

```java
public class Main {
  public static void main(String[] args) {
    MyData data = new MyData();   // Shared object

    Producer p = new Producer(data);
    Consumer c = new Consumer(data);

    p.start();  // Start producer thread
    c.start();  // Start consumer thread
  }
}
```

---

## **6. Key Concepts**

1. **Synchronization (`synchronized` keyword)**

   * Ensures that only one thread can execute `set()` or `get()` at a time.

2. **Flag Variable**

   * Controls **turn-taking**:

     * `true` â†’ Producerâ€™s turn
     * `false` â†’ Consumerâ€™s turn

3. **wait()**

   * Thread releases lock and waits for its turn.
   * Must be inside a `while` loop to prevent **spurious wake-ups**.

4. **notify()**

   * Wakes up one waiting thread (here, the other thread).

5. **Result**

   * Producer and Consumer work **hand in hand**, producing and consuming **one value at a time**:

     ```
     Producer produced: 1
     Consumer consumed: 1
     Producer produced: 2
     Consumer consumed: 2
     ...
     ```

---

âœ… **Summary:**
This is the classic **Producer-Consumer problem with interthread communication**. Using just **synchronized** is not enough because Producer thread is using set() and Consumer thread is using get(). Both are separate methods. No more than one Producer can use set() and no more than one Consumer can use get(). But they can use different method at same time. 
Hence, using a **flag + wait/notify**, we ensure strict alternation of access to the shared resource. This pattern can be extended for multiple producers and consumers, using `notifyAll()` instead of `notify()`.

---


# **ðŸ“˜Teacher-Student-Whiteboard Problem (Multi-threading)**

---

## **1. Problem Overview**

* **Producer:** Teacher
* **Consumers:** Multiple Students
* **Shared Resource:** Whiteboard
* **Goal:**

  * Teacher writes a statement on the whiteboard.
  * All students read it before the teacher writes the next statement.
  * Process continues statement by statement until the last statement ("end").

---

## **2. Whiteboard Class**

**Responsibilities:**

1. Hold the **current text**.
2. Track the **number of students** (`numStudents`).
3. Track how many students have read the current text (`count`).
4. **Synchronization:** Ensure the teacher waits until all students read before writing the next statement.

**Key Methods:**

```java
class Whiteboard {
  private String text;
  private int numStudents = 0;
  private int count = 0;

  // Increment the number of students attending
  public synchronized void attendance() {
    numStudents++;
  }

  // Teacher writes a statement
  public synchronized void write(String message) {
    System.out.println("Teacher wrote " + message);
    while(count != 0) {  // Wait until all students have read
      try { wait(); } catch(Exception e) {}
    }
    text = message;
    count = numStudents;  // Reset counter for students
    notifyAll();          // Wake up all students
  }

  // Student reads the statement
  public synchronized String read() {
    while(count == 0) {   // Wait until teacher writes
      try { wait(); } catch(Exception e) {}
    }
    String t = text;      // Read text
    count--;              // Decrement counter
    if(count == 0) notify(); // Notify teacher if all students read
    return t;
  }
}
```

---

## **3. Teacher Thread**

* Extends `Thread`.
* Has a reference to **Whiteboard**.
* Writes statements **one by one** using `whiteboard.write()`.
* Last statement is `"end"`.

```java
class Teacher extends Thread {
  private Whiteboard wb;
  private String[] notes = {
    "Java is language", "OOPs", "Platform independent", "Thread supported", "end"
  };

  public Teacher(Whiteboard wb) { this.wb = wb; }

  public void run() {
    for(int i=0;i<notes.length();i++)
      wb.write(notes[i]);
    // for(String note : notes) {
    //   wb.write(note);
    //   System.out.println("Teacher wrote: " + note);
    // }
  }
}
```

---

## **4. Student Thread**

* Extends `Thread`.
* Has a **name** and reference to **Whiteboard**.
* Calls `attendance()` in constructor or `run()` to register with whiteboard.
* Reads statements **in a loop** until `"end"` is read.
* Prints the message read from the whiteboard.

```java
class Student extends Thread {
  private String name;
  private Whiteboard wb;

  public Student(String name, Whiteboard wb) {
    this.name = name;
    this.wb = wb;
    wb.attendance(); // Register student
  }

  public void run() {
    String message = "";
    while(!message.equals("end")) {
      message = wb.read();
      System.out.println(name + " reads: " + message);
      System.out.flush();
    }
  }
}
```

---

## **5. Main Method**

```java
public class Classroom {
  public static void main(String[] args) {
    Whiteboard wb = new Whiteboard();

    Teacher t = new Teacher(wb);

    Student s1 = new Student("1. John", wb);
    Student s2 = new Student("2. Ajay", wb);
    Student s3 = new Student("3. Kloob", wb);
    Student s4 = new Student("4. Smith", wb);

    t.start();
    s1.start();
    s2.start();
    s3.start();
    s4.start();
  }
}
```

---

## **6. How It Works**

1. **Teacher writes:** Only when `count == 0` (all students have read previous statement).
2. **Students read:** Wait if `count == 0` (teacher hasnâ€™t written yet).
3. **Counter (`count`) decrements** each time a student reads.
4. When `count == 0`, teacher is notified to write next statement.
5. Process repeats until `"end"` is written and read by all students.

**Key points:**

* `synchronized` ensures only one thread enters `write` or `read` at a time.
* `wait()` and `notify/notifyAll()` manage turn-taking.
* `numStudents` allows multiple students to read a single statement.
* Output order may vary because of multithreading, but **all students read every statement**.

---

âœ… **Summary:**
This is a **multi-consumer extension of Producer-Consumer**:

* Teacher = producer
* Students = consumers
* Whiteboard manages synchronization, turn-taking, and counting.

---


# **üìò Inheritance in Java ‚Äî Generalization & Specialization Explained Clearly**

Inheritance is one of the most important concepts in Object-Oriented Programming. Before understanding inheritance in Java, you must clearly understand **generalization** and **specialization**, because inheritance is directly related to these two ideas.

---

# **1. Generalization vs Specialization (Core OOP Thinking)**

Both concepts form a **hierarchy** (parent ‚Üí children), but they work in opposite directions.

---

# **üìç A. Generalization (Bottom-Up Approach)**

Generalization means **grouping several specific things into one common category**.

### **Examples**

- iPhone, Samsung, Vivo ‚Üí grouped together as **Smartphones**
- Car, Bike, Ship ‚Üí grouped together as **Vehicles**
- Triangle, Rectangle, Circle ‚Üí grouped as **Shapes**

### **Key Idea**

The **specialized things existed first**, and then later we created a generalized term.

### **Bottom-Up**

Specific ‚Üí Common
iPhone + Samsung + Vivo ‚Üí Smartphone

### **Why do we do this?**

- To **refer to many objects using one name**
- To **handle multiple classes together**
- To make classification easier

### **In Java**

Generalization is achieved using:

- **Interfaces**, or
- **Abstract classes**

---

# **üìç B. Specialization (Top-Down Approach)**

Specialization means **creating a more detailed version of an already existing category**.

### **Examples**

- iPhone 10 to iPhone 11 Pro
- Car ‚Üí Fortuner to XUV700
- Circle to Cylinder (Circle + height)
- Guitar to Electric Guitar

### **Key Idea**

The **general concept existed first**, and then you create more specific versions.

### **Top-Down**

General ‚Üí Specific
Smartphone ‚Üí iPhone 15 Pro

### **In Java**

Specialization is achieved using:

- **Inheritance (extends keyword)**
- Subclass extends superclass.

---

# **2. Difference Between Generalization & Specialization**

| Concept            | Direction | Example                       | Achieved Using                |
| ------------------ | --------- | ----------------------------- | ----------------------------- |
| **Generalization** | Bottom-Up | iPhone + Samsung ‚Üí Smartphone | Interfaces / Abstract classes |
| **Specialization** | Top-Down  | Car ‚Üí Fortuner                | Inheritance (`extends`)       |

Both create **hierarchical relationships**, but the flow is different.

---

# **3. Why Is This Important?**

To think in an object-oriented way, you must know:

- When to group classes (generalization)
- When to derive new classes (specialization)
- How Java provides features to implement both

Once you understand this, you can design cleaner class structures.

---

# **4. How Java Achieves These Concepts**

### **A. Inheritance (specialization)**

Used when:

- You have a general class (Vehicle)
- You want to create a specialized class (Car, Bike)

Syntax:

```java
class Car extends Vehicle { }
```

### **B. Interfaces (generalization)**

Used when:

- You want different classes to fall under one common type

### **C. Abstract Classes (middle ground)**

Used when:

- You need partial implementation + generalization + specialization mixture

---

# **5. Visual Summary (Hierarchy)**

```
Generalization (Bottom-Up)
iPhone
Samsung
Vivo
   ‚Üë
   |  group them
   |
Smartphone
```

```
Specialization (Top-Down)
Smartphone
   |
   |  extend with more features
   ‚Üì
iPhone X
```

---

# **Final Note**

Generalization and Specialization are **thinking tools**.
Inheritance, Abstract Classes, and Interfaces are **Java tools** built to implement this thinking.

Once your mindset aligns with these concepts, you naturally think like an OOP designer.

---

# **üìò What is Inheritance**

## **1. Definition of Inheritance**

**Inheritance** is the process of **acquiring the properties and methods of an existing class (parent class) into a new class (child class).**

> **Child class = Parent class features + Extra features**

Example:

- `Circle` ‚Üí has **radius**
- `Cylinder` ‚Üí has **radius** (inherited from Circle) + **height**

So `Cylinder` **inherits** from `Circle`.

---

## **2. Why Use Inheritance?**

Inheritance supports these ideas:

### ‚úî Code Reusability

No need to rewrite radius, area, perimeter for cylinder.

### ‚úî Specialization

Child class adds extra features (height, volume).

### ‚úî Logical Hierarchy

Circle ‚Üí Cylinder
Rectangle ‚Üí Cuboid
Shape ‚Üí Triangle, Rectangle, Circle

---

## **3. The Example Code**

```java

package circle1;

class Circle
{
	public double radius;

	public double area()
	{
		return Math.PI * radius *radius;
	}

	public double perimeter()
	{
		return 2*Math.PI*radius;
	}
	public double circumference()
	{
		return perimeter();
	}
}

class Cylinder extends Circle
{
	public double height;

	public double volume()
	{
		return area()*height;
	}
}


public class Circle1
{
	public static void main(String[] args)
	{
		Cylinder c=new Cylinder();

		c.radius=7;
		c.height=10;

		System.out.println("Volume "+c.volume());
		System.out.println("Area "+c.area());
	}
}
```

### **Parent Class ‚Äî Circle**

Properties:

- `radius`

Methods:

- `area()`
- `perimeter()`

Constructor:

- takes `radius`

### **Child Class ‚Äî Cylinder**

Properties:

- inherits `radius`
- adds `height`

Methods:

- inherits `area()`, `perimeter()`
- adds `volume()`

Constructor:

- takes both `radius` and `height`

---

## **4. Syntax of Inheritance in Java**

```java
class Cylinder extends Circle {
    // new features + inherited features
}
```

Keyword: **extends**

---

## **5. How Objects Are Formed in Inheritance**

### **Circle c1 = new Circle();**

Object includes:

- radius
- Circle constructor
- area()
- perimeter()

### **Cylinder c2 = new Cylinder();**

Object includes:

- radius (inherited from Circle)
- height (own property)
- both constructors (Circle + Cylinder)
- area()
- perimeter()
- volume()

---

## **6. What Can You Call on Each Object?**

### On Circle object:

- c1.area()
- c1.perimeter()

### On Cylinder object:

- c2.area() ‚úî (inherited)
- c2.perimeter() ‚úî (inherited)
- c2.volume() ‚úî (own method)

---

## **7. Two Important Terms**

### **(1) Available**

All inherited properties and methods _exist inside the child class_.

### **(2) Accessible**

Whether the child class can actually _use_ them depends on access modifiers:

- `public` ‚Üí available + accessible
- `protected` ‚Üí available + accessible inside child
- `default` ‚Üí sometimes not accessible
- `private` ‚Üí available but **NOT accessible**

Example analogy:

- Your friend gives you a box.
- You can **hold** it ‚Üí _available_
- You cannot **open** it ‚Üí _not accessible_

This analogy matches private vs public members in classes.

---

## **8. Link to Generalization & Specialization**

### **Specialization (top-down)**

- Start with general class
- Create a more specific class
- Achieved using **inheritance**
  Examples:
- Circle ‚Üí Cylinder
- Alto ‚Üí Fortuner
- Guitar ‚Üí ElectricGuitar

### **Generalization (bottom-up)**

- Start with multiple classes
- Create a super class
- Achieved using **interfaces** or abstract classes
  Examples:
- iPhone, Samsung, MiPhone ‚Üí Smartphone
- Car, Bike, Ship ‚Üí Vehicle

---

## **9. Java Mechanisms**

Java provides **three tools**:

### ‚úî Inheritance

Used for specialization (top-down)

### ‚úî Interfaces

Used for generalization (bottom-up)

### ‚úî Abstract Classes

Used when you want features of both inheritance and interface

---

### ‚ùó **Constructor behavior in inheritance**

When you write:

```java
Cylinder c2 = new Cylinder();
```

Questions arise:

- Does Circle's constructor run automatically?
- If yes, in what order?
- How do we pass values to the parent constructor?

---

# **üìòTypes of Inheritance**

Below are the different types of inheritance which are supported by Java.

- Single Inheritance
- Multilevel Inheritance
- Hierarchical Inheritance
- Multiple Inheritance
- Hybrid Inheritance

### 1. Single Inheritance

In single inheritance, a sub-class is derived from only one super class. It inherits the properties and behavior of a single-parent class. Sometimes, it is also known as simple inheritance.

```java
//Super class
class Vehicle {
  Vehicle() {
    System.out.println("This is a Vehicle");
  }
}

// Subclass
class Car extends Vehicle {
  Car() {
    System.out.println("This Vehicle is Car");
  }
}

public class Test {
  public static void main(String[] args) {
      // Creating object of subclass invokes base class constructor
    Car obj = new Car();
  }
}
```

### 2. Multilevel Inheritance

In Multilevel Inheritance, a derived class will be inheriting a base class and as well as the derived class also acts as the base class for other classes.

```java
class Vehicle {
  Vehicle() {
    System.out.println("This is a Vehicle");
  }
}
class FourWheeler extends Vehicle {
  FourWheeler() {
    System.out.println("4 Wheeler Vehicles");
  }
}
class Car extends FourWheeler {
  Car() {
    System.out.println("This 4 Wheeler Vehicle is a Car");
  }
}
public class Geeks {
  public static void main(String[] args) {
    Car obj = new Car(); // Triggers all constructors in order
  }
}
```
### 3. Hierarchical Inheritance
In hierarchical inheritance, more than one subclass is inherited from a single base class. i.e. more than one derived class is created from a single base class. For example, cars and buses both are vehicle
```java 
class Vehicle {
  Vehicle() {
    System.out.println("This is a Vehicle");
  }
}

class Car extends Vehicle {
  Car() {
    System.out.println("This Vehicle is Car");
  }
}

class Bus extends Vehicle {
  Bus() {
    System.out.println("This Vehicle is Bus");
  }
}

public class Test {
  public static void main(String[] args) {
    Car obj1 = new Car(); 
    Bus obj2 = new Bus(); 
  }
}
```

### 4. Multiple Inheritance (Through Interfaces)
Java does not support multiple inheritances with classes. In Java, we can achieve multiple inheritances only through Interfaces. In Multiple inheritances, one class can have more than one superclass and inherit features from all parent classes.
```java 
interface Walkable {
  void walk(); // Interface methods are abstract and public by default
}

interface Swimmable {
  void swim();
}

// A class can implement multiple interfaces, separated by commas
// The class must provide concrete implementations for all interface methods
class Duck implements Walkable, Swimmable {
  @Override
  public void walk() {
    System.out.println("Duck is walking.");
  }

  @Override
  public void swim() {
    System.out.println("Duck is swimming.");
  }
}

// Main class to run the example
public class MultipleInheritanceDemo {
  public static void main(String[] args) {
    Duck myDuck = new Duck();
    myDuck.walk(); // Accessing behavior from the Walkable interface
    myDuck.swim(); // Accessing behavior from the Swimmable interface
  }
}
```

### 5. Hybrid Inheritance
It is a mix of two or more of the above types of inheritance. In Java, we can achieve hybrid inheritance only through Interfaces if we want to involve multiple inheritance to implement Hybrid inheritance.
- class Car extends Vehicle->Single Inheritance
- class Bus extends Vehicle and class Bus implements Interface Fare->Hybrid Inheritance (since Bus inherits from two sources, forming a combination of single + multiple inheritance).

# **üìò Constructors in Inheritance**

In this lesson, we learn:

‚úî How constructors behave in inheritance
‚úî How to call the **parameterized constructor** of a parent class using **super(...)**
‚úî Why `super(...)` must be the _first_ statement
‚úî Examples using simple classes, and later Rectangle ‚Üí Cuboid

---

## **1. Basic Example: Parent and Child Classes**

We start with two very simple classes: **Parent** and **Child**.

```java
class Parent {
    Parent() {
        System.out.println("Non-parameterized Parent");
    }

    Parent(int x) {
        System.out.println("Parameterized Parent: " + x);
    }
}

class Child extends Parent {
    Child() {
        System.out.println("Non-parameterized Child");
    }

    Child(int y) {
        System.out.println("Parameterized Child: " + y);
    }
}
```

---

## **2. What Happens When We Create a Child Object?**

### Case 1: `Child child = new Child()`

Output:

```
Non-parameterized Parent
Non-parameterized Child
```

Reason:

- When constructing a child object, **parent constructor always runs first**
- Since no `super(...)` is written, Java automatically calls `super()`

---

### Case 2: `Child child = new Child(20)`

Output:

```
Non-parameterized Parent
Parameterized Child: 20
```

Reason:

- Again, no `super(...)` is written ‚Üí Java calls `super()` by default
- Then Child(int y) runs

---

## **3. Calling the Parent‚Äôs Parameterized Constructor**

Now we modify Child to call **Parent(int)**.

We add a third constructor:

```java
class Child extends Parent {
    Child(int x, int y) {
        super(x);        // MUST be the first line
        System.out.println("Parameterized Child with 2 params: " + y);
    }
}
```

### Key Rules:

‚úî `super(...)` calls the constructor of the **parent class**
‚úî It MUST be the **first line** inside the child constructor
‚úî You can pass any values you want

### Example call:

```java
Child c = new Child(10, 20);
```

Output:

```
Parameterized Parent: 10
Parameterized Child with 2 params: 20
```

---

## **4. Important Rule: `super(...)` Must Be the First Line**

‚ùå Invalid:

```java
Child(int x, int y) {
    System.out.println("Hello");  // ERROR: cannot come before super(...)
    super(x);
}
```

‚úî Valid:

```java
Child(int x, int y) {
    super(x);    // first!
    System.out.println("Hello");
}
```

Why?
Because object construction begins from the parent class **before** the child can execute anything.

---

## **5. Rectangle ‚Üí Cuboid Example (Practical Scenario)**

## Parent class: Rectangle

```java
class Rectangle {
	int length;
	int breadth;

	Rectangle() {
		length = 1;
		breadth = 1;
	}

	Rectangle(int l, int b) {
		length = l;
		breadth = b;
	}
}
```

---

## Child class: Cuboid

```java
class Cuboid extends Rectangle {
	int height;

	Cuboid() {
		height = 1;
	}

	Cuboid(int h) {
		height = h;
	}

	Cuboid(int l, int b, int h) {
		super(l, b);  // calls Rectangle(l, b)
		height = h;   // sets child class property
	}

	int volume() {
		return length * breadth * height;
	}
}
```

---

## **6. Testing in main()**

### Case 1: No parameters

```java
Cuboid c = new Cuboid();
System.out.println(c.volume());
```

Values:

- length = 1
- breadth = 1
- height = 1

Output:

```
1
```

---

### Case 2: Only height given

```java
Cuboid c = new Cuboid(10);
System.out.println(c.volume());
```

Values:

- parent: calls Rectangle() ‚Üí length = 1, breadth = 1
- height = 10

Output:

```
10
```

---

### Case 3: Calling the full parameterized constructor

```java
Cuboid c = new Cuboid(5, 3, 10);
System.out.println(c.volume());
```

Constructor chain:

1. `super(5, 3)` ‚Üí sets length = 5, breadth = 3
2. height = 10

So volume = 5 √ó 3 √ó 10 = **150**

Output:

```
150
```

---

## **7. Summary (Very Important)**

### ‚úî Parent constructor always runs first

### ‚úî If you don‚Äôt write `super(...)`, Java inserts `super()` implicitly

### ‚úî To call parent **parameterized constructor**, write `super(parameters)` manually

### ‚úî `super(...)` must be the _first_ line in the constructor

### ‚úî Construction always happens **top ‚Üí down**

Parent ‚Üí Child

---

# **üìò Understanding `this` and `super` in Java**

1. `this` ‚Üí reference to the **current object**
2. `super` ‚Üí reference to the **parent (super) class**

---

## **1Ô∏è‚É£ The `this` Keyword**

The keyword `this` refers to the **current object** on which a method or constructor is invoked.

### Example: Rectangle Class

```java
class Rectangle {
    int length;
    int breadth;

    Rectangle(int length, int breadth) {
        this.length = length;   // refers to object's property
        this.breadth = breadth; // refers to object's property
    }

    void display() {
        System.out.println("Length: " + this.length + ", Breadth: " + this.breadth);
    }
}
```

### Key Points:

- `this.length` refers to the **property of the current object**.
- You **can omit `this`** if there is no name conflict:

```java
Rectangle(int l, int b) {
    length = l;
    breadth = b;
}
```

- When parameter names **conflict with property names**, you **must** use `this` to distinguish:

```java
Rectangle(int length, int breadth) {
    this.length = length;   // assigns parameter to object property
    this.breadth = breadth;
}
```

---

### Using `this` with Multiple Objects

```java
Rectangle r1 = new Rectangle(10, 5);
Rectangle r2 = new Rectangle(20, 10);

r1.display(); // refers to r1 object
r2.display(); // refers to r2 object
```

- Inside `display()`, `this.length` refers to the **object on which display() is called**.
- So `r1.display()` ‚Üí `this` refers to `r1`
- `r2.display()` ‚Üí `this` refers to `r2`

‚úÖ **Summary:** `this` always refers to the **current object**.

---

## **2Ô∏è‚É£ The `super` Keyword**

The keyword `super` refers to the **parent class** of the current class.

- It is mainly used to:

  1. Call **parent class constructors**
  2. Access **parent class properties** or methods (especially when names conflict)

### Example: Rectangle ‚Üí Cuboid

```java
class Rectangle {
	int length;
	int breadth;
	int x = 10;

	Rectangle(int l, int b) {
		length = l;
		breadth = b;
	}
}

class Cuboid extends Rectangle {
	int height;
	int x = 20; // name conflict with parent class

	Cuboid(int l, int b, int h) {
		super(l, b); // calls parent constructor to initialize length & breadth
		height = h;  // initializes child property
	}

	void display() {
		System.out.println("Parent X: " + super.x); // accesses parent class variable
		System.out.println("Child X: " + x);       // accesses child class variable
	}
}
```

### Key Points:

1. `super(l, b)` calls the **parameterized constructor of the parent class**.
2. `super.x` accesses the `x` variable from the parent class.
3. `x` alone accesses the child class variable.
4. Name conflicts between parent and child members can be resolved using `super`.

---

### Example Usage:

```java
Cuboid c1 = new Cuboid(5, 3, 10);
c1.display();
```

**Output:**

```
Parent X: 10
Child X: 20
```

Explanation:

- `super.x` ‚Üí 10 (from Rectangle)
- `x` ‚Üí 20 (from Cuboid)

---

## **3Ô∏è‚É£ Summary of `this` vs `super`**

| Keyword | Refers to           | Use Case                                                                                             |
| ------- | ------------------- | ---------------------------------------------------------------------------------------------------- |
| `this`  | Current object      | Resolve property/method ambiguity, call current object constructor, or pass current object reference |
| `super` | Parent class object | Access parent class properties/methods, call parent class constructor, resolve name conflicts        |

---

### ‚úÖ Key Takeaways:

- **`this`** ‚Üí current object
- **`super`** ‚Üí parent object
- Use `this` when parameter names conflict with object properties
- Use `super` to call parent constructor or access parent members

---

---

# **üìò Method Overriding in Java**

### **Definition:**

Method overriding happens when a **subclass provides its own implementation** of a method that is already defined in the **superclass**.

- Signature of the method in subclass **must be exactly the same** as in the superclass (same name, parameters, and return type).
- This is **not method overloading** (which has same method name but different parameters).

---

## **1Ô∏è‚É£ Example of Method Overriding**

```java
class SuperClass {
    void display() {
        System.out.println("Hello");
    }
}

class SubClass extends SuperClass {
    @Override
    void display() {
        System.out.println("Hello, Welcome");
    }
}
```

### Key Points:

- `SubClass` **overrides** the `display()` method of `SuperClass`.
- The method in the subclass **replaces** the inherited method for that subclass object.
- The superclass version is **shadowed** for objects of the subclass.

---

## **2Ô∏è‚É£ Calling Overridden Methods**

### Case 1: Object of Superclass

```java
SuperClass sc = new SuperClass();
sc.display();  // Output: Hello
```

- Calls **superclass method** because object is of superclass.

### Case 2: Object of Subclass

```java
SubClass sb = new SubClass();
sb.display();  // Output: Hello, Welcome
```

- Calls **subclass method** because object is of subclass.

---

## **3Ô∏è‚É£ Dynamic Method Dispatch**

This is the **most important part**. It explains what happens when a **superclass reference holds a subclass object**.

```java
SuperClass sc = new SubClass();
sc.display();  // Output: Hello, Welcome
```

### Key Points:

1. **Reference type:** SuperClass
2. **Actual object:** SubClass
3. **Method called:** SubClass version (`Hello, Welcome`)

‚úÖ **Rule:** In Java, **method calls are resolved at runtime based on the actual object**, not the reference type.

- This is called **dynamic method dispatch** or **runtime polymorphism**.
- Only **overridden methods** exhibit this behavior.

---

### **Important Notes:**

- Overridden method in subclass is **visible**, superclass version is shadowed.
- Reference type **does not matter** for which method is executed‚Äî**object type matters**.
- Overloading does **not** use dynamic dispatch. It is resolved at **compile time**.

---

## **4Ô∏è‚É£ Philosophy / Real-Life Analogy**

Think of it like this:

- Superclass = **generic remote control**
- Subclass = **specific smart TV**

Even if you hold a **generic remote reference**, if it is actually connected to a **smart TV**, the **TV-specific behavior** happens.

```text
SuperRemote remote = new SmartTV();
remote.turnOn();  // SmartTV turns on, not generic device
```

- The reference (`SuperRemote`) is generic, but the **actual device (object)** determines the behavior.

This is **why dynamic method dispatch exists**: it allows **flexibility and polymorphism**.

---

### **5Ô∏è‚É£ Recap: Overriding vs Overloading**

| Feature                  | Overriding              | Overloading             |
| ------------------------ | ----------------------- | ----------------------- |
| Same method signature?   | Yes                     | No (different params)   |
| Same class or subclass?  | Subclass                | Same or different class |
| Runtime or compile-time? | Runtime (dynamic)       | Compile-time (static)   |
| Reference type matters?  | No, object type matters | Compile-time checked    |

---

### ‚úÖ **Key Takeaways**

1. Method overriding ‚Üí subclass provides **its own version** of a superclass method.
2. Dynamic method dispatch ‚Üí **method call depends on object type at runtime**, not reference type.
3. Overridden superclass methods are **shadowed** by subclass methods.
4. Overloading ‚Üí compile-time, different signatures, not related to dynamic dispatch.
5. Real-life analogy ‚Üí reference = generic interface, object = actual behavior.

---

# **üìò Dynamic Method Dispatch in Java**

### **Definition:**

Dynamic method dispatch is a mechanism by which a **call to an overridden method is resolved at runtime**, rather than at compile time.

- This allows **runtime (dynamic) polymorphism**.
- It happens when a **superclass reference points to a subclass object**.

---

## **1Ô∏è‚É£ Example Setup**

```java
class SuperClass {
    void methodOne() {
        System.out.println("Super methodOne");
    }
    void methodTwo() {
        System.out.println("Super methodTwo");
    }
}

class SubClass extends SuperClass {
    @Override
    void methodTwo() {
        System.out.println("Sub methodTwo");
    }
    void methodThree() {
        System.out.println("Sub methodThree");
    }
}
```

- `methodTwo()` is **overridden** in the subclass.
- `methodThree()` exists **only in SubClass**.

---

## **2Ô∏è‚É£ Superclass Reference, Subclass Object**

```java
SuperClass ref = new SubClass();
```

- `ref` is a **SuperClass reference**.
- The actual object is of **SubClass**.
- ‚úÖ This is allowed in Java.
- ‚ùå The reverse is **not allowed**: `SubClass subRef = new SuperClass();` is invalid.

**Why allowed?**

- Because the subclass **is a type of superclass** (IS-A relationship).
- But the subclass may have extra methods that the superclass doesn‚Äôt know about.

---

## **3Ô∏è‚É£ Which methods can be called?**

With a **superclass reference**, you can **only call methods defined in the superclass**:

```java
ref.methodOne();  // Allowed
ref.methodTwo();  // Allowed
ref.methodThree(); // ‚ùå Not allowed, not visible in SuperClass
```

- Even though `methodThree` exists in the actual object (`SubClass`), the compiler **cannot see it through the superclass reference**.
- **This is the key restriction.**

---

## **4Ô∏è‚É£ Which method is executed?**

This is the heart of **dynamic method dispatch**:

```java
ref.methodTwo();
```

- `methodTwo()` is **overridden** in SubClass.
- The **method executed is determined by the actual object**, not the reference type.
- Since the actual object is `SubClass`, **SubClass‚Äôs methodTwo()** is executed:

```
Output: Sub methodTwo
```

‚úÖ **Rule:**

> Method call resolution happens **at runtime** based on the actual object.

---

## **5Ô∏è‚É£ Why dynamic method dispatch? (Philosophy)**

1. **Achieves runtime polymorphism**:

   - You can write code like `SuperClass ref = new SubClass();`
   - At runtime, the program automatically executes the **correct subclass method**.

2. **Flexible and reusable code**:

   - You can write methods that take a **superclass reference** and they will work for any subclass objects.

3. **Reference vs Object:**

   - Reference = **what the compiler knows** (visibility).
   - Object = **what exists at runtime** (actual execution).
   - Dynamic dispatch ensures execution depends on **object**, not reference.

---

## **6Ô∏è‚É£ Summary Table**

| Concept                | Description                                         |
| ---------------------- | --------------------------------------------------- |
| Reference type         | What methods the compiler allows you to call        |
| Object type            | Determines which overridden method actually runs    |
| Allowed?               | Superclass reference can hold subclass object ‚úÖ    |
| Not allowed            | Subclass reference cannot hold superclass object ‚ùå |
| Extra subclass methods | Cannot call through superclass reference            |
| Runtime resolution     | Yes, overridden method executed depends on object   |

---

## **7Ô∏è‚É£ Example Execution**

```java
SuperClass obj = new SubClass();

obj.methodOne(); // Super methodOne
obj.methodTwo(); // Sub methodTwo
// obj.methodThree(); // ‚ùå Compile-time error
```

- `methodOne()` ‚Üí superclass only ‚Üí executed as defined in superclass.
- `methodTwo()` ‚Üí overridden ‚Üí executed as defined in subclass.
- `methodThree()` ‚Üí compiler error ‚Üí reference doesn‚Äôt know about it.

---

‚úÖ **Takeaway:**

Dynamic method dispatch is **the mechanism behind runtime polymorphism in Java**.

- Reference = Superclass (controls visibility)
- Object = Subclass (controls execution)

This is why **overriding is powerful** and enables **flexible OOP design**.

---

# **üìò Method Overriding Rules in Java**

Method overriding occurs when a **subclass provides its own implementation** of a method already defined in the superclass.

---

## **1Ô∏è‚É£ Signature Must Match**

- Method **name** must be exactly the same (Java is case-sensitive).
- Parameters **must match exactly** (number, type, order).
- ‚úÖ Example:

```java
class SuperClass {
    public void display() { }
}

class SubClass extends SuperClass {
    @Override
    public void display() { }  // Correct
}
```

- ‚ùå Changing parameter types or adding parameters ‚Üí becomes **method overloading**, not overriding.

---

## **2Ô∏è‚É£ Return Type**

- Return type must **match exactly**, except in one special case:

  - **Covariant return type:** Subclass method can return an object of a **subclass type** of the original return type.

```java
class A { }
class B extends A { }

class SuperClass {
    public A getObject() { return new A(); }
}

class SubClass extends SuperClass {
    @Override
    public B getObject() { return new B(); } // ‚úÖ Allowed (covariant)
}
```

---

## **3Ô∏è‚É£ Access Modifiers**

- Access level **cannot be more restrictive** than the superclass method. If the superclass method is `public`, then subclass method cannot be more restrictive like `private or protected`
- Allowed changes: **same or more lenient**. If the superclass method is `protected`, then subclass method can be same or more lenient like `protected or public`

| Superclass method | Subclass override allowed?            |
| ----------------- | ------------------------------------- |
| `private`         | Cannot override (private not visible) |
| `protected`       | `protected` or `public` ‚úÖ            |
| `public`          | `public` only ‚úÖ                      |

> You **cannot reduce visibility** in the subclass.

---

## **4Ô∏è‚É£ Cannot Override**

- `final` methods ‚Üí cannot be overridden
- `static` methods ‚Üí cannot be overridden (they are hidden, not overridden)
- `private` methods ‚Üí cannot be overridden (not visible outside the class)

---

## **5Ô∏è‚É£ Use of `@Override` Annotation**

- Always use `@Override` for clarity.
- It helps **the compiler check** whether you are actually overriding a method.

---

## **6Ô∏è‚É£ Key Notes**

- **Method name, parameters, and return type** (except covariant) must match exactly.
- Overloading ‚â† overriding. Overloading = same method name, **different parameters**.
- Overriding allows **runtime polymorphism**.
- Access modifiers must be **same or more lenient**.

---

### **‚úÖ Quick Examples**

```java
class SuperClass {
    public void display() { System.out.println("Super display"); }
    public final void finalMethod() { }
    public static void staticMethod() { }
}

class SubClass extends SuperClass {
    @Override
    public void display() { System.out.println("Sub display"); }

    // Cannot override finalMethod ‚Üí ‚ùå error
    // Cannot override staticMethod ‚Üí ‚ùå error
}
```

---

# **üìò Polymorphism using Overloading and Overriding**

**Polymorphism** means:

> ‚ÄúOne name, many forms‚Äù
> The **same method name** can perform **different actions** depending on the context.

Java achieves polymorphism using:

1. **Method Overloading** ‚Üí Compile-time polymorphism
2. **Method Overriding** ‚Üí Runtime polymorphism

---

## **1Ô∏è‚É£ Method Overloading (Compile-time Polymorphism)**

- **Definition:** Same method name, **different parameter list** (number or type of parameters) within the same class (or subclass).
- **Decision:** Which method to call is **decided at compile time**.

**Example:**

```java
class Test {
    int max(int a, int b) {
        return (a > b) ? a : b;
    }

    int max(int a, int b, int c) {
        return Math.max(a, Math.max(b, c));
    }
}

public class Main {
    public static void main(String[] args) {
        Test obj = new Test();
        System.out.println(obj.max(10, 20));       // Calls max(int, int)
        System.out.println(obj.max(10, 20, 5));   // Calls max(int, int, int)
    }
}
```

‚úÖ **Key Points:**

- Methods must have **same name**.
- Parameters must **differ** (number or type).
- Return type **can be same or different**.
- Achieves **compile-time polymorphism**.

---

## **2Ô∏è‚É£ Method Overriding (Runtime Polymorphism)**

- **Definition:** Subclass **redefines a method** of the superclass with the **same signature**.
- **Decision:** Which method to call is **decided at runtime** based on the **object type**, not the reference type.

**Example:**

```java
class Super {
    public void display() {
        System.out.println("Super display");
    }
}

class Sub extends Super {
    @Override
    public void display() {
        System.out.println("Sub display");
    }
}

public class Main {
    public static void main(String[] args) {
        Super s1 = new Super();
        s1.display(); // Super display

        Super s2 = new Sub();
        s2.display(); // Sub display ‚Üí dynamic method dispatch
    }
}
```

‚úÖ **Key Points:**

- Method name, parameters, and return type must **match exactly** (except covariant return types).
- **Access modifiers:** Can stay same or become **less restrictive**.
- Cannot override `final`, `static`, or `private` methods.
- Achieves **runtime polymorphism** (dynamic method dispatch).

---

## **3Ô∏è‚É£ Differences Between Overloading and Overriding**

| Feature                | Overloading                      | Overriding                            |
| ---------------------- | -------------------------------- | ------------------------------------- |
| **Polymorphism type**  | Compile-time                     | Runtime                               |
| **Method signature**   | Must differ (parameters)         | Must be same                          |
| **Return type**        | Can differ                       | Must match (or covariant)             |
| **Access modifier**    | Any                              | Same or less restrictive              |
| **Inheritance needed** | Not necessary                    | Must have superclass/subclass         |
| **Use case**           | Different actions with same name | Redefine behavior of inherited method |

---

### **4Ô∏è‚É£ Dynamic Method Dispatch**

- When a **superclass reference** holds a **subclass object**, the **method that belongs to the actual object** is called.
- **Decision made at runtime** ‚Üí allows **dynamic polymorphism**.

---

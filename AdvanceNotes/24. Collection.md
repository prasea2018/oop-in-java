# **üìòWhat are Collections**
## **1Ô∏è‚É£ What is Collection Framework?**

* **Collection Framework = Data Structure in Java**

  - Java provides built-in data structures called **collections**.
  - Collections are used to **store and organize data** inside a program.
  - Without a collection framework (or some data structure), developing real-world applications is nearly impossible.

- **Data is Central**

  - Programs process **data** to compute results.
  - Most applications don‚Äôt deal with single values‚Äîthey deal with **lists of values** (e.g., students, books, accounts).

---

## **2Ô∏è‚É£ Sources of Data for a Java Program**

Java programs can get data from:

1. **Keyboard input**
2. **Files** (data already stored on disk)
3. **Databases**

   * Relational (SQL)
   * Object-oriented
4. **Remote computers / networks**

   * Through the internet or local network

üí° **Important:** The data is often a **list** (collection), not just a single value.

---

## **3Ô∏è‚É£ Examples of Data Lists**

* **List of primitive values:** integers, floats, etc.
* **List of objects:** students, books, customers, accounts, movies.
* **Purpose:** Computation, search, update, reporting, billing, etc.

Example:

```java
Student[] students = new Student[100];  // Array of 100 students
```

---

## **4Ô∏è‚É£ Storing Data in Memory**

* Once data comes from the source, it must be held in memory (typically in the **heap** for objects in Java).
* The **organization of data** in memory is called a **data structure**.
* **Collections** are Java‚Äôs way of arranging data efficiently.

---

## **5Ô∏è‚É£ Arrays: Basic Data Structure**

* Arrays are the simplest way to store a collection of values.
* Example:

```java
int[] numbers = new int[10];  // Array of integers
Student[] students = new Student[100]; // Array of Student objects
```

* **Limitations of Arrays:**

  1. Fixed size (cannot grow or shrink dynamically)
  2. Limited operations (insertion, deletion, searching are manual)
  3. Cannot handle complex operations efficiently for objects

---

## **6Ô∏è‚É£ Why Collections?**

* Arrays are not always sufficient for real-world applications.
* Java Collections provide:

  * Dynamic size (grow or shrink automatically)
  * Built-in methods for common operations:

    * Add, remove, search, sort, filter, iterate
  * Specialized collections depending on requirements:

    * **List**, **Set**, **Queue**, **Map**
* Collections solve the **drawbacks of arrays** and make programming easier for real-world applications.

---

## **Summary**

1. Programs need data from various sources.
2. Data is often in the form of **lists** (collections).
3. Arrays can store lists, but they have limitations.
4. Java provides **Collections Framework** to efficiently store, manage, and operate on data.

---
# **üìòWhy Collections are Required**
---

## **1Ô∏è‚É£ Limitations of Arrays**

* **Fixed Size:**

  * Once an array is created, its size **cannot change**.
  * To increase size:

    1. Create a new array of larger size.
    2. Copy existing elements into the new array.
    3. Make the original reference point to the new array.
    4. Optionally, discard the old array.

  Example:

  ```java
  int[] A = new int[5];  // original array
  int[] B = new int[10]; // new bigger array
  System.arraycopy(A, 0, B, 0, A.length);
  A = B;  // A now points to bigger array
  B = null;
  ```

* **Drawbacks:**

  * Programmer must handle resizing manually.
  * Cannot predict the number of elements coming at runtime.
  * Insertion/deletion in the middle of array requires shifting elements manually.

---

## **2Ô∏è‚É£ Why Arrays Are Not Always Suitable**

* Real-world applications often need **dynamic-sized collections**.
* Arrays are not flexible for:

  * Unknown size at runtime
  * Frequent insertion/deletion in the middle
  * Ensuring uniqueness of elements
  * Maintaining sorted order automatically

---

## **3Ô∏è‚É£ Collection Framework to the Rescue**

Java provides **built-in classes** under the **Collections Framework** to overcome array limitations:

### **Variable-size Collections**

* **ArrayList**

  * Dynamic resizing (auto-expands when more elements are added)
* **LinkedList**

  * Also allows dynamic insertion/deletion anywhere in the list

### **Distinct/Unique Elements**

* **Set**

  * Automatically prevents duplicate elements

### **Sorted & Unique**

* **SortedSet**

  * Ensures elements are unique **and** sorted automatically

---

## **4Ô∏è‚É£ Common Operations on Collections**

1. **Insertion**

   * Collections handle insertion automatically.
   * No need to manually shift elements like arrays.

2. **Deletion**

   * Collections handle deletion automatically.
   * No need to manually shift elements.

3. **Searching**

   * Collections provide built-in methods.
   * Methods can implement:

     * Linear Search
     * Binary Search
     * Hash-based search (key-value pair via Map classes)
   * Hashing provides **fast search** for large collections.

---

## **5Ô∏è‚É£ Key Takeaways**

* Arrays are simple but **limited in flexibility**.
* Collections Framework provides:

  * **Dynamic sizing** (ArrayList, LinkedList)
  * **Uniqueness** (Set)
  * **Sorting** (SortedSet)
  * **Efficient operations**: insert, delete, search, hash-based lookup
* Collections let the programmer **focus on using data**, not managing it.

---

# **üìòCollection Classes in Java**

---

## **1Ô∏è‚É£ Introduction to Collection Framework**

* **Collection Framework = Data Structures in Java**

  * Provided as **interfaces and classes**.
  * Organized in a **hierarchy**.
  * Classes implement interfaces to provide concrete functionality.

* **Shapes in hierarchy diagram:**

  * **Oval = Interface**
  * **Rectangle = Class**

* **Top-most interface:** `Iterable`

  * Has a single method: `iterator()`

* **Mother of all interfaces:** `Collection`

  * Represents a **group of objects** (homogeneous or heterogeneous).
  * Methods include:

    * Add object
    * Remove object
    * Search object
    * Check for object

---

## **2Ô∏è‚É£ List Interface (Ordered Collection)**

* **Definition:** Ordered collection of elements with **indexing**.

* **Features:**

  * Maintains order
  * Can have **duplicates**
  * Access elements by **index**

* **Classes implementing List:**

  * **ArrayList:** Dynamic array, widely used
  * **LinkedList:** Doubly-linked list structure
  * **Vector (Legacy):** Old dynamic array class
  * **Stack (Legacy):** Last-In-First-Out structure

* **Use Case:**

  * Insert/delete at specific positions easily
  * Maintain order of elements

---

## **3Ô∏è‚É£ Set Interface (Unordered, Unique Collection)**

* **Definition:** Unordered collection of **distinct elements** (no duplicates)

* **Features:**

  * Duplicates not allowed
  * No indexing (unordered)
  * Useful for **frequent search operations**

* **Classes implementing Set:**

  * **HashSet:** Uses hashing, unordered
  * **LinkedHashSet:** Maintains insertion order
  * **SortedSet (interface):** Elements are **sorted**

    * **TreeSet:** Implementation using tree data structure

---

## **4Ô∏è‚É£ Queue Interface (FIFO Collection)**

* **Definition:** Elements follow **First-In-First-Out (FIFO)** principle
* **Insertion:** At one end
* **Deletion:** From the other end
* **Class implementing Queue:**

  * **PriorityQueue:** Elements have priority order for processing

---

## **5Ô∏è‚É£ Deque Interface (Double-Ended Queue)**

* **Definition:** Insertion and deletion allowed at **both ends**
* **Class implementing Deque:**

  * **ArrayDeque:** Efficient double-ended queue

---

## **6Ô∏è‚É£ Map Interface (Key-Value Pair Storage)**

* **Definition:** Stores elements as **key-value pairs**
* **Use Case:** Search value by key efficiently
* **Classes implementing Map:**

  * **HashMap:** Unordered, uses hashing
  * **LinkedHashMap:** Maintains insertion order
  * **Hashtable (Legacy):** Old synchronized class
  * **SortedMap (interface):** Maintains sorted keys

    * **TreeMap:** Implementation using tree data structure

---

## **7Ô∏è‚É£ Key Points to Remember**

* **Interfaces define behavior**, classes provide implementation.

* **Collection interface** is the root of most interfaces (`List`, `Set`, `Queue`, `Deque`).

* **List:** Ordered, allows duplicates

* **Set:** Unordered, no duplicates

* **Queue:** FIFO

* **Deque:** Double-ended insertion/deletion

* **Map:** Key-value storage, separate hierarchy from Collection

* **Legacy Classes:** Vector, Stack, Hashtable ‚Äî old versions, rarely used now.

* Understanding the **interface** helps understand the **classes** implementing it.

---

# **üìòUnderstanding Collection Interface**

---

## **1Ô∏è‚É£ Collection Interface Overview**

* **Package:** `java.util`
* **Generic:** Supports objects of any class (`<E>` notation)
* **Represents:** A group of objects, parent interface for `List`, `Set`, `Queue`

---

## **2Ô∏è‚É£ Key Methods of Collection Interface**

| **Method**                          | **Description**                                          | **Example/Behavior**                                           |
| ----------------------------------- | -------------------------------------------------------- | -------------------------------------------------------------- |
| `add(E e)`                          | Adds a single element to the collection                  | Add `G` to `[A, B, C, D, E]` ‚Üí `[A, B, C, D, E, G]`            |
| `addAll(Collection<? extends E> c)` | Adds all elements from another collection                | `C1.addAll(C2)` adds all elements of `C2` into `C1`            |
| `remove(Object o)`                  | Removes a single element                                 | Removes `D` from collection if present, returns `true`/`false` |
| `removeAll(Collection<?> c)`        | Removes all elements present in another collection       | `C1.removeAll(C2)` removes common elements of `C2` from `C1`   |
| `retainAll(Collection<?> c)`        | Keeps only elements present in another collection        | `C1.retainAll(C2)` keeps common elements, removes others       |
| `clear()`                           | Removes all elements                                     | Collection becomes empty                                       |
| `isEmpty()`                         | Checks if collection is empty                            | Returns `true` if no elements                                  |
| `contains(Object o)`                | Checks if a specific element is present                  | Returns `true` if found                                        |
| `containsAll(Collection<?> c)`      | Checks if all elements of another collection are present | Returns `true` if all `C2` elements exist in `C1`              |
| `equals(Object o)`                  | Compares two collections for equality                    | True if both have same elements and size                       |
| `size()`                            | Returns number of elements                               | `C1.size()` returns count                                      |
| `iterator()`                        | Returns an `Iterator` to traverse elements               | Allows sequential access (`next()`, `hasNext()`)               |
| `toArray()`                         | Converts collection to array                             | Returns an array of collection elements                        |

---

## **3Ô∏è‚É£ Notes on Iterator**

* **Purpose:** Scans/traverses the collection, similar to **for-loop iteration on arrays**

* **Methods:**

  * `hasNext()` ‚Äì checks if more elements exist
  * `next()` ‚Äì retrieves the next element
  * `remove()` ‚Äì optionally remove the current element

* **Analogy:** `for (int i = 0; i < array.length; i++)` ‚Üí `Iterator` does the same for collections without indexes

---

## **4Ô∏è‚É£ Key Points**

* Collection interface **does not have objects**, only methods
* All collection classes (`ArrayList`, `HashSet`, etc.) **implement these methods**
* Understanding these methods gives you **most of the operations for all collection classes**
* `addAll`, `removeAll`, `retainAll` are **collection-to-collection operations**
* Iterators are essential for **traversing collections efficiently**

---

# **üìòUnderstanding List, Set Interface**

---

## **1Ô∏è‚É£ List Interface**

**Key Points:**

* **Extends:** `Collection`
* **Ordered:** Elements have indices
* **Duplicates:** Allowed
* **Extra Methods:** Related to index-based operations

**Important Methods:**

| **Method**                                     | **Description**                                                      | **Example**                       |
| ---------------------------------------------- | -------------------------------------------------------------------- | --------------------------------- |
| `add(E e)`                                     | Adds an element at the end                                           | `[A,B,C] ‚Üí add(D) ‚Üí [A,B,C,D]`    |
| `add(int index, E element)`                    | Inserts element at a specific index                                  | Insert `K` at index 2             |
| `addAll(Collection<? extends E> c)`            | Adds all elements from another collection at the end                 | `[A,B] addAll([C,D]) ‚Üí [A,B,C,D]` |
| `addAll(int index, Collection<? extends E> c)` | Adds all elements from another collection starting at specific index | Insert `[P,Q,R]` at index 2       |
| `remove(int index)`                            | Removes element at specific index                                    | Remove element at index 4         |
| `get(int index)`                               | Returns element at given index                                       | `get(2) ‚Üí C`                      |
| `set(int index, E element)`                    | Replaces element at given index                                      | Replace index 3 with `K`          |
| `subList(int fromIndex, int toIndex)`          | Returns part of the list (view)                                      | `subList(1,4)` ‚Üí `[B,C,D]`        |
| `indexOf(Object o)`                            | Returns first occurrence index of an object                          | `indexOf(C) ‚Üí 2`                  |
| `lastIndexOf(Object o)`                        | Returns last occurrence index of an object                           | Useful if duplicates exist        |
| `iterator()`                                   | Traverses elements forward                                           | Standard iteration                |
| `listIterator()`                               | Traverses elements forward & backward                                | Can start from a specific index   |

**Notes:**

* `add` vs `set`: `add` inserts (shifts elements), `set` replaces
* `listIterator` is bidirectional, unlike `iterator`

---

## **2Ô∏è‚É£ Set Interface**

**Key Points:**

* **Extends:** `Collection`
* **Unordered:** No indexing
* **Duplicates:** Not allowed (unique elements)
* **Extra Methods:** None
* **Methods:** Same as `Collection` interface

**Use Case:** Useful when uniqueness is required

---

## **3Ô∏è‚É£ Queue Interface**

**Key Points:**

* **Extends:** `Collection`
* **Mechanism:** FIFO (First In First Out)
* **Extra Methods:** Specific to queue operations

**Important Methods:**

| **Method**  | **Description**                          | **Behavior on Empty Queue**              |
| ----------- | ---------------------------------------- | ---------------------------------------- |
| `add(E e)`  | Adds element at the end                  | Throws exception if full (rarely used)   |
| `poll()`    | Removes and returns first element        | Returns `null` if empty                  |
| `remove()`  | Removes and returns first element        | Throws `NoSuchElementException` if empty |
| `peek()`    | Retrieves first element without removing | Returns `null` if empty                  |
| `element()` | Retrieves first element without removing | Throws `NoSuchElementException` if empty |

**Notes:**

* `poll` vs `remove`: Same action, different empty queue behavior
* `peek` vs `element`: Same action, different empty queue behavior

---

## **Summary Table for Interfaces**

| Interface  | Ordered | Duplicates  | Index-based Methods | Special Methods                                                                                           |
| ---------- | ------- | ----------- | ------------------- | --------------------------------------------------------------------------------------------------------- |
| Collection | No      | Allowed     | None                | add, addAll, remove, removeAll, retainAll, iterator, contains, containsAll, clear, isEmpty, size, toArray |
| List       | Yes     | Allowed     | Yes                 | get, set, add(index, E), addAll(index, Collection), subList, indexOf, lastIndexOf, listIterator           |
| Set        | No      | Not Allowed | None                | Same as Collection                                                                                        |
| Queue      | No      | Allowed     | No                  | poll, remove, peek, element                                                                               |

---

# **üìòVisiting Java Docs for Collections**

---

## **1Ô∏è‚É£ Using Java Documentation**

* Java provides **official documentation** for all packages, classes, interfaces, and methods.
* You can search for `Java <version> <package>` (e.g., `Java 13 util`) to get Oracle‚Äôs documentation.
* Documentation contains:

  * **Interfaces**: List of all interfaces in the package.
  * **Classes**: All classes in the package.
  * **Enums**: Enumerations.
  * **Exceptions**: Exceptions raised by classes.
* Each class or interface page contains:

  * **Description**
  * **Super interfaces**
  * **Subinterfaces**
  * **Known implementing classes**
  * **Methods and constructors**

---

## **2Ô∏è‚É£ Collection Interface**

* **Superinterface:** `Iterable`
* **Subinterfaces:** `List`, `Set`, `Queue`, etc.
* **Known Implementations:** `ArrayList`, `HashSet`, `LinkedList`, etc.
* **Methods:** `add()`, `addAll()`, `remove()`, `removeAll()`, `retainAll()`, `contains()`, `containsAll()`, `clear()`, `isEmpty()`, `size()`, `iterator()`, `toArray()`, etc.

---

## **3Ô∏è‚É£ List Interface**

* **Extends:** `Collection` ‚Üí inherits all Collection methods.
* **Implemented By:** `ArrayList`, `LinkedList`, `Vector`, `Stack`, etc.
* **Extra Methods:** Index-based methods like `get(int index)`, `set(int index, E element)`, `add(int index, E element)`, `addAll(int index, Collection c)`, `subList(int from, int to)`, `indexOf()`, `lastIndexOf()`, `listIterator()`.
* **Special Notes:** `ArrayList` implements `RandomAccess` for fast index-based access.

---

## **4Ô∏è‚É£ Set Interface**

* **Extends:** `Collection`
* **Implemented By:** `HashSet`, `LinkedHashSet`, `TreeSet`
* **Methods:** Same as Collection, no extra methods.
* **Properties:** Unordered, unique elements.

---

## **5Ô∏è‚É£ Queue Interface**

* **Extends:** `Collection`
* **Implemented By:** `LinkedList`, `PriorityQueue`
* **Extra Methods:** `offer()`, `peek()`, `poll()`, `remove()`, `element()`.
* **Purpose:** FIFO (First In First Out)
* **Notes:** `LinkedList` implements `Deque` as well, providing methods like `addFirst()`, `addLast()`, `peekFirst()`, `peekLast()`, `pollFirst()`, `pollLast()`, `pop()`, `push()`.

---

## **6Ô∏è‚É£ Example Classes**

| Class        | Implements                                                                      | Notes                                               |
| ------------ | ------------------------------------------------------------------------------- | --------------------------------------------------- |
| `ArrayList`  | `List`, `Collection`, `Iterable`, `RandomAccess`, `Serializable`, `Cloneable`   | Index-based access, dynamic array                   |
| `LinkedList` | `List`, `Deque`, `Queue`, `Collection`, `Iterable`, `Serializable`, `Cloneable` | Doubly-linked list, supports queue/deque operations |
| `HashSet`    | `Set`, `Collection`, `Iterable`, `Serializable`, `Cloneable`                    | Stores unique elements, unordered                   |

**Constructors:**

* Non-parameterized
* Initial capacity (and sometimes load factor for hash-based collections)
* Constructor accepting a collection

**Methods:** All methods from interfaces, plus class-specific operations.

---

## **7Ô∏è‚É£ Tips for Learning Collections**

1. Use **Oracle documentation** as the primary source of truth.
2. Focus on **interfaces first** (Collection, List, Set, Queue).
3. Learn **key implementing classes** (`ArrayList`, `LinkedList`, `HashSet`, etc.).
4. Explore methods for each class from docs (`add()`, `remove()`, `get()`, etc.).
5. Practice using **the right class in the right scenario**.

---

# **üìòArrayList and Iterator**

---

## **1Ô∏è‚É£ Creating an ArrayList**

```java
import java.util.ArrayList;
import java.util.List;

public class Demo {
  public static void main(String[] args) {
    List<Integer> al1 = new ArrayList<>(20); // Initial capacity 20
  }
}
```

* **Generic Class**: `ArrayList<Integer>` ensures only integers are stored.
* **Initial Capacity**: 20 ‚Üí array list can hold at least 20 elements initially, grows automatically as needed.

---

## **2Ô∏è‚É£ Adding Elements**

### **a) add(E element)**

```java
al1.add(10); // Adds 10 at the end
```

### **b) add(int index, E element)**

```java
al1.add(0, 5); // Inserts 5 at index 0, shifts 10 to index 1
```

### **c) addAll(Collection c)**

```java
List<Integer> al2 = List.of(50, 60, 70, 80, 90); // Static initialization
al1.addAll(al2); // Adds all elements at the end
```

### **d) addAll(int index, Collection c)**

```java
al1.addAll(1, al2); // Inserts all elements starting at index 1
```

---

## **3Ô∏è‚É£ Accessing Elements**

### **a) get(int index)**

```java
Integer val = al1.get(5); // Access element at index 5
```

### **b) indexOf(E element)**

```java
int idx = al1.indexOf(70); // Returns first occurrence index
```

### **c) lastIndexOf(E element)**

```java
int lastIdx = al1.lastIndexOf(70); // Returns last occurrence index
```

### **d) set(int index, E element)**

```java
al1.set(6, 100); // Replaces element at index 6 with 100
```

---

## **4Ô∏è‚É£ Removing Elements**

```java
al1.remove(3); // Remove element at index 3
al1.clear();   // Removes all elements
```

* **retainAll(Collection c)** ‚Üí Keep only elements present in another collection.
* **removeAll(Collection c)** ‚Üí Remove all elements present in another collection.

---

## **5Ô∏è‚É£ Checking Elements**

```java
al1.contains(50); // true if 50 is present
al1.equals(al2);  // checks if two lists are equal
```

---

## **6Ô∏è‚É£ Iterating through ArrayList**

### **a) Using for loop**

```java
for(int i = 0; i < al1.size(); i++) {
    System.out.println(al1.get(i));
}
```

### **b) Using for-each loop**

```java
for(Integer x : al1) {
  System.out.println(x);
}
```

### **c) Using Iterator**

```java
Iterator<Integer> it = al1.iterator();
while(it.hasNext()) {
  System.out.println(it.next());
}
```

### **d) Using ListIterator**

```java
ListIterator<Integer> li = al1.listIterator();
while(li.hasNext()) {
  System.out.println(li.next());
}
// ListIterator allows bidirectional iteration
```

### **e) Using forEach with Lambda**

```java
al1.forEach(n -> System.out.println(n));
```

### **f) Using Method Reference**

```java
al1.forEach(System.out::println);
```

### **g) Conditional Lambda**

```java
al1.forEach(n -> show(n));

static void show(int n) {
    if(n > 60) System.out.println(n);
}
```

* Only elements **greater than 60** are printed.
* Demonstrates combining **forEach** with a **custom method**.

---

## **7Ô∏è‚É£ Key Points**

* ArrayList allows **duplicate elements**.
* **Generic type** ensures type safety.
* Provides **dynamic resizing**.
* Can access elements by **index**.
* Iteration can be done using:

  * Traditional `for` loop
  * Enhanced `for-each` loop
  * `Iterator` or `ListIterator`
  * Lambda expressions or method references

---



Perfect! I‚Äôve analyzed your transcript. I‚Äôll now transform it into a structured, educational learning material for easier understanding and practical use.

---

# **üìòLinkedList**

## **Learning Objectives**

By the end of this module, you will be able to:

1. Understand the structure and concept of a **doubly-linked list**.
2. Compare **LinkedList** with **ArrayList**, identifying advantages and disadvantages.
3. Implement Java‚Äôs **LinkedList class** and use its key methods effectively.
4. Manipulate linked list elements: insert, delete, and access nodes efficiently.
5. Understand additional methods in LinkedList like `addFirst`, `addLast`, `peek`, `poll`, and iterators.

---

## **1. Introduction to LinkedList**

A **LinkedList** in Java is a collection of nodes arranged in a **doubly-linked list** structure:

* **Node Components**:

  * **Data/Value**: The actual element (can be Integer, String, or any object type).
  * **Next Pointer**: Points to the next node in the list.
  * **Previous Pointer**: Points to the previous node in the list.

* **Head Node**: First node in the list; stores the starting reference.

* **Tail Node**: Last node; its `next` pointer is `null`.

**Example Structure:**

```
HEAD -> [45 | next -> 3 | prev -> null] <-> [3 | next -> null | prev -> 45]
```

---

## **2. Why Use LinkedList?**

### **Advantages**

1. **Efficient Insertion/Deletion**:

   * Inserting or deleting a node doesn‚Äôt require shifting other elements (unlike arrays).
   * Example: Inserting `10` between `45` and `3` only updates pointers, no data movement.

2. **Dynamic Size**:

   * LinkedList can grow or shrink as needed.
   * No need to predefine a size (unlike arrays where resizing requires copying all elements).

### **Disadvantages**

1. **Extra Memory**:

   * Each node requires extra memory for `next` and `prev` pointers.
2. **Random Access Slower**:

   * Accessing an element by index is slower than arrays because it requires traversal.

---

## **3. LinkedList vs ArrayList**

| Feature              | ArrayList                | LinkedList                      |
| -------------------- | ------------------------ | ------------------------------- |
| Structure            | Dynamic array            | Doubly-linked list              |
| Insertion/Deletion   | Slow (requires shifting) | Fast (adjust pointers only)     |
| Memory Usage         | Less                     | More (extra space for pointers) |
| Size Flexibility     | Fixed / Resizable        | Fully dynamic                   |
| Access Time by Index | Fast (O(1))              | Slow (O(n))                     |

**Key Takeaway:**

* Use **LinkedList** when frequent insertions/deletions are needed.
* Use **ArrayList** for fast random access and memory efficiency.

---

## **4. Java LinkedList Class**

### **Initialization**

```java
import java.util.LinkedList;

LinkedList<Integer> list1 = new LinkedList<>();
LinkedList<Integer> list2 = new LinkedList<>(Arrays.asList(50, 60, 70, 80, 90));
```

**Notes:**

* No initial size is required.
* Elements are added dynamically.

---

### **Common Methods**

**Inherited from List Interface (similar to ArrayList):**

* `add(element)` ‚Äì Add at end.
* `add(index, element)` ‚Äì Add at specific position.
* `addAll(collection)` ‚Äì Add all elements of another collection.
* `get(index)` ‚Äì Retrieve element by index.
* `set(index, element)` ‚Äì Update element at index.
* `contains(element)` ‚Äì Check if element exists.
* `indexOf(element)` / `lastIndexOf(element)` ‚Äì Find element positions.
* Iteration: `for-each`, `ListIterator`, lambda expressions.

**Specific to LinkedList / Deque Interface:**

* `addFirst(element)` ‚Äì Add at beginning.
* `addLast(element)` ‚Äì Add at end.
* `removeFirst()` / `removeLast()` ‚Äì Remove from start or end.
* `getFirst()` / `getLast()` ‚Äì Retrieve first or last element without removing.
* `peekFirst()` / `peekLast()` ‚Äì View first or last element without removal.
* `pollFirst()` / `pollLast()` ‚Äì Retrieve and remove first/last element.
* `descendingIterator()` ‚Äì Iterate from last to first.

**Example:**

```java
LinkedList<Integer> list = new LinkedList<>();
list.addFirst(3);
list.addLast(200);

System.out.println(list.getFirst()); // Output: 3
System.out.println(list.getLast());  // Output: 200

list.removeFirst();
list.removeLast();
```

---

## **5. Practical Example**

```java
LinkedList<Integer> numbers = new LinkedList<>(Arrays.asList(50, 60, 70, 80, 90));
numbers.add(10);
numbers.addFirst(3);
numbers.addLast(200);

for (Integer num : numbers) {
    System.out.println(num);
}
```

**Output:**

```
3
50
60
70
80
90
10
200
```

* Shows insertion at beginning, end, and middle.
* Demonstrates dynamic resizing and order preservation.

---

## **6. Summary**

* **LinkedList** is a **doubly-linked structure** providing efficient insertion and deletion.
* **ArrayList** is better for random access; LinkedList is better for dynamic modification.
* Java‚Äôs `LinkedList` class supports all List operations and additional methods from **Deque interface**.
* Choosing the right data structure depends on **operation frequency** and **memory constraints**.

---

## **7. Application / Practical Use**

* Use LinkedList for **queues** and **stacks** (FIFO/LIFO).
* Ideal for applications with **frequent insertions/deletions**, like playlist management or undo-redo functionality.
* Can combine with **iterators** for reverse traversal or complex operations.

---

## **8. Self-Assessment Questions**

1. Explain the difference between a singly-linked list and a doubly-linked list.
2. Why is insertion in a linked list more efficient than in an array?
3. Write a Java code snippet to insert `15` at the beginning and `100` at the end of a LinkedList.
4. What are the disadvantages of using a LinkedList over an ArrayList?
5. Name four methods in LinkedList that are **not available in ArrayList**.
6. How would you traverse a LinkedList in **reverse order**?

---

# **üìòArrayDeque**

---


## **Learning Objectives**

By the end of this module, you will be able to:

1. Understand the concept of **Deque (Double-Ended Queue)**.
2. Explain how **ArrayDeque** works internally using arrays.
3. Use **ArrayDeque** to implement both **stack** and **queue** behaviors.
4. Identify key methods for insertion, deletion, and retrieval from both ends.
5. Understand the difference between methods that throw exceptions vs safer alternatives.
6. Write practical Java code using ArrayDeque efficiently.

---

## **1. What is a Deque?**

* **Deque** = Double-Ended Queue.
* Elements can be **inserted or removed from both ends** (front and rear).
* Can behave like a **queue** or a **stack** depending on usage:

| Usage                      | Behavior     | Explanation        |
| -------------------------- | ------------ | ------------------ |
| Insert rear, remove front  | Queue (FIFO) | First In First Out |
| Insert front, remove front | Stack (LIFO) | Last In First Out  |
| Insert rear, remove rear   | Stack (LIFO) | Last In First Out  |
| Insert front, remove rear  | Queue (FIFO) | First In First Out |

---

## **2. ArrayDeque Class**

* Implements **Deque interface** and interfaces like **Queue**, **Collection**, **Iterable**.
* Internally uses **arrays** as the storage mechanism.
* Performs **insertions and deletions in constant (amortized) time**, making it faster than the legacy `Stack` class.
* Safer and more efficient than `LinkedList` for implementing stacks or queues.

**Key advantage:** You can use a single class for both **stack** and **queue operations**.

---

## **3. Important Methods**

### **Insertion**

* `addFirst(element)` / `offerFirst(element)` ‚Üí Add to the front.
* `addLast(element)` / `offerLast(element)` ‚Üí Add to the rear.
* **Difference**:

  * `addFirst/addLast` throw exceptions if insertion fails.
  * `offerFirst/offerLast` return `false` instead of throwing an exception (safer).

### **Removal**

* `removeFirst()` / `pollFirst()` ‚Üí Remove from front.
* `removeLast()` / `pollLast()` ‚Üí Remove from rear.
* **Difference**:

  * `removeFirst/removeLast` throw exceptions if removal fails.
  * `pollFirst/pollLast` return `null` if the deque is empty.

### **Access Without Removal**

* `getFirst()` / `peekFirst()` ‚Üí View first element.
* `getLast()` / `peekLast()` ‚Üí View last element.

**Tip:** Use `peek` and `poll` methods to avoid exceptions.

---

## **4. Using ArrayDeque as a Stack or Queue**

### **Stack (LIFO)**

* Insert and delete from the **same end**.

```java
ArrayDeque<Integer> stack = new ArrayDeque<>();
stack.offerLast(10);
stack.offerLast(20);
stack.offerLast(30);

System.out.println(stack.pollLast()); // 30
System.out.println(stack.pollLast()); // 20
```

### **Queue (FIFO)**

* Insert at **one end** and delete from the **other end**.

```java
ArrayDeque<Integer> queue = new ArrayDeque<>();
queue.offerLast(10);
queue.offerLast(20);
queue.offerLast(30);

System.out.println(queue.pollFirst()); // 10
System.out.println(queue.pollFirst()); // 20
```

### **Bidirectional Operations**

```java
ArrayDeque<Integer> dq = new ArrayDeque<>();
dq.offerFirst(1);  // insert front
dq.offerFirst(2);  // insert front
dq.offerLast(10);  // insert rear
dq.offerLast(20);  // insert rear

dq.forEach(x -> System.out.println(x));
// Output: 2, 1, 10, 20
```

---

## **5. Notes on Performance**

* ArrayDeque operations are **faster than Stack** because Stack is a legacy class.
* All operations are **constant time** (O(1)) on average.
* Internally, ArrayDeque starts inserting near the middle of the array for efficient insertion at both ends.
* Automatically resizes if array space runs out.

---

## **6. Practical Guidelines**

1. Use **ArrayDeque** for stacks instead of `Stack` class.
2. Use **ArrayDeque** for queues instead of `LinkedList` when you need high performance.
3. Choose between `add/remove` vs `offer/poll` depending on whether you want exception handling.
4. Use **forEach loop or lambda** for simple traversal.

---

## **7. Summary**

* **Deque = double-ended queue**, supports insertion and deletion from both ends.
* **ArrayDeque** is a high-performance implementation of Deque.
* Can act as **stack** (LIFO) or **queue** (FIFO).
* Offers **constant-time operations** for add, remove, and access.
* Safer and more efficient than older alternatives (Stack and LinkedList).

---

## **8. Self-Assessment Questions**

1. What is the difference between a **Deque** and a normal queue?
2. How can you use **ArrayDeque** to implement a stack?
3. How can you use **ArrayDeque** to implement a queue?
4. Explain the difference between `addFirst` and `offerFirst`.
5. Write a Java code snippet that adds 1, 2, 3 to the front and 10, 20, 30 to the rear of an ArrayDeque and prints all elements.
6. Why is ArrayDeque preferred over Stack for implementing LIFO?
7. What happens if you call `pollFirst()` on an empty ArrayDeque?

---
# **üìòPriorityQueue**
---

## **Learning Objectives**

By the end of this module, you will be able to:

1. Understand the concept of **PriorityQueue** in Java.
2. Explain how a **heap** data structure underlies a PriorityQueue.
3. Describe how **priority is determined** for elements.
4. Use **PriorityQueue** methods to insert, remove, and access elements.
5. Implement a **custom comparator** to change priority order.
6. Understand the **time complexity** of insertion and deletion operations.

---

## **1. What is a PriorityQueue?**

* A **PriorityQueue** is a data structure where elements are stored **based on priority**.
* **Priority is determined by the element‚Äôs value** (or a custom comparator).
* Elements with **higher priority** are removed first.

  * By default, **smaller numbers have higher priority** (min-heap).
  * You can reverse this order using a **custom comparator** (max-heap).
* Internally, a **PriorityQueue uses a binary heap**, implemented with an array.

**Important:** You cannot arbitrarily delete an element; removal always targets the **highest priority element**.

---

## **2. Heap Concept**

* **Heap** is a complete binary tree where:

  * Min-heap: Root is **smallest element**.
  * Max-heap: Root is **largest element**.
* **Insertion:** Element is added at the next available position, then ‚Äúbubbled up‚Äù to maintain heap property.
* **Deletion:** Only the root is removed. The next element is adjusted to restore heap property.
* **Time complexity:** Both insertion and deletion take **O(log n)** because elements shift along the height of the tree.

**Example of min-heap insertion:**

```
Insert: 20, 10, 30, 5, 15, 3

Heap after insertions:
        3
      /   \
    5       10
   / \     / 
 20  15   30
```

* Deleting the root (3) adjusts the tree, next smallest element becomes the new root.

---

## **3. Key PriorityQueue Methods**

| Method                            | Description                    | Time Complexity |
| --------------------------------- | ------------------------------ | --------------- |
| `add(element)` / `offer(element)` | Insert element                 | O(log n)        |
| `peek()` / `element()`            | Retrieve head without removing | O(1)            |
| `poll()` / `remove()`             | Remove head element            | O(log n)        |
| `contains(element)`               | Check if element exists        | O(n)            |

**Notes:**

* `offer` and `poll` are safer alternatives that handle exceptions gracefully.
* `peek` returns the head element without removing it.

---

## **4. Using PriorityQueue in Java**

### **Min-Heap Example**

```java
PriorityQueue<Integer> pq = new PriorityQueue<>();
pq.add(20);
pq.add(10);
pq.add(30);
pq.add(5);
pq.add(15);
pq.add(3);

System.out.println("Head: " + pq.peek()); // 3

pq.forEach(x -> System.out.println(x));
// Output (internal heap order may vary): 3, 5, 10, 20, 15, 30

pq.poll(); // removes 3
```

### **Max-Heap Example (Custom Comparator)**

```java
Comparator<Integer> maxHeapComparator = (a, b) -> b - a;

PriorityQueue<Integer> pqMax = new PriorityQueue<>(maxHeapComparator);
pqMax.add(20);
pqMax.add(10);
pqMax.add(30);
pqMax.add(5);

System.out.println("Head: " + pqMax.peek()); // 30 (largest element)
pqMax.poll(); // removes 30
```

---

## **5. Important Notes**

1. Elements **must be comparable**, otherwise a `ClassCastException` occurs.
2. You can define a **custom comparator** to change the default priority order.
3. **Heap operations** (insert/remove) are O(log n), while `contains` is O(n).
4. PriorityQueue is widely used in **algorithmic applications**, such as:

   * Dijkstra‚Äôs shortest path
   * Huffman coding
   * Task scheduling

---

## **6. Summary**

* **PriorityQueue** organizes elements based on **priority**, not insertion order.
* Uses **binary heap** internally (array-based).
* Supports **min-heap by default**; max-heap possible with a comparator.
* Efficient for applications requiring **dynamic priority ordering**.

---

## **7. Self-Assessment Questions**

1. What is the default priority rule in a Java PriorityQueue?
2. Why does insertion and deletion in a PriorityQueue take O(log n) time?
3. How can you implement a max-heap using PriorityQueue?
4. What happens if you try to add elements that are not comparable?
5. Write a Java snippet to create a min-heap PriorityQueue, add elements, and print them using a lambda expression.
6. Explain the difference between `add` and `offer`, and `poll` and `remove`.

---

# **üìòHashing Technique**

---


## **Learning Objectives**

By the end of this module, you will be able to:

1. Explain the concept of **hashing**.
2. Identify Java classes that use hashing (HashSet, HashMap, LinkedHashSet, LinkedHashMap, Hashtable, Properties).
3. Understand **buckets** and how values are stored in a hash table.
4. Learn two main collision-handling techniques: **Open Addressing** and **Chaining**.
5. Explain **load factor** and its importance.
6. Demonstrate insertion and searching in a hash table.

---

## **1. What is Hashing?**

* **Hashing** is a technique to map **keys or values** to specific **locations** in a table using a **hash function**.
* Each location in a hash table is called a **bucket**.
* A bucket may store **one or more entries**, depending on the collision-handling method.
* Hashing allows **constant time operations** (O(1)) for insertion and searching in ideal cases.

---

## **2. Hash Table and Buckets**

* A **hash table** has an **initial size** (often 16 in Java).
* The **size can grow dynamically** as more elements are inserted.
* Hash function example:

```text
index = value % table_size
```

* Example insertion:

```
Insert 15 in table of size 10: 15 % 10 = 5 ‚Üí store at index 5
Insert 28: 28 % 10 = 8 ‚Üí store at index 8
Insert 42: 42 % 10 = 2 ‚Üí store at index 2
```

---

## **3. Collision Handling**

When two keys hash to the same index, this is called a **collision**.
Java uses two primary methods to handle collisions:

### **A. Open Addressing**

* If a bucket is occupied, **insert the element in the next available location**.
* Example:

```
Insert 35: 35 % 10 = 5 ‚Üí index 5 is occupied by 15 ‚Üí check next index ‚Üí insert 35 at index 6
```

* **Search:** Use hash function, check sequentially until value is found or a **blank bucket** is reached.
* **Important:** Table must have **some blank spaces** to terminate search.

  * Ideal fill: 50% keys, 50% blanks
  * Acceptable fill: ‚â§ 75% keys ‚Üí blank spaces ensure search can terminate

---

### **B. Chaining**

* Each bucket can **store multiple elements** in a **linked list**.
* Example:

```
Insert 15 ‚Üí index 5 ‚Üí store in bucket
Insert 35 ‚Üí index 5 ‚Üí store in linked list at bucket 5
```

* **Search:** Go to bucket ‚Üí traverse linked list to find key.
* No issue with load factor; linked list can grow as needed.

---

## **4. Load Factor**

* **Load Factor (LF)** = (Number of keys) / (Size of hash table)
* Determines when the table should **resize** or **rehash**.
* Open addressing is sensitive to load factor; chaining can handle higher loads without resizing.

---

## **5. Searching in Hash Table**

### **Open Addressing**

1. Compute index using hash function.
2. Check if value exists at that index.
3. If not, check sequentially until value found or blank bucket encountered.

### **Chaining**

1. Compute index using hash function.
2. Traverse linked list at that bucket to find value.
3. If not found, key does not exist.

---

## **6. Java Classes Using Hashing**

* **HashSet** ‚Üí stores unique values (no duplicates)
* **HashMap** ‚Üí stores key-value pairs
* **LinkedHashSet** ‚Üí preserves insertion order
* **LinkedHashMap** ‚Üí preserves insertion order with key-value pairs
* **Hashtable** ‚Üí legacy synchronized key-value store
* **Properties** ‚Üí key-value pairs, often for configuration

**Concepts behind these classes:**

* Open addressing or a combination of open addressing and chaining
* Resizing of hash table based on **load factor**
* Use of hash function for quick access

---

## **7. Practical Tips**

1. **Draw a hash table** and try inserting sample keys manually to see collisions.
2. Observe **open addressing vs chaining**.
3. Understand **importance of blank spaces** in open addressing.
4. Think about **resizing** and **rehashing** when table grows.

---

## **8. Summary**

* Hashing maps **keys or values** to a bucket using a **hash function**.
* Two main collision strategies:

  * **Open Addressing** ‚Üí linear probing in next available space
  * **Chaining** ‚Üí linked list at each bucket
* **Load factor** controls how full a hash table should be.
* Many Java classes rely on hashing for **fast access** (O(1) on average).

---


---

# **üìòHashSet**

## **1. Introduction**

* **HashSet** is a **Set**: it **does not allow duplicate elements**.
* **Hash**: internally uses **hash table** for storing elements.
* Implements **Collection** and **Set** interfaces.
* Offers **constant time performance** (O(1)) for basic operations like `add`, `remove`, `contains`, and `size`.
* Unlike `ArrayList` or `LinkedList` which may take **O(n)** time, `HashSet` is faster due to hashing.

---

## **2. Constructors**

HashSet has several constructors:

1. **Non-parameterized constructor**

```java
HashSet<Integer> hs = new HashSet<>();
```

2. **Constructor with initial capacity**

```java
HashSet<Integer> hs = new HashSet<>(initialCapacity);
```

* Default capacity: **16**
* Capacity increases dynamically as elements are added.

3. **Constructor with initial capacity and load factor**

```java
HashSet<Integer> hs = new HashSet<>(initialCapacity, loadFactor);
```

* **Load factor**: controls how full the hash table can be before resizing.
* Default: 0.75
* Recommended: 0.5 for balance between space and performance.
* Should be **between 0 and 1**.

---

## **3. HashSet Characteristics**

* **No duplicates**: only unique elements are stored.
* **No guaranteed order**: elements may appear in any order.
* **Fast operations**: add, remove, and search in constant time.
* **Dynamic resizing**: table size increases automatically if more elements are added than allowed by the load factor.
* **Space trade-off**: some space is wasted to maintain constant time performance (default ~25%).

---

## **4. Common Methods**

| Method          | Description                      |
| --------------- | -------------------------------- |
| `add(E e)`      | Adds element to the HashSet      |
| `remove(E e)`   | Removes element from the HashSet |
| `contains(E e)` | Checks if element exists         |
| `size()`        | Returns number of elements       |
| `iterator()`    | Iterates through elements        |
| `clear()`       | Removes all elements             |

**Example Code:**

```java
import java.util.*;

public class HashSetDemo {
    public static void main(String[] args) {
        HashSet<Integer> hs = new HashSet<>();

        hs.add(10);
        hs.add(20);
        hs.add(30);
        hs.add(10); // duplicate, will be ignored

        System.out.println(hs); // Output: [10, 20, 30] (order not guaranteed)
    }
}
```

---

## **5. Practical Tips**

1. Decide **load factor** based on expected number of elements.
2. Use HashSet when **fast add/remove operations** are needed.
3. Remember **HashSet ignores insertion order**.
4. For ordered sets, use **LinkedHashSet**.

---

‚úÖ **Summary**

* HashSet is efficient for storing **unique elements**.
* Internally uses **hashing** for **constant time operations**.
* Load factor and initial capacity are key parameters affecting **performance and memory usage**.

---

# **üìòTreeSet**

---


## **1. Introduction**

* **TreeSet** is a **Set**: it stores **unique elements** (no duplicates).
* **Tree**: uses a tree-based data structure for storage (likely a **Red-Black Tree** or **AVL Tree**).
* Guarantees **log(n) time complexity** for basic operations like `add`, `remove`, and `contains`.
* Implements multiple interfaces:

  * `Set` ‚Äì ensures uniqueness.
  * `SortedSet` ‚Äì maintains elements in **sorted order**.
  * `NavigableSet` ‚Äì provides navigation methods (`ceiling`, `floor`, etc.).
  * `Collection` ‚Äì basic collection interface.

---

## **2. Constructors**

TreeSet provides several constructors:

1. **No-parameter constructor**

```java
TreeSet<Integer> ts = new TreeSet<>();
```

2. **Constructor with a Collection**

```java
TreeSet<Integer> ts = new TreeSet<>(List.of(10, 20, 30));
```

3. **Constructor with Comparator**

```java
TreeSet<Integer> ts = new TreeSet<>(Comparator.reverseOrder());
```

---

## **3. TreeSet Characteristics**

* **No duplicates**: automatically removes duplicates.
* **Sorted elements**: maintains natural order (or custom order using `Comparator`).
* **Logarithmic performance**: `add`, `remove`, `contains` take **O(log n)** time.
* **Generic**: can store `Integer`, `Float`, `Double`, `Character`, `String`, or any **comparable object**.

---

## **4. Common Methods**

| Method                 | Description                         |
| ---------------------- | ----------------------------------- |
| `add(E e)`             | Adds an element                     |
| `addAll(Collection c)` | Adds all elements from a collection |
| `ceiling(E e)`         | Returns smallest element **‚â• e**    |
| `floor(E e)`           | Returns largest element **‚â§ e**     |
| `first()`              | Returns first (smallest) element    |
| `last()`               | Returns last (largest) element      |
| `descendingSet()`      | Returns reversed order set          |
| `contains(E e)`        | Checks if element exists            |
| `iterator()`           | Iterates in ascending order         |
| `descendingIterator()` | Iterates in descending order        |
| `remove(E e)`          | Removes element                     |

**Example Code:**

```java
import java.util.*;

public class TreeSetDemo {
    public static void main(String[] args) {
        TreeSet<Integer> ts = new TreeSet<>(List.of(20, 30, 50, 70, 10, 40, 10));
        
        System.out.println(ts); // Output: [10, 20, 30, 40, 50, 70] (sorted, no duplicates)

        ts.add(25);
        System.out.println(ts); // Output: [10, 20, 25, 30, 40, 50, 70]

        System.out.println(ts.ceiling(55)); // Output: 70
        System.out.println(ts.floor(55));   // Output: 50
    }
}
```

---

## **5. Interfaces and References**

* **TreeSet** implements multiple interfaces. You can create references of these interfaces:

```java
Collection<Integer> c = new TreeSet<>();
SortedSet<Integer> s = new TreeSet<>();
```

* **Limitation**: reference can only access methods declared in the interface type.

  * Example: `Collection` reference cannot access `ceiling()` or `floor()`.
  * `SortedSet` reference can access sorted-specific methods.

---

## **6. Comparable**

* **Comparable** interface allows objects of custom classes to be **sorted naturally**.
* Required if you want to store **user-defined objects** in TreeSet without a custom Comparator.
* `Comparator` interface can also be used for **custom sorting order**.

---

‚úÖ **Summary**

* TreeSet = **unique + sorted elements**.
* Provides **log(n) performance** for basic operations.
* Useful when **natural ordering** or **sorted collections** are needed.
* Can store any **comparable objects**.
* Interfaces like `Collection`, `SortedSet`, `NavigableSet` control what methods are accessible.

---

# **üìòComparable Interface **

---


## **1. Introduction**

* Previously, TreeSet was used with integers.
* For **custom objects**, TreeSet must know **how to compare them** to maintain sorted order.
* Java uses the **Comparable interface** to define this comparison.
* The **compareTo()** method must be overridden to define the sorting logic.

---

## **2. Example Scenario**

* Class: `Point` (representing coordinates in a 2D plane).
* Properties: `int x`, `int y`.
* Goal: Define which point is **smaller** or **greater**:

  1. Compare **x-coordinate** first.
  2. If `x` is equal, compare **y-coordinate**.
  3. If both are equal, points are equal.

**Example Points:**

```
(1,1), (5,5), (5,2)
```

* Sorting criteria: `(1,1) < (5,2) < (5,5)`

---

## **3. Implementing Comparable**

### **Step 1: Define the Point Class**

```java
class Point implements Comparable<Object> {
    int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public String toString() {
        return "(" + x + "," + y + ")";
    }

    @Override
    public int compareTo(Object o) {
        Point p = (Point) o;

        if (this.x < p.x) return -1;
        else if (this.x > p.x) return 1;
        else { // x values are equal
            if (this.y < p.y) return -1;
            else if (this.y > p.y) return 1;
            else return 0; // points are equal
        }
    }
}
```

### **Notes**

* The parameter of `compareTo` must be **Object**, because Comparable is generic.
* Must **typecast** to your class (`Point`) before comparing properties.
* Return values:

  * `-1` ‚Üí this object is smaller
  * `1` ‚Üí this object is greater
  * `0` ‚Üí objects are equal

---

## **4. Using TreeSet with Custom Objects**

```java
import java.util.*;

public class TreeSetPointsDemo {
    public static void main(String[] args) {
        TreeSet<Point> ts = new TreeSet<>();

        ts.add(new Point(1,1));
        ts.add(new Point(5,5));
        ts.add(new Point(5,2));

        System.out.println(ts);
        // Output: [(1,1), (5,2), (5,5)]
    }
}
```

* TreeSet automatically **sorts objects** using `compareTo()`.
* `toString()` ensures points are printed in readable format.

---

## **5. Key Points**

* **TreeSet** requires elements to be comparable for sorting.
* For **custom classes**, implement **Comparable** and override `compareTo()`.
* Sorting logic can be customized (here based on `x` then `y`).
* Ensures **no duplicates** in TreeSet, and elements are **sorted automatically**.

---

‚úÖ **Summary**

* Comparable allows **custom object sorting** in TreeSet.
* Always override `compareTo()` to define sorting rules.
* Properly implement `toString()` for readable output.
* TreeSet + Comparable = **sorted collection of custom objects**.

---

# **TreeMap and HashMap**

---


## **1. Introduction**

* Both **TreeMap** and **HashMap** are implementations of the **Map interface** in Java.
* A **Map** stores **key-value pairs**.
* **Difference between Tree and Hash**:

  * Tree structures (like TreeMap) maintain **sorted order**.
  * Hash structures (like HashMap) do **not guarantee order**, but provide **faster access**.

---

## **2. TreeMap**

* **Implementation**: Based on **Red-Black Tree** (a type of self-balancing binary search tree).
* **Interfaces implemented**: `Map`, `SortedMap`, `NavigableMap`.
* **Performance**: Guaranteed **O(log n)** for basic operations (`put`, `get`, `remove`).

### **Key Features**

1. Maintains keys in **sorted order**.
2. Supports operations like:

   * `ceilingEntry(key)`: Returns entry with **key ‚â• given key**.
   * `floorEntry(key)`: Returns entry with **key ‚â§ given key**.
   * `higherEntry(key)`: Returns entry with **key > given key**.
   * `lowerEntry(key)`: Returns entry with **key < given key**.
   * `firstEntry()`, `lastEntry()`: Returns **first/last entry**.
   * `subMap(startKey, endKey)`, `tailMap(startKey)`: Returns a portion of the map.
   * `containsKey(key)`, `containsValue(value)`.

### **Example**

```java
import java.util.*;

public class TreeMapDemo {
    public static void main(String[] args) {
        TreeMap<Integer, String> tm = new TreeMap<>();

        tm.put(0, "A");
        tm.put(1, "B");
        tm.put(2, "C");
        tm.put(3, "D");
        tm.put(4, "E");
        tm.put(5, "F");

        System.out.println(tm); // {0=A, 1=B, 2=C, 3=D, 4=E, 5=F}

        // Ceiling entry
        System.out.println(tm.ceilingEntry(6).getValue()); // G (nearest higher key if 6 not present)

        // First entry
        Map.Entry<Integer, String> e = tm.firstEntry();
        System.out.println(e.getKey() + " " + e.getValue()); // 0 A

        // Get value by key
        System.out.println(tm.get(3)); // D
    }
}
```

---

## **3. HashMap**

* **Implementation**: Uses **hash table**.
* **Interfaces implemented**: `Map`.
* **Performance**: O(1) **average time** for basic operations (`put`, `get`, `remove`).

### **Key Points**

* Does **not maintain order** of keys.
* Most **methods are similar to TreeMap**: `put`, `get`, `containsKey`, `containsValue`, `remove`, `replace`.
* Some **methods specific to TreeMap** (like `firstEntry()`, `ceilingEntry()`) are **not available** in HashMap.
* Can specify **initial capacity** and **load factor** to manage performance and memory.

### **Switching Between TreeMap and HashMap**

* Easy to switch: just replace `TreeMap` with `HashMap`.
* Choose **TreeMap** if **sorted order** is needed.
* Choose **HashMap** if **fast access** is required and order is not important.

---

## **4. Key Methods Comparison**

| Feature / Method | TreeMap  | HashMap   |
| ---------------- | -------- | --------- |
| Order            | Sorted   | Unordered |
| Time Complexity  | O(log n) | O(1) avg  |
| put() / get()    | Yes      | Yes       |
| containsKey()    | Yes      | Yes       |
| firstEntry()     | Yes      | No        |
| ceilingEntry()   | Yes      | No        |
| subMap()         | Yes      | No        |
| keySet()         | Yes      | Yes       |
| entrySet()       | Yes      | Yes       |

---

‚úÖ **Summary**

* **TreeMap**: Sorted, log(n) operations, based on Red-Black tree.
* **HashMap**: Unsorted, constant time, based on hash table.
* **Use TreeMap** when **order matters**; **use HashMap** when **speed matters**.

---

# **üìòLinkedHashMap**

---


## **1. Overview**

* **LinkedHashMap** is similar to **HashMap**: stores **key-value pairs**.
* **Difference from HashMap**: maintains **insertion order** or **access order** using a **doubly linked list** along with the hash table.
* Each **bucket (entry)** contains pointers: `next` and `previous`.

---

## **2. Structure Comparison**

| Feature               | HashMap                          | LinkedHashMap                           |
| --------------------- | -------------------------------- | --------------------------------------- |
| Order of keys         | Unordered                        | Maintains insertion/access order        |
| Underlying structure  | Hash table                       | Hash table + doubly linked list         |
| Iteration performance | Faster                           | Slightly slower (traverses linked list) |
| Access by key         | O(1)                             | O(1)                                    |
| Collision handling    | Same (linear probing / chaining) | Same                                    |

---

## **3. Key Points**

1. **Insertion Order**: LinkedHashMap preserves the order in which keys were inserted.

   * Each entry points to **next** and **previous** entries.
   * Useful for predictable iteration order.

2. **Access Order**:

   * Optionally, keys can be reordered based on **access**.
   * Recently accessed keys move to the front.
   * Supports **LRU (Least Recently Used)** behavior ‚Äî commonly used in **cache implementation**.

3. **Capacity & Load Factor**:

   * Ideal to keep **50% of buckets empty** for better performance.
   * Default load factor is **0.75**.
   * Avoid filling hash table to 100% to prevent collisions and slow lookups.

4. **Performance**:

   * `put`, `get`, `remove`: **O(1)** constant time (hash function used).
   * Iteration: slightly slower due to linked list traversal.

---

## **4. Behavior Examples**

* **Insertion Order**:
  Insert keys: 12 ‚Üí 17 ‚Üí 14 ‚Üí 24
  Iteration returns keys in the same order: 12, 17, 14, 24

* **Collision Handling**:
  If two keys map to same bucket, linked list allows searching for next free space.

* **Access Order / LRU Cache**:

  * Limit size, e.g., 10 keys
  * Insert 11th key ‚Üí **least recently used key is removed**
  * Useful for **cache memory management**

---

## **5. Use Cases**

* Predictable iteration order (unlike HashMap).
* Implementing **LRU cache**.
* Maintaining **insertion order** in collections.

---

‚úÖ **Summary**

* LinkedHashMap = HashMap + doubly linked list.
* Keeps insertion or access order.
* Constant time access, slightly slower iteration.
* Can be used for **cache implementations (LRU)**.

---

# **Using LinkedHashMap as Cache**

---


## **1. Setup**

```java
import java.util.*;
```

* Create a **LinkedHashMap** object:

```java
LinkedHashMap<Integer, String> lhm = new LinkedHashMap<>(5);
```

* **Initial capacity**: 5 (can grow dynamically).
* **Key type**: `Integer`
* **Value type**: `String`

---

## **2. Inserting Elements**

```java
lhm.put(1, "A");
lhm.put(2, "B");
lhm.put(3, "C");
lhm.put(4, "D");
lhm.put(5, "E");
```

* Maintains **insertion order**: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5

* Adding more entries beyond initial capacity:

```java
lhm.put(6, "F");
lhm.put(9, "I");
lhm.put(8, "H");
```

* LinkedHashMap **automatically resizes**, insertion order is preserved: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí 6 ‚Üí 9 ‚Üí 8

---

## **3. Accessing Elements**

```java
String val1 = lhm.get(2);  // B
String val2 = lhm.get(5);  // E
```

* **Default behavior**: order remains as **insertion order**.
* **Access order mode**: can be enabled using a constructor:

```java
LinkedHashMap<Integer, String> lhmAccessOrder = new LinkedHashMap<>(initialCapacity, loadFactor, true);
```

* **true** ‚Üí keys are ordered by **access**, not insertion.
* Most recently accessed keys move to the **end**; least recently used remain at the beginning.

---

## **4. Limiting Size (Cache Behavior)**

* To limit size (e.g., 5 entries), override the **`removeEldestEntry`** method:

```java
LinkedHashMap<Integer, String> cache = new LinkedHashMap<Integer, String>(5, 0.75f, true) {
    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer, String> eldest) {
        return size() > 5;
    }
};
```

* **Behavior**:

  * When `size() > 5`, the **eldest entry** is removed automatically.
  * Eldest is determined by:

    * **Insertion order**: first inserted key
    * **Access order**: least recently accessed key

* This is commonly used for **LRU cache implementation**.

---

## **5. Key Points**

1. **Insertion Order** is preserved by default.
2. **Access Order** can be enabled for LRU behavior.
3. **Initial capacity** can grow dynamically; does not limit size unless `removeEldestEntry` is overridden.
4. **Operations `put`, `get`, `remove`** are **O(1)** (hash function).
5. Iterating is slightly slower than HashMap because of linked list traversal.

---

‚úÖ **Summary**

* LinkedHashMap = HashMap + doubly linked list.
* Maintains order (insertion or access).
* Can implement **fixed-size cache** with **automatic removal of eldest entries**.
* Useful for **predictable iteration** and **LRU caching**.

---

# **üìòLinkedHashSet**

---


## **1. Overview**

* **LinkedHashSet** is a **Set** implementation.
* Stores **unique values only** (like HashSet).
* **Maintains insertion order**, unlike HashSet which does **not guarantee order**.
* Similar to **LinkedHashMap**, but stores **only values**, not key-value pairs.

---

## **2. Class and Constructors**

```java
LinkedHashSet<String> lhs = new LinkedHashSet<>(initialCapacity);
```

* **Initial capacity**: Default is 16 if not specified.
* **Optional loading factor**: Can also specify for performance tuning.
* **Dynamic size**: Grows as elements are inserted.
* **Cannot fix a limit** like in LinkedHashMap.

---

## **3. Inserting Elements**

```java
lhs.add("A");
lhs.add("C");
lhs.add("E");
lhs.add("K");
lhs.add("B");
lhs.add("G");
```

* Maintains **insertion order**: `A ‚Üí C ‚Üí E ‚Üí K ‚Üí B ‚Üí G`.
* **Duplicate values are ignored**: `.add("B")` again does nothing.

---

## **4. Iterating Elements**

```java
lhs.forEach(System.out::println);
```

* Prints elements **in the order of insertion**.
* Using an iterator:

```java
Iterator<String> itr = lhs.iterator();
while(itr.hasNext()) {
    System.out.println(itr.next());
}
```

---

## **5. Comparison with HashSet**

| Feature            | HashSet                                  | LinkedHashSet            |
| ------------------ | ---------------------------------------- | ------------------------ |
| Maintains order    | ‚ùå No                                     | ‚úÖ Yes, insertion order   |
| Stores duplicates  | ‚ùå No                                     | ‚ùå No                     |
| Iteration order    | Unpredictable (appears sorted sometimes) | Same as insertion order  |
| Internal structure | Hash table                               | Hash table + linked list |

---

## **6. Key Points**

1. **LinkedHashSet = HashSet + linked list** to maintain insertion order.
2. **Duplicates not allowed** (like all sets).
3. Useful when you need **predictable iteration order** while ensuring uniqueness.
4. Both LinkedHashSet and HashSet use **hashing internally**.

---

‚úÖ **Summary**

* Use **HashSet** if you only need uniqueness and don‚Äôt care about order.
* Use **LinkedHashSet** if you need **uniqueness + insertion order preserved**.

---

# **üìòHashtable Legacy Class**

---


## **1. Overview**

* **Hashtable** is an **older Java class** for storing **key-value pairs**.
* Similar to **HashMap**, but now **obsolete** (not recommended for new code).
* Key points:

  * Originally **non-generic**: keys and values treated as `Object`.
  * Later, a **generic version** was introduced.
* Implements **Map interface**.

---

## **2. Creating a Hashtable**

**Non-generic version:**

```java
Hashtable ht = new Hashtable();
ht.put(1, "A");
ht.put(2, "B");
```

* Keys and values are **Objects**.
* **Retrieval requires typecasting**:

```java
String value = (String) ht.get(1); // must cast Object to String
```

**Generic version:**

```java
Hashtable<Integer, String> ht = new Hashtable<>();
ht.put(1, "A");
ht.put(2, "B");
String value = ht.get(1); // no typecasting required
```

---

## **3. Iterating Elements**

* Old class used **Enumeration** instead of Iterator:

```java
Enumeration e = ht.elements();
while(e.hasMoreElements()) {
    System.out.println(e.nextElement());
}
```

* For keys:

```java
Enumeration keys = ht.keys();
while(keys.hasMoreElements()) {
    System.out.println(keys.nextElement());
}
```

* In modern code, **Iterator or for-each** is preferred (with generic Hashtable).

---

## **4. Important Methods**

* **`put(key, value)`** ‚Üí insert key-value pair
* **`get(key)`** ‚Üí retrieve value for key
* **`compute(key, BiFunction)`** ‚Üí compute a new value for an existing key:

```java
ht.compute(2, (k, v) -> v + "Z"); // updates B ‚Üí BZ
```

* **`computeIfAbsent(key, Function)`** ‚Üí compute value only if key is absent:

```java
ht.computeIfAbsent(7, k -> "Z" + k); // inserts 7 ‚Üí Z7
```

* **`toString()`** prints all key-value pairs.

---

## **5. Key Points**

1. **Non-generic**: older versions treated all keys/values as `Object`.
2. **Generic version** exists now but still rarely used.
3. **Thread-safe** (methods are synchronized), unlike HashMap.
4. Modern code prefers **HashMap, HashSet, LinkedHashMap, LinkedHashSet**.
5. Useful **compute** methods allow mapping **key ‚Üí value** via functions.

---

‚úÖ **Summary**

* **Hashtable** = old synchronized map class.
* **Non-generic** vs **Generic** version exists.
* Modern development favors **HashMap** or **LinkedHashMap**.
* Useful for understanding **hashing, compute methods, and old Java collections**.

---

# **üìòProperties**

---


## **1. Overview**

* `Properties` class **inherits from Hashtable**.
* Stores **key-value pairs**, but **both key and value must be Strings**.
* Implements the **Map interface**.
* Commonly used for:

  * Application **configuration settings**.
  * **Storing and reading data** from property files.
  * **Data transfer** in a key-value format.

---

## **2. Creating a `Properties` Object**

```java
Properties p = new Properties();
```

### **Adding Properties**

```java
p.setProperty("brand", "Dell");
p.setProperty("processor", "i7");
p.setProperty("OS", "Windows 10");
p.setProperty("model", "Latitude");
```

* Both **key and value must be Strings**.
* Each key-value pair represents a **property**.

---

## **3. Printing Properties**

```java
System.out.println(p);
```

Output:

```
{brand=Dell, processor=i7, OS=Windows 10, model=Latitude}
```

* Left-hand side ‚Üí **key**
* Right-hand side ‚Üí **value**

---

## **4. Saving Properties to a File**

### **Text File**

```java
FileOutputStream out = new FileOutputStream("mydata.txt");
p.store(out, "Laptop Properties");
out.close();
```

* Creates a **.txt file** with key-value pairs.
* Includes **comment** and **timestamp**.

### **XML File**

```java
FileOutputStream outXML = new FileOutputStream("mydata.xml");
p.storeToXML(outXML, "Laptop Properties");
outXML.close();
```

* Creates **XML file** using Java's **DTD specification**:

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
  <properties>
      <comment>Laptop Properties</comment>
      <entry key="brand">Dell</entry>
      <entry key="processor">i7</entry>
  </properties>
  ```

---

## **5. Reading Properties from a File**

### **From XML**

```java
FileInputStream inXML = new FileInputStream("person.xml");
p.loadFromXML(inXML);
inXML.close();

// Access properties
System.out.println(p.getProperty("name"));  // John
System.out.println(p.getProperty("age"));   // 20
```

### **From Text File**

```java
FileInputStream inTxt = new FileInputStream("mydata.txt");
p.load(inTxt);
inTxt.close();

// Access properties
System.out.println(p.getProperty("brand"));  // Coca-Cola
System.out.println(p.getProperty("type"));   // drink
```

---

## **6. Key Methods**

| Method                              | Description                        |
| ----------------------------------- | ---------------------------------- |
| `setProperty(key, value)`           | Add or update a property           |
| `getProperty(key)`                  | Retrieve a property value          |
| `store(OutputStream, comment)`      | Save properties to **text file**   |
| `storeToXML(OutputStream, comment)` | Save properties to **XML file**    |
| `load(InputStream)`                 | Load properties from **text file** |
| `loadFromXML(InputStream)`          | Load properties from **XML file**  |

---

## **7. Key Points**

1. **Keys and values are Strings only.**
2. Can save **text or XML** representation of properties.
3. Can **read back** properties from file or XML.
4. Useful for **configuration, settings, and data transfer**.

---

‚úÖ **Summary**
The `Properties` class is a **specialized Hashtable** for **String key-value pairs**. It simplifies storing, saving, and reading **application settings** or configuration data in **text or XML formats**.

---

# **üìòStringTokenizer**

---


## **1. Overview**

* `StringTokenizer` is part of **`java.util` package**.
* **Purpose:** To break a string into **tokens** based on **delimiters**.
* Useful for parsing **key-value pairs**, CSV files, or any **delimited data**.

---

## **2. Concepts**

* **Token:** A meaningful element extracted from a string.
  Example: `"name=Vijay;address=Delhi;country=India"`
  Tokens: `name`, `Vijay`, `address`, `Delhi`, `country`, `India`
* **Delimiter:** Character(s) used to separate tokens.
  Example delimiters: `=`, `;`, `,`, `space`, `newline`.

---

## **3. Creating a `StringTokenizer` Object**

```java
String data = "name=Vijay;address=Delhi;country=India";
StringTokenizer stk = new StringTokenizer(data, "=;");
```

* **Parameters:**

  * The string to tokenize.
  * Delimiters as a string of characters.

---

## **4. Retrieving Tokens**

```java
while(stk.hasMoreTokens()) {
    String token = stk.nextToken();
    System.out.println(token);
}
```

* `hasMoreTokens()`: Returns true if there are more tokens.
* `nextToken()`: Returns the next token.
* `hasMoreElements()` can also be used (works like an iterator).

---

## **5. Delimiter Variations**

* **Default delimiters:** whitespace if none is specified.
* Multiple delimiters can be specified in one string: `"=; "`
* **Newline:** Works automatically without explicitly specifying `\n`.
* **Space:** Must be included explicitly if needed as a delimiter.

---

## **6. Reading and Tokenizing a File**

### **Example 1: Key-Value Pairs**

```java
FileInputStream fis = new FileInputStream("Student1.txt");
byte[] b = fis.readAllBytes();
String data = new String(b);
StringTokenizer stk = new StringTokenizer(data, "=");

while(stk.hasMoreTokens()) {
    System.out.println(stk.nextToken());
}
fis.close();
```

* Reads a file, converts to string, and tokenizes using `=` as delimiter.

### **Example 2: Numbers Separated by Comma**

```java
FileInputStream fis = new FileInputStream("Data.txt");
byte[] b = fis.readAllBytes();
String data = new String(b);

StringTokenizer stk = new StringTokenizer(data, ",");
ArrayList<Integer> al = new ArrayList<>();

while(stk.hasMoreTokens()) {
    al.add(Integer.valueOf(stk.nextToken()));
}

System.out.println(al);
fis.close();
```

* Reads numbers separated by `,` and stores them in an `ArrayList<Integer>`.

---

## **7. Key Points**

1. `StringTokenizer` is **simple and lightweight**, mostly for small-scale parsing.
2. It **does not support regular expressions** (use `String.split()` for regex).
3. Useful for **parsing configuration files, CSVs, and simple key-value pairs**.
4. Always ensure **correct delimiters** are specified.

---

‚úÖ **Summary**
`StringTokenizer` allows you to **break a string into smaller tokens** easily using **custom delimiters**.

* Use `hasMoreTokens()` and `nextToken()` to iterate over tokens.
* Can read data from **files** or **hardcoded strings**.
* Combine with collections like `ArrayList` for further processing.

---

# **üìòBitSet**

---


## **1. Overview**

* `BitSet` is part of **`java.util` package**.
* **Purpose:** A **dynamic array of bits** (`true/false` values) with methods for **bitwise operations**.
* Each bit can be `true` (1) or `false` (0).
* Conceptually similar to an array of boolean values.

---

## **2. Key Concepts**

* **Set a bit:** `bitSet.set(index)` ‚Üí makes the bit at `index` **true**.
* **Clear a bit:** `bitSet.clear(index)` ‚Üí makes the bit at `index` **false**.
* **Flip a bit:** `bitSet.flip(index)` ‚Üí toggles the bit at `index`.
* **Get bit:** `bitSet.get(index)` ‚Üí returns `true` or `false`.

---

## **3. Bitwise Operations**

`BitSet` allows operations on **two BitSets**:

| Operation | Method                    | Meaning                                |
| --------- | ------------------------- | -------------------------------------- |
| AND       | `bitSet1.and(bitSet2)`    | Intersection of two sets (common bits) |
| OR        | `bitSet1.or(bitSet2)`     | Union of two sets (all bits set)       |
| XOR       | `bitSet1.xor(bitSet2)`    | Bits set in either but not both        |
| NOT       | `bitSet.flip(start, end)` | Complement of bits in a range          |

---

## **4. Example Use Cases**

1. **Finding missing elements in a range:**

   * Example: You have 10 numbers but only 8 present.
   * Set bits for present numbers; bits that remain `false` indicate missing numbers.

2. **Detecting duplicates:**

   * Use BitSet to track occurrences; if a bit is already set, a duplicate exists.

3. **Set operations:**

   * AND ‚Üí Intersection
   * OR ‚Üí Union
   * XOR ‚Üí Symmetric difference

---

## **5. Sample Code Demonstration**

```java
import java.util.BitSet;

public class BitSetDemo {
    public static void main(String[] args) {
        // Create BitSets
        BitSet bs1 = new BitSet();
        BitSet bs2 = new BitSet();

        // Set bits in BitSet 1
        bs1.set(0); bs1.set(2); bs1.set(4); bs1.set(6); bs1.set(8);

        // Set bits in BitSet 2
        bs2.set(1); bs2.set(3); bs2.set(5); bs2.set(7);

        // Print BitSet 1
        System.out.println("BitSet1: " + bs1);

        // AND operation
        BitSet bsAnd = (BitSet) bs1.clone();
        bsAnd.and(bs2);
        System.out.println("AND: " + bsAnd);

        // OR operation
        BitSet bsOr = (BitSet) bs1.clone();
        bsOr.or(bs2);
        System.out.println("OR: " + bsOr);

        // Flip operation
        bs1.flip(0, bs1.length());
        System.out.println("Flipped BitSet1: " + bs1);

        // Get bit
        System.out.println("Bit at index 3: " + bs1.get(3));
    }
}
```

**Output Example:**

```
BitSet1: {0, 2, 4, 6, 8}
AND: {}
OR: {0, 1, 2, 3, 4, 5, 6, 7, 8}
Flipped BitSet1: {1, 3, 5, 7}
Bit at index 3: true
```

---

## **6. Key Points**

* `BitSet` **is not part of Collection Framework**.
* It is **memory efficient** for large sets of boolean flags.
* Works best in **logical applications, set operations, and tracking presence/absence**.
* Methods allow **bit-level manipulation** similar to primitive bitwise operators.

---

# **üìòArrays and Comparator**

---


## **1. Overview**

* `Arrays` is part of **`java.util` package**.
* Provides **static utility methods** for array operations.
* Works with **primitive types** (int, float, double, etc.) and **objects**.

---

## **2. Key Methods of `Arrays`**

### **a. compare**

* **Purpose:** Compare two arrays element by element.
* **Return values:**

  * `0` ‚Üí arrays are equal
  * `1` ‚Üí first array is greater
  * `-1` ‚Üí second array is greater
* Can also compare **subarrays** using start and end indexes.

### **b. equals / deepEquals**

* `equals(array1, array2)` ‚Üí returns `true` if arrays have same elements.
* `deepEquals(array1, array2)` ‚Üí used for **arrays of objects** (nested arrays).

### **c. copyOf**

```java
int[] c = Arrays.copyOf(a, 4); // copy first 4 elements of array a
```

* Creates a new array with specified **length**.

### **d. fill**

```java
Arrays.fill(c, 10); // fills array c with 10
```

* Initialize or overwrite all elements of an array with the same value.

### **e. sort / parallelSort**

* `Arrays.sort(array)` ‚Üí sorts in **ascending order**.
* `Arrays.parallelSort(array)` ‚Üí uses **multi-threaded merge sort**, useful for large arrays.

### **f. binarySearch**

* Requires a **sorted array**.
* Returns **index of element** if found; otherwise, a negative value.

### **g. mismatch**

* Returns **index of first mismatch** between two arrays.

---

## **3. Example Code**

```java
import java.util.Arrays;

public class ArraysDemo {
    public static void main(String[] args) {
        int[] a = {2, 4, 6, 8, 1, 3, 5, 7};
        int[] b = {2, 4, 6, 8, 1, 3, 5, 7};

        // Compare arrays
        System.out.println("Compare a & b: " + Arrays.compare(a, b));

        // Copy first 4 elements
        int[] c = Arrays.copyOf(a, 4);
        System.out.println("Copy: " + Arrays.toString(c));

        // Fill array with 10
        Arrays.fill(c, 10);
        System.out.println("Fill: " + Arrays.toString(c));

        // Sort array
        Arrays.sort(a);
        System.out.println("Sorted a: " + Arrays.toString(a));

        // Binary search
        System.out.println("Index of 2: " + Arrays.binarySearch(a, 2));
    }
}
```

---

## **Java `Comparator` Interface**

### **1. Overview**

* Allows **custom comparison logic** for sorting objects.
* Useful when:

  * Sorting **user-defined classes**.
  * Sorting in **custom order** (ascending, descending).

---

### **2. How to Use Comparator**

1. **Implement Comparator interface**:

```java
import java.util.Comparator;

class MyComparator implements Comparator<Integer> {
    @Override
    public int compare(Integer i1, Integer i2) {
        // Reverse order
        return i2 - i1;
    }
}
```

2. **Sort array using Comparator**:

```java
Integer[] a = {1,2,3,4,5,6,7,8};
Arrays.sort(a, new MyComparator());
System.out.println(Arrays.toString(a)); // [8,7,6,5,4,3,2,1]
```

* **Default `Comparable` interface** is used if no comparator is provided.
* Comparator allows **separate comparison logic** for the same class.

---

### **3. Key Points**

* Arrays class provides **sorting, searching, and utility methods**.
* `Comparator` enables **custom sorting** logic.
* `Comparable` is for **natural ordering**, implemented in the class itself.
* For **user-defined objects**, use either `Comparable` or `Comparator` depending on requirement.

---

# **üìòJava Manual-Driven Account Program**

---


## **1. Overview**

* The program is **menu-driven**.
* It uses **`HashMap<String, Account>`** to store accounts:

  * **Key:** `accountNumber` (String)
  * **Value:** `Account` object
* **Account details** are **persisted** in a file (`accounts.txt`) using **serialization**.
* Supports the following operations:

  1. Create an account
  2. Delete an account
  3. View a specific account
  4. View all accounts
  5. Save accounts to file
  6. Exit (also saves automatically)

---

## **2. Account Class**

```java
import java.io.Serializable;

class Account implements Serializable {
    private String accountNumber;
    private String name;
    private double balance;

    // Non-parameterized constructor
    public Account() {}

    // Parameterized constructor
    public Account(String accountNumber, String name, double balance) {
        this.accountNumber = accountNumber;
        this.name = name;
        this.balance = balance;
    }

    // Getter methods
    public String getAccountNumber() { return accountNumber; }
    public String getName() { return name; }
    public double getBalance() { return balance; }

    // Display account details
    @Override
    public String toString() {
        return "Account Number: " + accountNumber + ", Name: " + name + ", Balance: " + balance;
    }
}
```

---

## **3. Main Program Logic**

### **a. Load accounts from file**

```java
import java.io.*;
import java.util.*;

public class AccountManager {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        HashMap<String, Account> accounts = new HashMap<>();

        // Load existing accounts from file
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("accounts.txt"))) {
            int size = ois.readInt();
            for (int i = 0; i < size; i++) {
                Account acc = (Account) ois.readObject();
                accounts.put(acc.getAccountNumber(), acc);
            }
        } catch (Exception e) {
            System.out.println("No existing accounts found. Starting fresh.");
        }
```

---

### **b. Menu Driven Operations**

```java
        int choice;
        do {
            System.out.println("\n--- Account Menu ---");
            System.out.println("1. Create Account");
            System.out.println("2. Delete Account");
            System.out.println("3. View Account");
            System.out.println("4. View All Accounts");
            System.out.println("5. Save Accounts");
            System.out.println("6. Exit");
            System.out.print("Enter your choice: ");
            choice = sc.nextInt();
            sc.nextLine(); // consume newline

            switch (choice) {
                case 1: // Create account
                    System.out.print("Enter Account Number: ");
                    String accNum = sc.nextLine();
                    System.out.print("Enter Name: ");
                    String name = sc.nextLine();
                    System.out.print("Enter Balance: ");
                    double balance = sc.nextDouble();
                    sc.nextLine(); // consume newline
                    Account newAcc = new Account(accNum, name, balance);
                    accounts.put(accNum, newAcc);
                    System.out.println("Account created for " + name);
                    break;

                case 2: // Delete account
                    System.out.print("Enter Account Number to delete: ");
                    String delAccNum = sc.nextLine();
                    accounts.remove(delAccNum);
                    System.out.println("Account deleted if existed.");
                    break;

                case 3: // View account
                    System.out.print("Enter Account Number to view: ");
                    String viewAccNum = sc.nextLine();
                    Account acc = accounts.get(viewAccNum);
                    if (acc != null) {
                        System.out.println(acc);
                    } else {
                        System.out.println("Account not found.");
                    }
                    break;

                case 4: // View all accounts
                    for (Account a : accounts.values()) {
                        System.out.println(a);
                    }
                    break;

                case 5: // Save accounts
                case 6: // Exit (also saves)
                    try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("accounts.txt"))) {
                        oos.writeInt(accounts.size());
                        for (Account a : accounts.values()) {
                            oos.writeObject(a);
                        }
                        oos.flush();
                        System.out.println("Accounts saved successfully.");
                    } catch (IOException e) {
                        System.out.println("Error saving accounts.");
                    }
                    break;

                default:
                    System.out.println("Invalid choice.");
            }
        } while (choice != 6);
        sc.close();
    }
}
```

---

## **4. Key Points**

1. **Serialization**:

   * Enables saving objects (`Account`) to file and retrieving them later.
2. **HashMap**:

   * Efficient lookup using `accountNumber` as key.
3. **Menu-driven**:

   * Users can **create, delete, view, and save accounts**.
4. **Persistence**:

   * Accounts are restored automatically when program is restarted.

---

‚úÖ **Optional Enhancements**:

* Auto-generate account numbers.
* Input validation for balance.
* Sorting accounts by name or balance.
* Encryption for account file.

---

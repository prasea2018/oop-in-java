# **üìòWhat are Collections**
## **1Ô∏è‚É£ What is Collection Framework?**

* **Collection Framework = Data Structure in Java**

  * Java provides built-in data structures called **collections**.
  * Collections are used to **store and organize data** inside a program.
  * Without a collection framework (or some data structure), developing real-world applications is nearly impossible.

* **Data is Central**

  * Programs process **data** to compute results.
  * Most applications don‚Äôt deal with single values‚Äîthey deal with **lists of values** (e.g., students, books, accounts).

---

## **2Ô∏è‚É£ Sources of Data for a Java Program**

Java programs can get data from:

1. **Keyboard input**
2. **Files** (data already stored on disk)
3. **Databases**

   * Relational (SQL)
   * Object-oriented
4. **Remote computers / networks**

   * Through the internet or local network

üí° **Important:** The data is often a **list** (collection), not just a single value.

---

## **3Ô∏è‚É£ Examples of Data Lists**

* **List of primitive values:** integers, floats, etc.
* **List of objects:** students, books, customers, accounts, movies.
* **Purpose:** Computation, search, update, reporting, billing, etc.

Example:

```java
Student[] students = new Student[100];  // Array of 100 students
```

---

## **4Ô∏è‚É£ Storing Data in Memory**

* Once data comes from the source, it must be held in memory (typically in the **heap** for objects in Java).
* The **organization of data** in memory is called a **data structure**.
* **Collections** are Java‚Äôs way of arranging data efficiently.

---

## **5Ô∏è‚É£ Arrays: Basic Data Structure**

* Arrays are the simplest way to store a collection of values.
* Example:

```java
int[] numbers = new int[10];  // Array of integers
Student[] students = new Student[100]; // Array of Student objects
```

* **Limitations of Arrays:**

  1. Fixed size (cannot grow or shrink dynamically)
  2. Limited operations (insertion, deletion, searching are manual)
  3. Cannot handle complex operations efficiently for objects

---

## **6Ô∏è‚É£ Why Collections?**

* Arrays are not always sufficient for real-world applications.
* Java Collections provide:

  * Dynamic size (grow or shrink automatically)
  * Built-in methods for common operations:

    * Add, remove, search, sort, filter, iterate
  * Specialized collections depending on requirements:

    * **List**, **Set**, **Queue**, **Map**
* Collections solve the **drawbacks of arrays** and make programming easier for real-world applications.

---

## **Summary**

1. Programs need data from various sources.
2. Data is often in the form of **lists** (collections).
3. Arrays can store lists, but they have limitations.
4. Java provides **Collections Framework** to efficiently store, manage, and operate on data.

---
# **üìòWhy Collections are Required**
---

## **1Ô∏è‚É£ Limitations of Arrays**

* **Fixed Size:**

  * Once an array is created, its size **cannot change**.
  * To increase size:

    1. Create a new array of larger size.
    2. Copy existing elements into the new array.
    3. Make the original reference point to the new array.
    4. Optionally, discard the old array.

  Example:

  ```java
  int[] A = new int[5];  // original array
  int[] B = new int[10]; // new bigger array
  System.arraycopy(A, 0, B, 0, A.length);
  A = B;  // A now points to bigger array
  B = null;
  ```

* **Drawbacks:**

  * Programmer must handle resizing manually.
  * Cannot predict the number of elements coming at runtime.
  * Insertion/deletion in the middle of array requires shifting elements manually.

---

## **2Ô∏è‚É£ Why Arrays Are Not Always Suitable**

* Real-world applications often need **dynamic-sized collections**.
* Arrays are not flexible for:

  * Unknown size at runtime
  * Frequent insertion/deletion in the middle
  * Ensuring uniqueness of elements
  * Maintaining sorted order automatically

---

## **3Ô∏è‚É£ Collection Framework to the Rescue**

Java provides **built-in classes** under the **Collections Framework** to overcome array limitations:

### **Variable-size Collections**

* **ArrayList**

  * Dynamic resizing (auto-expands when more elements are added)
* **LinkedList**

  * Also allows dynamic insertion/deletion anywhere in the list

### **Distinct/Unique Elements**

* **Set**

  * Automatically prevents duplicate elements

### **Sorted & Unique**

* **SortedSet**

  * Ensures elements are unique **and** sorted automatically

---

## **4Ô∏è‚É£ Common Operations on Collections**

1. **Insertion**

   * Collections handle insertion automatically.
   * No need to manually shift elements like arrays.

2. **Deletion**

   * Collections handle deletion automatically.
   * No need to manually shift elements.

3. **Searching**

   * Collections provide built-in methods.
   * Methods can implement:

     * Linear Search
     * Binary Search
     * Hash-based search (key-value pair via Map classes)
   * Hashing provides **fast search** for large collections.

---

## **5Ô∏è‚É£ Key Takeaways**

* Arrays are simple but **limited in flexibility**.
* Collections Framework provides:

  * **Dynamic sizing** (ArrayList, LinkedList)
  * **Uniqueness** (Set)
  * **Sorting** (SortedSet)
  * **Efficient operations**: insert, delete, search, hash-based lookup
* Collections let the programmer **focus on using data**, not managing it.

---

# **üìòCollection Classes in Java**

---

## **1Ô∏è‚É£ Introduction to Collection Framework**

* **Collection Framework = Data Structures in Java**

  * Provided as **interfaces and classes**.
  * Organized in a **hierarchy**.
  * Classes implement interfaces to provide concrete functionality.

* **Shapes in hierarchy diagram:**

  * **Oval = Interface**
  * **Rectangle = Class**

* **Top-most interface:** `Iterable`

  * Has a single method: `iterator()`

* **Mother of all interfaces:** `Collection`

  * Represents a **group of objects** (homogeneous or heterogeneous).
  * Methods include:

    * Add object
    * Remove object
    * Search object
    * Check for object

---

## **2Ô∏è‚É£ List Interface (Ordered Collection)**

* **Definition:** Ordered collection of elements with **indexing**.

* **Features:**

  * Maintains order
  * Can have **duplicates**
  * Access elements by **index**

* **Classes implementing List:**

  * **ArrayList:** Dynamic array, widely used
  * **LinkedList:** Doubly-linked list structure
  * **Vector (Legacy):** Old dynamic array class
  * **Stack (Legacy):** Last-In-First-Out structure

* **Use Case:**

  * Insert/delete at specific positions easily
  * Maintain order of elements

---

## **3Ô∏è‚É£ Set Interface (Unordered, Unique Collection)**

* **Definition:** Unordered collection of **distinct elements** (no duplicates)

* **Features:**

  * Duplicates not allowed
  * No indexing (unordered)
  * Useful for **frequent search operations**

* **Classes implementing Set:**

  * **HashSet:** Uses hashing, unordered
  * **LinkedHashSet:** Maintains insertion order
  * **SortedSet (interface):** Elements are **sorted**

    * **TreeSet:** Implementation using tree data structure

---

## **4Ô∏è‚É£ Queue Interface (FIFO Collection)**

* **Definition:** Elements follow **First-In-First-Out (FIFO)** principle
* **Insertion:** At one end
* **Deletion:** From the other end
* **Class implementing Queue:**

  * **PriorityQueue:** Elements have priority order for processing

---

## **5Ô∏è‚É£ Deque Interface (Double-Ended Queue)**

* **Definition:** Insertion and deletion allowed at **both ends**
* **Class implementing Deque:**

  * **ArrayDeque:** Efficient double-ended queue

---

## **6Ô∏è‚É£ Map Interface (Key-Value Pair Storage)**

* **Definition:** Stores elements as **key-value pairs**
* **Use Case:** Search value by key efficiently
* **Classes implementing Map:**

  * **HashMap:** Unordered, uses hashing
  * **LinkedHashMap:** Maintains insertion order
  * **Hashtable (Legacy):** Old synchronized class
  * **SortedMap (interface):** Maintains sorted keys

    * **TreeMap:** Implementation using tree data structure

---

## **7Ô∏è‚É£ Key Points to Remember**

* **Interfaces define behavior**, classes provide implementation.

* **Collection interface** is the root of most interfaces (`List`, `Set`, `Queue`, `Deque`).

* **List:** Ordered, allows duplicates

* **Set:** Unordered, no duplicates

* **Queue:** FIFO

* **Deque:** Double-ended insertion/deletion

* **Map:** Key-value storage, separate hierarchy from Collection

* **Legacy Classes:** Vector, Stack, Hashtable ‚Äî old versions, rarely used now.

* Understanding the **interface** helps understand the **classes** implementing it.

---

# **üìòUnderstanding Collection Interface**

---

## **1Ô∏è‚É£ Collection Interface Overview**

* **Package:** `java.util`
* **Generic:** Supports objects of any class (`<E>` notation)
* **Represents:** A group of objects, parent interface for `List`, `Set`, `Queue`

---

## **2Ô∏è‚É£ Key Methods of Collection Interface**

| **Method**                          | **Description**                                          | **Example/Behavior**                                           |
| ----------------------------------- | -------------------------------------------------------- | -------------------------------------------------------------- |
| `add(E e)`                          | Adds a single element to the collection                  | Add `G` to `[A, B, C, D, E]` ‚Üí `[A, B, C, D, E, G]`            |
| `addAll(Collection<? extends E> c)` | Adds all elements from another collection                | `C1.addAll(C2)` adds all elements of `C2` into `C1`            |
| `remove(Object o)`                  | Removes a single element                                 | Removes `D` from collection if present, returns `true`/`false` |
| `removeAll(Collection<?> c)`        | Removes all elements present in another collection       | `C1.removeAll(C2)` removes common elements of `C2` from `C1`   |
| `retainAll(Collection<?> c)`        | Keeps only elements present in another collection        | `C1.retainAll(C2)` keeps common elements, removes others       |
| `clear()`                           | Removes all elements                                     | Collection becomes empty                                       |
| `isEmpty()`                         | Checks if collection is empty                            | Returns `true` if no elements                                  |
| `contains(Object o)`                | Checks if a specific element is present                  | Returns `true` if found                                        |
| `containsAll(Collection<?> c)`      | Checks if all elements of another collection are present | Returns `true` if all `C2` elements exist in `C1`              |
| `equals(Object o)`                  | Compares two collections for equality                    | True if both have same elements and size                       |
| `size()`                            | Returns number of elements                               | `C1.size()` returns count                                      |
| `iterator()`                        | Returns an `Iterator` to traverse elements               | Allows sequential access (`next()`, `hasNext()`)               |
| `toArray()`                         | Converts collection to array                             | Returns an array of collection elements                        |

---

## **3Ô∏è‚É£ Notes on Iterator**

* **Purpose:** Scans/traverses the collection, similar to **for-loop iteration on arrays**

* **Methods:**

  * `hasNext()` ‚Äì checks if more elements exist
  * `next()` ‚Äì retrieves the next element
  * `remove()` ‚Äì optionally remove the current element

* **Analogy:** `for (int i = 0; i < array.length; i++)` ‚Üí `Iterator` does the same for collections without indexes

---

## **4Ô∏è‚É£ Key Points**

* Collection interface **does not have objects**, only methods
* All collection classes (`ArrayList`, `HashSet`, etc.) **implement these methods**
* Understanding these methods gives you **most of the operations for all collection classes**
* `addAll`, `removeAll`, `retainAll` are **collection-to-collection operations**
* Iterators are essential for **traversing collections efficiently**

---

# **üìòUnderstanding List, Set Interface**

---

## **1Ô∏è‚É£ List Interface**

**Key Points:**

* **Extends:** `Collection`
* **Ordered:** Elements have indices
* **Duplicates:** Allowed
* **Extra Methods:** Related to index-based operations

**Important Methods:**

| **Method**                                     | **Description**                                                      | **Example**                       |
| ---------------------------------------------- | -------------------------------------------------------------------- | --------------------------------- |
| `add(E e)`                                     | Adds an element at the end                                           | `[A,B,C] ‚Üí add(D) ‚Üí [A,B,C,D]`    |
| `add(int index, E element)`                    | Inserts element at a specific index                                  | Insert `K` at index 2             |
| `addAll(Collection<? extends E> c)`            | Adds all elements from another collection at the end                 | `[A,B] addAll([C,D]) ‚Üí [A,B,C,D]` |
| `addAll(int index, Collection<? extends E> c)` | Adds all elements from another collection starting at specific index | Insert `[P,Q,R]` at index 2       |
| `remove(int index)`                            | Removes element at specific index                                    | Remove element at index 4         |
| `get(int index)`                               | Returns element at given index                                       | `get(2) ‚Üí C`                      |
| `set(int index, E element)`                    | Replaces element at given index                                      | Replace index 3 with `K`          |
| `subList(int fromIndex, int toIndex)`          | Returns part of the list (view)                                      | `subList(1,4)` ‚Üí `[B,C,D]`        |
| `indexOf(Object o)`                            | Returns first occurrence index of an object                          | `indexOf(C) ‚Üí 2`                  |
| `lastIndexOf(Object o)`                        | Returns last occurrence index of an object                           | Useful if duplicates exist        |
| `iterator()`                                   | Traverses elements forward                                           | Standard iteration                |
| `listIterator()`                               | Traverses elements forward & backward                                | Can start from a specific index   |

**Notes:**

* `add` vs `set`: `add` inserts (shifts elements), `set` replaces
* `listIterator` is bidirectional, unlike `iterator`

---

## **2Ô∏è‚É£ Set Interface**

**Key Points:**

* **Extends:** `Collection`
* **Unordered:** No indexing
* **Duplicates:** Not allowed (unique elements)
* **Extra Methods:** None
* **Methods:** Same as `Collection` interface

**Use Case:** Useful when uniqueness is required

---

## **3Ô∏è‚É£ Queue Interface**

**Key Points:**

* **Extends:** `Collection`
* **Mechanism:** FIFO (First In First Out)
* **Extra Methods:** Specific to queue operations

**Important Methods:**

| **Method**  | **Description**                          | **Behavior on Empty Queue**              |
| ----------- | ---------------------------------------- | ---------------------------------------- |
| `add(E e)`  | Adds element at the end                  | Throws exception if full (rarely used)   |
| `poll()`    | Removes and returns first element        | Returns `null` if empty                  |
| `remove()`  | Removes and returns first element        | Throws `NoSuchElementException` if empty |
| `peek()`    | Retrieves first element without removing | Returns `null` if empty                  |
| `element()` | Retrieves first element without removing | Throws `NoSuchElementException` if empty |

**Notes:**

* `poll` vs `remove`: Same action, different empty queue behavior
* `peek` vs `element`: Same action, different empty queue behavior

---

## **Summary Table for Interfaces**

| Interface  | Ordered | Duplicates  | Index-based Methods | Special Methods                                                                                           |
| ---------- | ------- | ----------- | ------------------- | --------------------------------------------------------------------------------------------------------- |
| Collection | No      | Allowed     | None                | add, addAll, remove, removeAll, retainAll, iterator, contains, containsAll, clear, isEmpty, size, toArray |
| List       | Yes     | Allowed     | Yes                 | get, set, add(index, E), addAll(index, Collection), subList, indexOf, lastIndexOf, listIterator           |
| Set        | No      | Not Allowed | None                | Same as Collection                                                                                        |
| Queue      | No      | Allowed     | No                  | poll, remove, peek, element                                                                               |

---

# **üìòVisiting Java Docs for Collections**

---

## **1Ô∏è‚É£ Using Java Documentation**

* Java provides **official documentation** for all packages, classes, interfaces, and methods.
* You can search for `Java <version> <package>` (e.g., `Java 13 util`) to get Oracle‚Äôs documentation.
* Documentation contains:

  * **Interfaces**: List of all interfaces in the package.
  * **Classes**: All classes in the package.
  * **Enums**: Enumerations.
  * **Exceptions**: Exceptions raised by classes.
* Each class or interface page contains:

  * **Description**
  * **Super interfaces**
  * **Subinterfaces**
  * **Known implementing classes**
  * **Methods and constructors**

---

## **2Ô∏è‚É£ Collection Interface**

* **Superinterface:** `Iterable`
* **Subinterfaces:** `List`, `Set`, `Queue`, etc.
* **Known Implementations:** `ArrayList`, `HashSet`, `LinkedList`, etc.
* **Methods:** `add()`, `addAll()`, `remove()`, `removeAll()`, `retainAll()`, `contains()`, `containsAll()`, `clear()`, `isEmpty()`, `size()`, `iterator()`, `toArray()`, etc.

---

## **3Ô∏è‚É£ List Interface**

* **Extends:** `Collection` ‚Üí inherits all Collection methods.
* **Implemented By:** `ArrayList`, `LinkedList`, `Vector`, `Stack`, etc.
* **Extra Methods:** Index-based methods like `get(int index)`, `set(int index, E element)`, `add(int index, E element)`, `addAll(int index, Collection c)`, `subList(int from, int to)`, `indexOf()`, `lastIndexOf()`, `listIterator()`.
* **Special Notes:** `ArrayList` implements `RandomAccess` for fast index-based access.

---

## **4Ô∏è‚É£ Set Interface**

* **Extends:** `Collection`
* **Implemented By:** `HashSet`, `LinkedHashSet`, `TreeSet`
* **Methods:** Same as Collection, no extra methods.
* **Properties:** Unordered, unique elements.

---

## **5Ô∏è‚É£ Queue Interface**

* **Extends:** `Collection`
* **Implemented By:** `LinkedList`, `PriorityQueue`
* **Extra Methods:** `offer()`, `peek()`, `poll()`, `remove()`, `element()`.
* **Purpose:** FIFO (First In First Out)
* **Notes:** `LinkedList` implements `Deque` as well, providing methods like `addFirst()`, `addLast()`, `peekFirst()`, `peekLast()`, `pollFirst()`, `pollLast()`, `pop()`, `push()`.

---

## **6Ô∏è‚É£ Example Classes**

| Class        | Implements                                                                      | Notes                                               |
| ------------ | ------------------------------------------------------------------------------- | --------------------------------------------------- |
| `ArrayList`  | `List`, `Collection`, `Iterable`, `RandomAccess`, `Serializable`, `Cloneable`   | Index-based access, dynamic array                   |
| `LinkedList` | `List`, `Deque`, `Queue`, `Collection`, `Iterable`, `Serializable`, `Cloneable` | Doubly-linked list, supports queue/deque operations |
| `HashSet`    | `Set`, `Collection`, `Iterable`, `Serializable`, `Cloneable`                    | Stores unique elements, unordered                   |

**Constructors:**

* Non-parameterized
* Initial capacity (and sometimes load factor for hash-based collections)
* Constructor accepting a collection

**Methods:** All methods from interfaces, plus class-specific operations.

---

## **7Ô∏è‚É£ Tips for Learning Collections**

1. Use **Oracle documentation** as the primary source of truth.
2. Focus on **interfaces first** (Collection, List, Set, Queue).
3. Learn **key implementing classes** (`ArrayList`, `LinkedList`, `HashSet`, etc.).
4. Explore methods for each class from docs (`add()`, `remove()`, `get()`, etc.).
5. Practice using **the right class in the right scenario**.

---

# **üìòArrayList and Iterator**

---

## **1Ô∏è‚É£ Creating an ArrayList**

```java
import java.util.ArrayList;
import java.util.List;

public class Demo {
  public static void main(String[] args) {
    List<Integer> al1 = new ArrayList<>(20); // Initial capacity 20
  }
}
```

* **Generic Class**: `ArrayList<Integer>` ensures only integers are stored.
* **Initial Capacity**: 20 ‚Üí array list can hold at least 20 elements initially, grows automatically as needed.

---

## **2Ô∏è‚É£ Adding Elements**

### **a) add(E element)**

```java
al1.add(10); // Adds 10 at the end
```

### **b) add(int index, E element)**

```java
al1.add(0, 5); // Inserts 5 at index 0, shifts 10 to index 1
```

### **c) addAll(Collection c)**

```java
List<Integer> al2 = List.of(50, 60, 70, 80, 90); // Static initialization
al1.addAll(al2); // Adds all elements at the end
```

### **d) addAll(int index, Collection c)**

```java
al1.addAll(1, al2); // Inserts all elements starting at index 1
```

---

## **3Ô∏è‚É£ Accessing Elements**

### **a) get(int index)**

```java
Integer val = al1.get(5); // Access element at index 5
```

### **b) indexOf(E element)**

```java
int idx = al1.indexOf(70); // Returns first occurrence index
```

### **c) lastIndexOf(E element)**

```java
int lastIdx = al1.lastIndexOf(70); // Returns last occurrence index
```

### **d) set(int index, E element)**

```java
al1.set(6, 100); // Replaces element at index 6 with 100
```

---

## **4Ô∏è‚É£ Removing Elements**

```java
al1.remove(3); // Remove element at index 3
al1.clear();   // Removes all elements
```

* **retainAll(Collection c)** ‚Üí Keep only elements present in another collection.
* **removeAll(Collection c)** ‚Üí Remove all elements present in another collection.

---

## **5Ô∏è‚É£ Checking Elements**

```java
al1.contains(50); // true if 50 is present
al1.equals(al2);  // checks if two lists are equal
```

---

## **6Ô∏è‚É£ Iterating through ArrayList**

### **a) Using for loop**

```java
for(int i = 0; i < al1.size(); i++) {
    System.out.println(al1.get(i));
}
```

### **b) Using for-each loop**

```java
for(Integer x : al1) {
  System.out.println(x);
}
```

### **c) Using Iterator**

```java
Iterator<Integer> it = al1.iterator();
while(it.hasNext()) {
  System.out.println(it.next());
}
```

### **d) Using ListIterator**

```java
ListIterator<Integer> li = al1.listIterator();
while(li.hasNext()) {
  System.out.println(li.next());
}
// ListIterator allows bidirectional iteration
```

### **e) Using forEach with Lambda**

```java
al1.forEach(n -> System.out.println(n));
```

### **f) Using Method Reference**

```java
al1.forEach(System.out::println);
```

### **g) Conditional Lambda**

```java
al1.forEach(n -> show(n));

static void show(int n) {
    if(n > 60) System.out.println(n);
}
```

* Only elements **greater than 60** are printed.
* Demonstrates combining **forEach** with a **custom method**.

---

## **7Ô∏è‚É£ Key Points**

* ArrayList allows **duplicate elements**.
* **Generic type** ensures type safety.
* Provides **dynamic resizing**.
* Can access elements by **index**.
* Iteration can be done using:

  * Traditional `for` loop
  * Enhanced `for-each` loop
  * `Iterator` or `ListIterator`
  * Lambda expressions or method references

---


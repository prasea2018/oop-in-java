#  **üìòWhat are Exceptions**

## **1. Learning Objectives**

After studying these notes, you will be able to:

- Understand different types of program errors: **syntax**, **logical**, and **runtime errors**.
- Distinguish which errors are faced by the **programmer** and which are faced by the **user**.
- Explain why runtime errors are also called **exceptions**.
- Identify the causes of runtime errors (bad input and missing resources).
- Understand how exception handling helps in managing runtime errors.
- Grasp the need for giving meaningful messages to users through exception-handling constructs.

## **2. Key Concepts (with short explanations)**

### **Syntax Error**

- Errors in typing, grammar, or structure of code.
- Detected by the **compiler** before program execution.

### **Logical Error**

- Code runs but produces incorrect or unexpected results.
- Difficult to detect; requires step-by-step tracing or a **debugger**.

### **Runtime Error (Exception)**

- Occurs during execution, usually due to user mistakes or missing resources.
- Causes program to crash if not handled.
- Examples: invalid input, missing files, no network, printer not working.

### **Exception Handling**

- Technique used by programmers to *manage- runtime errors.
- Provides meaningful messages to users instead of crashing the program.

---

## **3. Detailed Breakdown (Organized Explanation)**

## **A. Three Types of Errors**

### **1. Syntax Errors**

- Faced by: **Programmer**
- Cause: Typing mistakes or incorrect use of language rules.
- Examples:
```java 
int x, y; 
x = 10 
z = x + y;
```

  - Missing semicolon: `x = 10`
  - Using an undeclared variable: `z = x + y` when `z` is not declared.
  - Using a variable without initialization.
- Detected by: **Compiler**
- Behavior:
  - Compiler stops translation and shows the line number and message.

---

### **2. Logical Errors**

- Faced by: **Programmer**
- Cause: Incorrect logic or wrong implementation of formulas.
- Characteristics:

  - No syntax errors.
  - Program runs- but gives **wrong output**.
- Examples:

  - Incorrect formula:

    - Correct: `r = (-b) / (2 - a)`
    - Incorrect: `r = -b / 2 - a`
  - Array printing starting at index 1 instead of 0. `for(int i=1; i<A.length; i++)`
- Why difficult?

  - Compiler cannot detect logic.
  - Requires tracing or using a **debugger**.

---

### **3. Runtime Errors (Exceptions)**

- Faced by: **User**, not programmer.
- Cause: Program is correct but external conditions fail.
- Common causes:

  - **Bad input*- (negative age value).
  - **Unavailable resources*- (file missing, no internet, printer out of paper).
- Characteristics:

  - Program crashes or stops abruptly.
  - User cannot fix the program‚Äîonly *uses- it.

---

## **B. Why Runtime Errors Occur**

### Root causes:

1. **Bad Input**

   - User gives invalid values (negative age, incorrect data format).

2. **Unavailable Resources**

   - File not found.
   - No network connectivity.
   - No printer / no ink / no paper.

---

## **C. Why Runtime Errors Need Exception Handling**

### Without exception handling:

- Program crashes ‚Üí poor user experience.
- User receives no guidance.

### With exception handling:

- Program doesn‚Äôt crash.
- User sees helpful messages:

  - ‚ÄúAge cannot be negative.‚Äù
  - ‚ÄúFile not found. Please place the file in the correct location.‚Äù
  - ‚ÄúNetwork unavailable. Check your connection.‚Äù

---

## **D. Why They‚Äôre Called ‚ÄúExceptions‚Äù**

A programmer claims:

> ‚ÄúMy program works perfectly **except*- when the user provides bad input or resources are missing.‚Äù

These **exceptional cases** prevent the program from running normally.
Handling these exceptional cases = **exception handling**.

---

## **4. Summary**

- **Syntax errors**: Typing mistakes; caught by compiler; faced by programmer.
- **Logical errors**: Wrong logic; difficult to detect; program runs but gives wrong output; faced by programmer.
- **Runtime errors (exceptions)**: Occur due to user mistakes or missing resources; faced by user; cause program crash.
- **Exception handling**: Programmer writes code to handle runtime errors gracefully and inform users properly.

---

## **5. Practical Applications**

- Writing code that never crashes unexpectedly.
- Validating user input to prevent bad data.
- Checking for resource availability (files, network, devices).
- Using try‚Äìcatch blocks (or equivalent) to handle exceptions.
- Providing meaningful feedback to users for smoother program usage.

---

## **6. Self-Assessment Questions**

### **Conceptual**

1. What is the difference between syntax error and logical error?
2. Why can‚Äôt a user fix runtime errors?
3. What are the two main causes of runtime errors?
4. Why are runtime errors called ‚Äúexceptions‚Äù?

### **Applied**

5. Give an example of bad input that could cause a runtime error.
6. Write one real-world example where missing resources cause a program failure.
7. How would you explain exception handling to a beginner programmer?


#  **üìòHow to Handle Exception**

---

## **1. Learning Objectives**

By the end of this lesson, you will be able to:

- Understand what a **runtime error (exception)** is and why it occurs.
- Explain what happens when an exception is not handled.
- Use **try‚Äìcatch** to prevent program crashes.
- Write programs that continue executing even after errors occur.
- Handle specific exception types like:

  - `ArithmeticException`
  - `ArrayIndexOutOfBoundsException`
- Use **multiple catch blocks**, **nested try‚Äìcatch**, and the **finally block**.
- Understand rules about exception class hierarchy in multiple catch blocks.

---

## **2. Key Concepts (with clear explanations)**

### **Runtime Error / Exception**

- Happens **during execution** (not at compile-time).
- Caused by invalid operations (e.g., divide by zero, accessing invalid array index).
- If not handled ‚Üí program stops immediately.

### **try block**

- A block of code that may cause an exception.

### **catch block**

- Executes when an exception happens in the try block.
- Can specify which type of exception it handles.

### **ArithmeticException**

- Thrown when illegal arithmetic operations occur (e.g., division by zero).

### **ArrayIndexOutOfBoundsException**

- Thrown when you try to access an array index outside its valid range.

### **Multiple Catch Blocks**

- One try block can have multiple catch blocks for different types of exceptions.

### **Nested try‚Äìcatch**

- A try‚Äìcatch inside another try block.

### **finally block**

- Code that executes **always**, whether or not an exception occurs.
- Used for cleanup: closing files, releasing resources, disconnecting DB, etc.

---

## **3. Detailed Breakdown**

---

### **A. What Happens When an Exception Occurs?**

Example:

```java
int a = 5;
int b = 0;
int c = a / b;   // Division by zero
```

- In mathematics ‚Üí result is ‚àû
- In computers ‚Üí **infinity is undefined**, so Java throws an exception.
- The error: `java.lang.ArithmeticException: / by zero`
- Once exception occurs:

  - Java prints the error
  - Program **immediately exits main()**
  - Any lines after the exception are **not executed**

Example effect:

```
Exception in thread "main" java.lang.ArithmeticException: / by zero
Program stops here. Remaining statements never run.
```

---

### **B. Why We Need Exception Handling**

Goal:

- Even if an error occurs, the program shouldn't crash.
- The user should see a **meaningful message**.
- Program should continue gracefully.

Desired behavior:

- Skip the faulty calculation.
- Print custom error message.
- Continue with the rest of the program.

---

### **C. try‚Äìcatch Syntax and Example**

#### **Basic Syntax**

```java
try {
  // risky code
}
catch(ExceptionType e) {
  // handling code
}
```

#### **Division Example with try‚Äìcatch**

```java
try {
  int a = 5; 
  int b = 2;
  int c = a / b;
  System.out.println(c);
} catch(ArithmeticException e) {
  System.out.println("Division by zero error");
  System.out.println(e);
}
```

### **Execution Flow**

Case 1: **b = 0**

- Division causes `ArithmeticException`
- try ‚Üí exception ‚Üí skip remaining try lines ‚Üí go to catch
- catch prints:

  - Custom message
  - The exception object

Case 2: **b ‚â† 0**

- No exception
- Entire try block executes
- catch block is skipped

---

### **D. Multiple Catch Blocks**

Used when multiple types of exceptions may occur.

#### Example Code:

```java
try {
  int[] A = {10, 0, 5, 3, 8};
  int r = A[0] / A[1];     // could cause ArithmeticException
  System.out.println(r);

  System.out.println(A[10]);  // definitely causes ArrayIndexOutOfBoundsException
}
catch(ArithmeticException e) {
  System.out.println("Division by zero");
}
catch(ArrayIndexOutOfBoundsException e) {
  System.out.println("Array index out of bounds");
}
```

### Key Rule ‚Äì *Very Important*

Catch blocks must be ordered from **most specific ‚Üí most general**.

Example:

‚ùå INVALID:

```java
catch(Exception e)
catch(ArithmeticException e)
```

`Exception` is a **superclass**, it would catch everything first ‚Üí compiler error.

‚úî VALID:

```java
catch(ArithmeticException e)
catch(Exception e)
```

---

### **E. Nested try‚Äìcatch**

A try‚Äìcatch block **inside another try block**.

### Structure:

```java
try {
  int[] A = {10, 0, 5, 3, 8};  
  try {
    // something risky
    int r = A[0] / A[1];     // could cause ArithmeticException
    System.out.println(r);
  }
  catch(ArithmeticException e) {
    // handle inner exception
    System.out.println(e);
  }
  // outer risky code
    System.out.println(A[10]); 
}
catch(ArrayIndexOutOfBoundsException e) {
  // handle outer exception
  System.out.println(e);
}
```

Use case:

- When different parts of code require independent handling.

---

### **F. finally Block**

### Purpose

- Always executes:

  - Whether exception occurs or not.
  - Whether catch is executed or not.

#### Example:

```java
try {
  int c = a / b;
}
catch(ArithmeticException e) {
  System.out.println("Exception occurred");
}
finally {
  System.out.println("Finally always executes");
}
```

### Typical Uses:

- Closing files
- Releasing database connections
- Freeing memory buffers
- Resetting states

---

## **4. Visual Summary (Text Diagram)**

```
              +-----------------------+
              |        try block      |
              | (code that may fail)  |
              +-----------+-----------+
                          |
                    Exception?
                     /        \
                    / No       \ Yes
                   v            v
        +----------------+   +----------------+
        | Continue code  |   |  catch block   |
        | inside try     |   | handles error  |
        +----------------+   +----------------+
                                 |
                                 v
                     +-------------------------+
                     |     finally block       |
                     | always executes         |
                     +-------------------------+
```

---

## **5. Summary**

- Exceptions occur **during runtime**, not compile-time.
- Unhandled exceptions cause immediate program termination.
- `try‚Äìcatch` prevents crashes and enables graceful recovery.
- Multiple catch blocks handle multiple exception types.
- Exception classes have hierarchy; ordering of catch matters.
- Nested try‚Äìcatch gives fine-grained control.
- `finally` always executes and is useful for cleanup.

---

## **6. Practical Application**

Use exception handling when:

- Reading files (file may not exist)
- Network operations (connection failures)
- User input (invalid format)
- Arithmetic operations (divide by zero)
- Array operations (invalid index)

It helps:

- Keep software stable
- Provide better user experience
- Prevent unexpected crashes
- Ensure resources are always closed properly

---

## **7. Self-Assessment Questions**

### **Conceptual**

1. Why does a program stop immediately when an unhandled exception occurs?
2. What is the difference between `ArithmeticException` and `ArrayIndexOutOfBoundsException`?
3. Why must specific catch blocks come before general ones?
4. What is the purpose of the `finally` block?

### **Code Understanding**

5. What happens when the following code runs?

```java
int a = 10, b = 0;
try {
  System.out.println(a / b);
}
catch(Exception e) {
  System.out.println("Handled");
}
System.out.println("Done");
```

### **Applied**

6. Write a try‚Äìcatch example to handle file not found errors.
7. Where would you use nested try‚Äìcatch in a real application?

---

# **üìòTry and Catch Block**

---

## **1. Overview**

This lesson demonstrates:

- What happens when a **runtime exception*- occurs.
- How unhandled exceptions **stop program execution**.
- How to properly **handle exceptions using try‚Äìcatch**.
- How to display helpful messages instead of system errors.
- How to let the program **continue smoothly*- after an exception.
- How to read input using `Scanner` and handle exceptions in user-driven inputs.

---

## **2. What Happens When an Exception Occurs?**

### **Normal Execution**

```java
int a = 10, b = 2, c;
c = a / b;   // Output: 5
System.out.println(c);
System.out.println("bye");
```

Output:

```
5
bye
```

- No errors ‚Üí program runs completely.

---

### **When b = 0 (Division by Zero)**

- `a / b` becomes `10 / 0`
- Result is **infinity**, which is illegal in Java
- Java throws a **runtime exception**:

```
Exception in thread "main"
java.lang.ArithmeticException: / by zero
at ExceptionDemo.main(ExceptionDemo.java:9)
```

### Important Points:

- Java clearly reports:

  - Type of exception (`ArithmeticException`)
  - Line number where it occurred
- After exception:

  - Nothing after that line executes
  - `"bye"` is NOT printed
  - Program **crashes**

---

## **3. Understanding the Need for Exception Handling**

### Example Comparison (Chrome Analogy)

- If Chrome can't connect to the internet:

  - It shows a message (‚ÄúCheck your internet connection‚Äù)
  - It **does not crash**
  - You can still open tabs, menus, etc.

### Similarly, in Java:

- A program should:

  - Display a **meaningful message**
  - Continue executing remaining statements
  - Not terminate abruptly

---

## **4. Using try‚Äìcatch to Handle Exceptions**

### **Basic Structure**

```java
try {
  // risky statements
}
catch(ExceptionType e) {
  // handling code
}
```

---

### **Applying try‚Äìcatch to the Division Program**

#### Example:

```java
try {
  c = a / b; 
  System.out.println(c);
}
catch(ArithmeticException e) {
  System.out.println("Denominator should not be zero. Try again.");
}

System.out.println("bye");
```

### **Behavior**

Case 1: **Valid denominator**

```
Division result is shown
bye
```

Case 2: **b = 0**

```
Denominator should not be zero. Try again.
bye
```

### Key Point:

- Program **continues normally*- after catch
- No crash

---

## **5. Viewing the Exception Object**

You can print the exception object itself:

```java
catch(ArithmeticException e) {
  System.out.println(e);
}
```

Output:

```
java.lang.ArithmeticException: / by zero
```

- This is the actual message stored inside the exception object created by JVM.

---

## **6. Reading Input Using Scanner + Exception Handling**

### Adding Scanner

```java
Scanner sc = new Scanner(System.in);
System.out.println("Enter two numbers");
a = sc.nextInt();
b = sc.nextInt();
```

### Final Combined Example:

```java
Scanner sc = new Scanner(System.in);
System.out.println("Enter two numbers:");

a = sc.nextInt();
b = sc.nextInt();

try {
  c = a / b;
  System.out.println("Division is " + c);
}
catch(ArithmeticException e) {
  System.out.println("Denominator should not be zero. Try again.");
}

System.out.println("bye");
```

### Outputs

#### **Valid input**

```
Enter two numbers:
15
3
Division is 5
bye
```

#### **Invalid input**

```
Enter two numbers:
5
0
Denominator should not be zero. Try again.
bye
```

- Program becomes **robust**
- Continues execution despite invalid denominator

---

## **7. Why Exception Handling Matters**

- Prevents program crashes
- Displays **user-friendly messages**
- Allows remaining code to execute
- Makes applications behave predictably (like Chrome‚Äôs error message)

---

## **8. Final Summary**

- Division by zero causes `ArithmeticException`.
- Without exception handling ‚Üí program stops immediately.
- `try‚Äìcatch` allows you to:

  - Handle the problem
  - Give meaningful error messages
  - Continue execution
- The exception object (`e`) contains details about the error.
- Input using `Scanner` can be combined with exception handling for safer programs.

---

## **9. Practice Suggestions**

- Recreate the same program manually.
- Try different invalid inputs (zero, negative numbers).
- Print both custom messages and exception object messages.
- Add more processing after the division to see how the flow continues.


---

#  **üìòMultiple & Nested Try Catch**

---

## **1. Program Setup**

Example array used in the demo:

```java
int[] A = {30, 20, 10, 40, 0};
```

- Valid indices: `0‚Äì4`
- Note: `A[4] = 0` (used to trigger division-by-zero)

Two operations are executed:

1. Divide two elements of the array.
2. Print an array element (possibly invalid index).

---

## **2. Normal Execution**

### Example:

```java
c = A[0] / A[1];  // 30 / 20 ‚Üí 1 (integer division)
System.out.println("Division is " + c);

System.out.println(A[5]);  // invalid index ‚Üí exception
```

### Output:

```
Division is 1
java.lang.ArrayIndexOutOfBoundsException
```

- First statement works.
- Accessing `A[5]` throws `ArrayIndexOutOfBoundsException`.
- Nothing after the exception line executes.

---

## **3. When Division by Zero Occurs**

If we divide:

```java
A[0] / A[4]   // 30 / 0 ‚Üí ArithmeticException
```

- JVM throws:
  `java.lang.ArithmeticException: / by zero`
- Program stops immediately unless handled.

---

## **4. Using a Single try Block with Multiple catch Blocks**

### Syntax:

```java
try {
  // risky code
}
catch(ExceptionType1 e) { ... }
catch(ExceptionType2 e) { ... }
```

---

### **Example with Both Exceptions Handled**

```java
try {
  int c = A[0] / A[4];  // possible division by zero
  System.out.println("Division is " + c);

  System.out.println(A[5]);  // possible invalid index
}
catch(ArithmeticException e) {
  System.out.println("Denominator should not be zero");
}
catch(ArrayIndexOutOfBoundsException e) {
  System.out.println("Index is invalid");
}

System.out.println("bye");
```

---

### **Case 1: Division by zero**

Output:

```
Denominator should not be zero
bye
```

### **Case 2: Invalid array index**

Example change:

- Valid division: `A[0] / A[2] ‚Üí 3`
- Invalid index: `A[5]`

Output:

```
Division is 3
Index is invalid
bye
```

---

## **5. Important Rules for Multiple Catch Blocks**

- Only **one catch executes per exception**.
- Once an exception occurs inside the try block:

  - Remaining statements **inside the try** are skipped.
  - Control jumps to the matching catch block.
- You can have many catch blocks.
- Must respect **exception hierarchy** (e.g., `Exception` must not come before subclass exceptions).
  **This hierarchy rule is covered in a later lesson.**

---

## **6. Nested try‚Äìcatch (try inside another try)**

### Structure:

```java
try {                       // Outer try
  // Code that may throw ArithmeticException

  try {                   // Inner try
    // Code that may throw ArrayIndexOutOfBoundsException
  }
  catch(ArrayIndexOutOfBoundsException e) {
    System.out.println("Index is invalid");
  }
}
catch(ArithmeticException e) {
  System.out.println("Denominator should not be zero");
}
```

---

## **7. Example of Nested try‚Äìcatch**

```java
try {  
  int c = A[0] / A[4];   // division by zero ‚Üí handled by outer catch
  System.out.println("Division is " + c);

  try {
    System.out.println(A[5]);  // invalid index ‚Üí handled by inner catch
  }
  catch(ArrayIndexOutOfBoundsException e) {
    System.out.println("Index is invalid");
  }
}
catch(ArithmeticException e) {
  System.out.println("Denominator should not be zero");
}

System.out.println("bye");
```

---

### **Case 1: Division by zero occurs first**

- Outer try fails immediately.
- Inner try **never executes**.

Output:

```
Denominator should not be zero
bye
```

---

### **Case 2: Valid division, invalid inner index**

If division works (`A[0] / A[2] ‚Üí 3`):

Output:

```
Division is 3
Index is invalid
bye
```

---

## **8. Multiple Catch vs Nested Try‚ÄìCatch**

| Multiple catch blocks                      | Nested try‚Äìcatch                                            |
| ------------------------------------------ | ----------------------------------------------------------- |
| One try block, multiple catches            | try inside another try                                      |
| Good for grouping related risky statements | Good when inner logic has separate exception handling logic |
| Cleaner structure                          | More flexible but more complex                              |
| All exceptions handled after the same try  | Inner exception handled immediately                         |

Both methods are valid. Choice depends on **application design**.

---

## **9. Key Takeaways**

- You can handle different exceptions separately using multiple catch blocks.
- Nested try‚Äìcatch allows finer control over portions of code.
- As soon as an exception occurs inside a try block:

  - Remaining code inside that try does not execute.
- Always handle exceptions to keep the program **robust and crash-free**.
- `System.out.println("bye")` (or similar final statements) prove program completed normally.


---

# **üìòClass Exception**

---

## **1. Overview of Exceptions in Java**

- Java provides **many built-in exception classes**.
- These classes are used when runtime errors occur.
- You can:

  - **Use** built-in exception classes by writing try‚Äìcatch.
  - **Create** your own custom exception classes.

---

## **2. Exception Class Hierarchy**

```
Object  
 ‚îî‚îÄ‚îÄ Throwable  
        ‚îú‚îÄ‚îÄ Exception  
        ‚îî‚îÄ‚îÄ Error
```

### **Object**

- Topmost parent class in Java (superclass of all classes).

### **Throwable**

- Base class for **all exception and error objects**.

### **Error**

- Represents serious system-level issues handled by **JVM**.
- Not meant for normal application handling (e.g., `OutOfMemoryError`).

### **Exception**

- Parent class for all Java exceptions.
- Represents issues that applications can catch and handle.

---

## **3. Important Built-in Exception Classes**

### ‚úî **Checked Exceptions** (must handle)

- **ClassNotFoundException**

  - When JVM cannot find a class used in code.

- **IOException** (I/O operations)

  - Problems in reading/writing files.
  - **FileNotFoundException** is a common subclass.

- **InterruptedException**

  - Occurs in multithreading when a thread is unexpectedly interrupted.

- **NumberFormatException**

  - String cannot be converted to a number.

---

### ‚úî **RuntimeException (Unchecked)**

Parent: `RuntimeException`

Not mandatory to handle. Common subclasses:

- **ArithmeticException**
  Example: division by zero.

- **IndexOutOfBoundsException**

  - **ArrayIndexOutOfBoundsException**
  - **StringIndexOutOfBoundsException**

- **NullPointerException**
  Using a reference variable with no object assigned.

---

## **4. Checked vs Unchecked Exceptions**

| **Checked Exceptions**                                     | **Unchecked Exceptions**                                |
| ---------------------------------------------------------- | ------------------------------------------------------- |
| Must be handled using try‚Äìcatch OR declared using `throws` | Handling is optional                                    |
| Compiler enforces handling                                 | Compiler does NOT enforce handling                      |
| Examples: `IOException`, `InterruptedException`            | Examples: `ArithmeticException`, `NullPointerException` |

---

## **5. Multiple Catch Blocks & Exception Hierarchy**

Java allows:

```java
try { ... }
catch(SubclassException e) { ... }
catch(SuperclassException e) { ... }
```

### **Rule:**

- **Specific (subclass) catch blocks must come before general (superclass) blocks.**

### Example (correct):

```java
catch(ArithmeticException e) { ... }   // subclass
catch(Exception e) { ... }             // superclass
```

### Example (incorrect ‚Äî compile error):

```java
catch(Exception e) { ... }              // superclass first ‚Üí catches everything
catch(ArithmeticException e) { ... }    // unreachable ‚Üí ERROR
```

Reason:
If superclass comes first, the subclass block will **never*- execute.

---

## **6. Useful Methods of the Exception Class**

### ‚úî **1. getMessage()**

- Returns a short message about the exception.

```java
System.out.println(e.getMessage());
```

---

### ‚úî **2. toString()**

- Returns a detailed message with exception class name.
- Automatically called when printing an object.

```java
System.out.println(e);   // calls e.toString()
```

You do **not*- need to write `e.toString()` explicitly.

---

### ‚úî **3. printStackTrace()**

- Prints the sequence of method calls (stack trace) that led to the exception.
- Very useful for debugging.

Example program call chain:

```
main() ‚Üí method1() ‚Üí method2()
```

If exception raised in `method2()`, stack trace shows:

```
method2
method1
main
```

Usage:

```java
e.printStackTrace();
```

---

## **7. Creating User-Defined Exceptions**

You can define custom exceptions by extending `Exception`.

### ‚úî **Example: Minimum Balance Exception**

Requirement:
Minimum balance in a bank account must be **‚Çπ5000**.
If balance goes below this ‚Üí raise custom exception.

### Step 1: Define the custom class

```java
class MinBalanceException extends Exception {
  public String toString() {
    return "Minimum balance should be 5000. Try again with a smaller amount.";
  }
}
```

### Rules:

- Must extend `Exception` (or its subclasses).
- You can override:

  - `toString()`
  - `getMessage()`
    to give meaningful error messages.

---

## **8. Summary**

- Java exceptions follow a strict hierarchy.
- Use **checked exceptions*- when compiler enforces handling.
- **Unchecked/runtime exceptions*- are optional to handle.
- Maintain correct order in multiple catch blocks (subclass ‚Üí superclass).
- Exception class provides useful methods:

  - `getMessage()`
  - `toString()`
  - `printStackTrace()`
- Custom exceptions are created by extending `Exception`.

---


---

# **üìò Checked & Unchecked Exceptions**

## **1. Overview**

This lesson demonstrates:

- The difference between **checked** and **unchecked** exceptions
- How Java treats each type at compile time
- How stack tracing and exception methods work
- How to define and throw a **custom exception**

---

## **2. Program Structure (Used in Demonstration)**

A simple call-chain:

```
main() ‚Üí fun3() ‚Üí fun2() ‚Üí fun1()
```

The instructor uses this structure to show:

- How exceptions propagate up the call stack
- How stack trace displays the method-calling sequence

---

## **3. Unchecked Exceptions**

## **Definition**

- Exceptions **not checked by the compiler**.
- Java **does not force*- handling with `try-catch`.
- Program compiles even if such exceptions are possible.

Examples discussed:

- `ArithmeticException` (division by zero)
- `NullPointerException`
- `IndexOutOfBoundsException`
- All subclasses of `RuntimeException`

## **Demo: ArithmeticException**

```java 
public class CheckedUnchecked 
{
  static void fun1() {
    int res = 10/0;
  }
  static void fun2() { 
    fun1();
  }

  static void fun3() {
    fun2();
  } 
  public static void main(String[] args) {
    fun3();
  }
}
```

**Compiler behavior:**
‚úî Program compiles
‚úò No warning or error

**Runtime behavior:**

- Program crashes with `java.lang.ArithmeticException: / by zero`
- Stack trace shows:

  ```
  at fun1()
  at fun2()
  at fun3()
  at main()
  ```

---

## **4. Handling Unchecked Exceptions Manually**

The instructor wraps the code in `try-catch`:

```java

public class CheckedUnchecked 
{
  static void fun1() {
    try {
      int x = 10 / 0;
    } catch (Exception e) {
      System.out.println(e.getMessage());
      e.printStackTrace(); // optional
    }
  }
  static void fun2() { 
    fun1();
  }

  static void fun3() {
    fun2();
  } 
  public static void main(String[] args) {
    fun3();
  }
}

```

### **Important Exception Methods Demonstrated**

| Method              | What It Returns             |
| ------------------- | --------------------------- |
| `getMessage()`      | Only the error message      |
| `toString()`        | Exception type + message    |
| `printStackTrace()` | Full stack trace on console |

Note:

- Using just `System.out.println(e)` automatically calls `toString()`.
- IDE warns that the direct version of `printStackTrace()` is not recommended because it prints sensitive program details (better to log instead).

---

## **5. Sending Crash Reports / Logging**

- Applications often ask: *"Send crash report to developer?"*
- Exception details + stack trace are collected (often using `printStackTrace(PrintStream)`).
- Useful for debugging and fixing issues in production software.

---

## **6. Checked Exceptions**

### **Definition**

- Exceptions that **must*- be handled using:

  - `try-catch`, **or**
  - `throws` in method signature
- Compiler **forces*- you to handle them.

Examples:

- `IOException`
- `FileNotFoundException`
- `SQLException`
- `ClassNotFoundException`

### **Demo: FileInputStream**

```java
FileInputStream fi = new FileInputStream("my.txt");
```

**Compiler error:**

```
Unhandled exception: FileNotFoundException must be caught or declared to be thrown
```

Java forces handling:

### Option 1: try-catch

```java
static void fun1() {
  try {
    FileInputStream fi = new FileInputStream("my.txt");
  } catch (FileNotFoundException e) {
    e.printStackTrace();
  }
}
```

### Option 2: declare throws

```java
static void fun1() throws FileNotFoundException { 
  FileInputStream fi = new FileInputStream("my.txt");
}
```

---

## **7. User-Defined Exceptions**


### **Steps to define your own exception**

#### **1. Create a class extending `Exception`**

```java
class LowBalanceException extends Exception {
  public String toString() {
    return "Balance should not be less than ‚Çπ5000.";
  }
}
```

**Important:**

- Extending `Exception` makes it a **checked exception**.
- Extending `RuntimeException` makes it **unchecked**.

#### **2. Throwing the exception**

Inside `fun1()`:

```java
static void fun1()
{
  throw new LowBalanceException();
}
```

#### **3. Handling it**

```java
static void fun1()
{
  try{
    throw new LowBalanceException();
  } catch(LowBalanceException e) {
    System.out.println(e);
  }
}
```


**Output:**

```
Balance should not be less than ‚Çπ5000.
```

---

## **8. Summary Table: Checked vs Unchecked Exceptions**

| Aspect               | Checked Exceptions                       | Unchecked Exceptions                       |
| -------------------- | ---------------------------------------- | ------------------------------------------ |
| Checked by compiler? | ‚úî Yes                                    | ‚úò No                                       |
| Must handle?         | ‚úî Mandatory                              | ‚úò Optional                                 |
| Extends              | `Exception`                              | `RuntimeException`                         |
| Examples             | IOException, SQLException, ClassNotFound | ArithmeticException, NPE, IndexOutOfBounds |
| What if not handled? | Compile-time error                       | Runtime crash                              |

---

## **9. Key Takeaways**

- Java distinguishes exceptions based on **compiler enforcement**.
- Unchecked exceptions compile fine but cause runtime crashes.
- `printStackTrace()` provides debugging information on call sequence.
- Custom exceptions mimic real-world situations (like bank balance rules).
- Custom exceptions must **extend `Exception`** to be checked exceptions.


---

# **üìòThrow vs Throws**

---

## **1. Exception Propagation**

### **Concept**

Exception propagation is the process by which an exception moves **up the call stack** until it is handled.
If no method handles it, the exception reaches the JVM ‚Üí program crashes.

### **Example Call Chain**

```
main() ‚Üí method1() ‚Üí method2()
```
```java 
static void method2(int a, int b)
{
  int c = a / b; // b = 0 ‚Üí ArithmeticException
  return c;      // will NOT execute
}

static void method1()
{
  int r = method2(10,0);
  System.out.prinln(r)
}
public static void main(String[] args)
{
  method1();
}
```

### What Happens?

1. Exception occurs inside **method2**.
2. method2 has **no try-catch**, so the exception is passed to **method1**.
3. method1 also has **no try-catch**, so exception is passed to **main**.
4. main has **no try-catch**, so exception is passed to **JVM**.
5. JVM terminates the program with a stack trace.

### **Key Behavior**

- Java checks **each caller** to see whether it handles the exception.
- If none handle it ‚Üí crash.
- `printStackTrace()` helps trace the entire propagation sequence.

---

## **2. Throwing Exceptions Manually (`throw`)**

## **Use Case**

A method cannot complete its normal operation, so instead of returning a value, it ‚Äúsignals‚Äù failure by throwing an exception.

### **Example (Area of Rectangle)**

```
main ‚Üí method1 ‚Üí area()
```

### Original Behavior

`area()` returns `length - breadth`.

### But if input is invalid:

- Length or breadth cannot be negative.
- If invalid ‚Üí return is impossible ‚Üí throw an exception.

### **Code**

```java
static int area(int length, int breadth)
{
  if (length < 0 || breadth < 0) {
    throw new Exception("Length and breadth cannot be negative");
  }
  return length * breadth;
}

static void method1() 
{
  int a = area(-10, 5);
  System.out.println(a);
}

public static void main(String[] args)
{
  method1();
}
```

### **Important Points**

- `throw` is used **inside a method body**.
- It throws an **object** (typically `new Exception(message)`).
- Throwing an exception **stops the method** immediately.
- Any statements after `throw` will not execute.

---

## **3. The `throws` Keyword**

### **Why `throws` is Needed?**

- `Exception` is a **checked exception**.
- Any method that might throw a checked exception must **declare** it using `throws`.

### Example:

```java
static int area(int length, int breadth) throws Exception
{
  if (length < 0 || breadth < 0) {
    throw new Exception("Length and breadth cannot be negative");
  }
  return length * breadth;
}

static void method1() 
{
  int a = area(-10, 5);
  System.out.println(a);
}

public static void main(String[] args)
{
  method1();
}
```

### Purpose of `throws`

- Informs caller: ‚ÄúThis method may throw an exception. **You must handle it**.‚Äù

### Handling it in caller:

```java
static int area(int length, int breadth)
{
  if (length < 0 || breadth < 0) {
    throw new Exception("Length and breadth cannot be negative");
  }
  return length * breadth;
}

static void method1() 
{
  try {
    int a = area(-10, 5);
  } catch (Exception e) {
    System.out.println(e.getMessage());
  }
}

public static void main(String[] args)
{
  method1();
}
```

---

# **4. Difference Between `throw` and `throws`**

| Keyword    | Meaning                       | Used In          | Purpose                |
| ---------- | ----------------------------- | ---------------- | ---------------------- |
| **throw**  | Explicitly throw an exception | Inside a method  | Action keyword (verb)  |
| **throws** | Declare possible exceptions   | Method signature | Warning for the caller |

### Easy Memory Trick:

- **throw** = I throw the exception
- **throws** = Written on my head- ‚Äî ‚ÄúBe careful, I may throw exceptions‚Äù

---

## **5. Chaining `throws` Up the Call Stack**

If a method doesn‚Äôt want to handle the exception, it can forward it:

```java
static int area(int length, int breadth) throws Exception {
  if (length < 0 || breadth < 0) {
    throw new Exception("Length and breadth cannot be negative");
  }
  return length * breadth;
}

static void method1() throws Exception {
  int a = area(-10, 5);    
  System.out.println(a);
}

public static void main(String[] args) throws Exception {
  method1();
}
```

Eventually, if main doesn't handle the exception ‚Üí JVM catches ‚Üí crash.

Use this only when you want the **topmost level** to decide how to respond.

---

## **6. User-Defined Exceptions**

### **Why Create Custom Exceptions?**

- Built-in classes may not describe project-specific errors.
- Custom exceptions give clarity, e.g., `NegativeDimensionException`.

---

### **Steps to Create a Custom Exception**

#### **Step 1: Create Exception Class**

```java
class NegativeDimensionException extends Exception {
  public String toString() {
    return "Dimensions cannot be negative";
  }
}
```

Key rules:

- Must extend **Exception*- (for checked exception).
- Use a descriptive class name ending with ‚ÄúException‚Äù.
- Override `toString`() or provide a constructor to customize message.

---

#### **Step 2: Throw the Exception**

```java
if (length < 0 || breadth < 0) {
  throw new NegativeDimensionException();
}
```

---

#### **Step 3: Declare it in Method Signature**

```java
int area(int length, int breadth) throws NegativeDimensionException
```

---

### **Step 4: Handle it in Caller**

```java
try {
  int a = area(-5, 10);
} catch (NegativeDimensionException e) {
  System.out.println(e);
}
```

---

## **7. Key Takeaways**

### **Exception Propagation**

- Unhandled exception travels up call stack until someone catches it.

### **throw**

- Used to actually throw an exception object.
- Stops execution immediately.

### **throws**

- Declares exceptions a method may throw.
- Required for checked exceptions.

### **User-Defined Exceptions**

- Created by extending `Exception`.
- Improve readability and maintainability.


---

# **üìòDemo Throw and Throws**

## **1. Exception Propagation (How exceptions move through methods)**

### **Example Setup**

```java
static int meth1() { return 10 / 0; }
static void meth2() { meth1(); }
static void meth3() { meth2(); }

public static void main(String[] args) {
  meth3();
}
```

### **How Propagation Occurs**

- `meth1()` executes `10/0` ‚Üí **ArithmeticException** occurs.
- No try‚Äìcatch inside `meth1` ‚Üí exception goes to **meth2**.
- No try‚Äìcatch in **meth2*- ‚Üí exception goes to **meth3**.
- No try‚Äìcatch in **meth3*- ‚Üí exception goes to **main**.
- No handling in main ‚Üí exception goes to **JVM** ‚Üí program crashes.

### **Stack Trace Meaning**

The printed stack trace shows:

- **Where the exception originated** (method + line number)
- Each method in the chain that passed the exception upward.

Example trace order:

1. meth1 (origin)
2. meth2 (caller)
3. meth3 (caller)
4. main (caller)
5. JVM (program stops)

### **Handling the Exception**

You can catch it at any level:

```java
public static void main(String[] args) {
  try {
    meth3();
  } catch (Exception e) {
    System.out.println(e);
  }
}
```

Output:

```
java.lang.ArithmeticException: / by zero
```

---

## **2. throw and throws (Throwing your own exceptions)**

### **Area Calculation Example**

```java
static int area(int length, int breadth) {
  return length * breadth;
}

static int meth1() {
  return area(10, 5);
}
```

#### **Adding Validation**

If dimensions are negative ‚Üí method cannot calculate area.

#### **Using throw**

```java
if (length < 0 || breadth < 0) {
    throw new Exception("Dimensions cannot be negative");
}
```

#### **Compiler Error**

`Exception` is a **checked exception**, so Java requires:

- Either **handle** it with try-catch, OR
- **Declare** it with `throws`.

#### **Adding throws**

```java
static int area(int length, int breadth) throws Exception {
  if (length < 0 || breadth < 0) {
    throw new Exception("Dimensions cannot be negative");
  }
  return length * breadth;
}
```

Then caller must also add:

```java
static void meth1() throws Exception
{
  System.out.println("Area is " + area(-10,5));
}
```

And finally main:

```java
public static void main(String[] args) throws Exception
{
  meth1()
}
```

(or catch it in main)

#### **If no one catches it**

‚Üí JVM handles it ‚Üí program terminates with error.

#### **Handling the Exception**

```java
public static void main(String[] args) {
  try {
    meth1();
  } catch (Exception e) {
    System.out.println(e); 
  }
}
```

---

## **3. User-Defined Exception Class**

### **Defining Custom Exception**

```java
class NegativeDimensionException extends Exception {
  public String toString() {
    return "Dimensions of a rectangle cannot be negative";
  }
}
```

### **Throwing Custom Exception**

```java
if (length < 0 || breadth < 0) {
  throw new NegativeDimensionException();
}
```

### **Updating Method Signature**

```java
static int area(int length, int breadth) throws NegativeDimensionException
```

### **Catching the Custom Exception**

```java
try {
  meth1();
} catch (NegativeDimensionException e) {
  System.out.println(e);
}
```

### **Output**

```
Dimensions of a rectangle cannot be negative
```

If values are positive ‚Üí program prints area normally.

---

## **4. Key Concepts Summary**

### **Exception Propagation**

- Exceptions move upward along the call chain.
- If no method handles it ‚Üí JVM terminates the program.

### **throw**

- Actively ‚Äúthrows‚Äù an exception object.
- Used inside a method.
- Syntax:
  `throw new Exception("message");`

### **throws**

- Declares that a method may throw an exception.
- Added in method signature.
- Forces caller to handle or re-throw exception.

### **Custom Exceptions**

- Create your own exception class by extending `Exception`.
- Optionally override `toString()` or create constructors.
- Useful for domain-specific errors (e.g., negative dimension, invalid age, insufficient balance).


---

# **üìòJava Exception Handling ‚Äî finally Block Demonstration**

## **1. Purpose of finally**

- The `finally` block **always executes**, regardless of whether an exception occurs or not.
- Useful for **closing or releasing resources*- (files, connections, streams) even if an exception occurs.
- Can be used with:

  - `try` alone
  - `try` + `catch`
  - `try` + multiple `catch` blocks

---

## **2. Basic Example Without Exception**

```java
public static void main(String[] args) {
    int result = 10 / 5;
    System.out.println(result);  // Prints 2
    System.out.println("Final message");  // Prints final message
}
```

---

## **3. Basic Example With Exception**

```java
int result = 10 / 0; // ArithmeticException
System.out.println("Final message"); // Not printed
```

- Program crashes because exception occurs before the print statement.
- **Final message is not printed**.

---

## **4. Using finally Block**

```java
try {
    int result = 10 / 0;
} finally {
    System.out.println("Final message");  // Always executes
}
```

- **Even if exception occurs**, `finally` block runs before program terminates.

---

## **5. Using try, catch, and finally**

```java
try {
    int result = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println(e);
} finally {
    System.out.println("Final message");  // Always executes
}
```

- **Catch handles exception**
- **Finally executes regardless**
- Output:

```
java.lang.ArithmeticException: / by zero
Final message
```

---

## **6. Key Points**

- `finally` is **optional**.
- If **all exceptions are handled**, `finally` may not be necessary.
- If **exceptions are not fully handled** or method throws exceptions to caller ‚Üí use `finally` to execute critical code.

---

## **7. finally with a method that throws exception**

```java
static void meth1() throws Exception {
  try {
    throw new Exception("Exception occurred");
  } finally {
    System.out.println("Final message");  // Always executes
  }
}

public static void main(String[] args) throws Exception {
  meth1();  // Exception propagates to JVM
}
```

- **Even if the method throws an exception**, `finally` executes before control returns to the caller.
- If no `finally` ‚Üí statements after `throw` are **unreachable**.

---

## **8. Multiple catch blocks with finally**

```java
try {
  // Code that may throw multiple exceptions
} catch (IOException e) {
  // Handle IO exception
} catch (ArithmeticException e) {
  // Handle arithmetic exception
} finally {
  // Code that executes always
}
```

- `finally` executes after **any handled or unhandled exception**.
- Ensures **resource cleanup** or mandatory execution.

---

### **Summary**

- `finally` block **guarantees execution**.
- Use for:

  - Releasing resources
  - Printing final messages
  - Ensuring cleanup code runs
- Works with:

  - try-only
  - try-catch
  - multiple catch blocks
- Statements after `throw` are **unreachable** unless inside `finally`.

---


# **üìòTry with Resources**

## **1. What are Resources?**

- **Resources** are entities **external to the program** that the program uses:

  - Examples:

    - Heap : Every objects in Java is created in Heap (`new` objects)
    - Files (FileReader, FileWriter)
    - Network connections
    - Printers, keyboards, mouse, monitor, database connections
- **Program responsibility:**

  - **Acquire** resource when needed
  - **Release** resource when not needed
- Analogy: Borrowing a book from a library ‚Üí must return it when done.

---

## **2. Problem with Resource Management**

- Example: Reading a file

```java
FileReader f = new FileReader("my.txt");
f.read();      // using the file
f.close();     // release resource
```

- **Without proper handling:**

  - Exception occurs ‚Üí `f.close()` never executes
  - Resource stays **acquired** ‚Üí memory leak or file locked
- **Solution:** Use `finally` block to ensure cleanup.

---

## **3. Using finally for Cleanup**

```java
int method1() throws Exception
{
  FileReader f;
  try {
    f = new FileReader("my.txt");
    f.read();  // Using resource
    return 10;
  } finally {
    f.close(); // Always executes, ensures cleanup
  }
}
```

- **Behavior:**

  - **No exception:** `finally` executes before method returns.
  - **Exception occurs:** `finally` executes before exception is propagated.
- Ensures **resources are always released**, regardless of exception.

---

## **4. Try-with-Resources (Java 7+)**

- New feature in Java 1.7.
- Allows **automatic resource management** ‚Üí avoids manual `finally`.
- Syntax:

```java
int method1() throws Exception 
{
  try (FileReader f = new FileReader("my.txt")) {
    f.read();  // use the resource  
    return 10;
  }  // f is automatically closed here
}
```

- **Multiple resources:** Separate by semicolons

```java
try (Resource1 r1 = ...; Resource2 r2 = ...) {
  // use resources
}  // r1 and r2 automatically closed
```

- **No need for finally block** for closing resources.
- **Catch block optional:** Only if you want to handle exceptions

```java
try (FileReader f = new FileReader("my.txt")) {
  f.read();
} catch (IOException e) {
  e.printStackTrace();
}
```

---

## **5. Conditions for Try-with-Resources**

- Resource must implement **`AutoCloseable`** interface (e.g., `FileReader`, `Scanner`) for try to close automatically.
- `try` block **automatically calls `close()`** on resource at the end.

---

## **6. Summary**

- **Resources**: External entities used by program (heap, files, network, etc.)
- **Problem:*- Resources not released ‚Üí leaks, locked files
- **Solution 1:*- `finally` block ‚Üí manually close resources
- **Solution 2:*- **Try-with-Resources*- ‚Üí automatically closes resources, no finally needed
- Only works with **AutoCloseable resources**.

---

‚úÖ **Key Takeaways:**

1. Always **acquire and release** resources properly.
2. **finally** guarantees execution for cleanup.
3. **Try-with-Resources** simplifies code and prevents leaks.

---


# **Demo  Try with Resources**

## **1. Scenario**

- A text file `test.txt` contains numbers: `50 40 0 30 10`.
- Task:

  - Read numbers from the file.
  - Divide numbers and handle potential **division by zero** exceptions.
  - Manage file resources properly to avoid leaks.

---

## **2. Initial Approach**

- Using `FileInputStream` and `Scanner` to read the file.
- Divide first two numbers (`50 / 40`) ‚Üí works fine.
- Divide first and third number (`50 / 0`) ‚Üí **ArithmeticException** occurs.

```java 
public class ResourceDemo
{
  static FileInputStream fi; 
  static Scanner sc; 

  static void Divide() throws Exception 
  {
    fi = new FileInputStream("/Path2Test.txt");
    sc = new Scanner(fi);
    int a = sc.nextInt();
    int b = sc.nextInt();
    int c = sc.nextInt();
    //System.out.println(a/b);
    System.out.println(a/c);
    
    fi.close();
    sc.close();
  }

  public static void main(String[] args)
  {    
     try {
        Divide();
      } catch (Exception ex) {
        System.out.println(ex);
      }
    int x = sc.nextInt(); // Readd next from file
    System.out.println(x)
  }
}
```

**Problem Observed:**

- After an exception, `FileInputStream` and `Scanner` are **not closed**.
- Trying to access the next number in `main` may or may not work depending on whether resources were closed manually.

---

## **3. Using finally Block**

```java
public class ResourceDemo
{
  static FileInputStream fi; 
  static Scanner sc; 

  static void Divide() throws Exception 
  {
    fi = new FileInputStream("/Path2Test.txt");
    sc = new Scanner(fi);
    try {
      int a = sc.nextInt();
      int b = sc.nextInt();
      int c = sc.nextInt();
      //System.out.println(a/b);
      System.out.println(a/c);
    } finally {
      fi.close();
      sc.close();
    }    
  }

  public static void main(String[] args)
  {    
     try {
        Divide();
      } catch (Exception ex) {
        System.out.println(ex);
      }
    int x = sc.nextInt(); // Readd next from file
    System.out.println(x)
  }
}

```

- Ensures **resources are always closed**, even if an exception occurs.
- After finally executes:

  - Resources are released
  - Further reading from the file is **not possible** outside the try block.

---

## **4. Try-with-Resources Approach**

- Introduced in **Java 7** to simplify resource management.
- Syntax:

```java
try (
  FileInputStream fi = new FileInputStream("test.txt");
  Scanner sc = new Scanner(fi)
) {
  int a = sc.nextInt();
  int b = sc.nextInt();
  int c = sc.nextInt();
  System.out.println(a / c); // may throw ArithmeticException
}
```

- **Key Points:**

  - Resources declared in parentheses of `try` are **automatically closed** when the block ends.
  - No need for explicit `finally` block for closing resources.
  - Scope of resources is limited to the try block.
  - Can handle exceptions using `catch` if needed:

```java
catch(Exception e) {
  e.printStackTrace();
}
```

---

## **5. Advantages of Try-with-Resources**

1. **Automatic cleanup:** Resources are always closed.
2. **Simpler code:** No manual `finally` block needed.
3. **Scope limitation:** Resource objects cannot be used outside the try block, preventing misuse.
4. **Multiple resources:** Declare multiple resources separated by semicolons:

```java
try (Resource1 r1 = ...; Resource2 r2 = ...) { ... }
```

---

## **6. Example Observations**

- **Without closing resources:** Further reads from the file can still succeed but can cause undefined behavior.
- **With finally block:** Resources are reliably closed; further reads fail.
- **With try-with-resources:** Clean, automatic closure; simplifies code and prevents leaks.

---

‚úÖ **Key Takeaways**

- Always **acquire and release resources properly**.
- Use **finally** if you manage resources manually.
- Prefer **try-with-resources** for **AutoCloseable** resources (like `FileInputStream`, `Scanner`), as it guarantees closure and simplifies exception handling.

---


# **User-Defined Exceptions in Java: Stack Example**

## **1. Stack Basics**

- **Stack**: A data structure that works on **LIFO (Last In, First Out)** principle.
- **Implementation**: Can use a fixed-size array.
- **Top Pointer**:

  - Points to the top-most element in the stack.
  - `top = -1` ‚Üí stack is empty.
  - `top = size - 1` ‚Üí stack is full.
- **Operations**:

  - **Push**: Insert element ‚Üí increment `top` and store value.
  - **Pop**: Delete element ‚Üí retrieve value and decrement `top`.

---

## **2. Exceptional Situations**

1. **StackUnderFlow Exception**

   - Occurs when trying to **pop*- from an empty stack (`top = -1`).
2. **StackOverFlow Exception**

   - Occurs when trying to **push*- into a full stack (`top = size - 1`).

---

## **3. User-Defined Exception Classes**

### **StackOverFlow**

```java
class StackOverFlow extends Exception {
  public String toString() {
    return "Stack is Full";
  }
}
```

### **StackUnderFlow**

```java
class StackUnderFlow extends Exception {
  public String toString() {
    return "Stack is Empty";
  }
}
```

- Both **extend `Exception`**.
- Override `toString()` to provide descriptive messages.

---

## **4. Stack Class**

```java
class Stack {
  int top = -1;
  int size;
  int[] s;

  Stack(int size) {
    this.size = size;
    s = new int[size];
  }

  void push(int val) throws StackOverFlow {
    if(top == size - 1)
      throw new StackOverFlow();
    top++;
    s[top] = val;
  }

  int pop() throws StackUnderFlow {
    if(top == -1)
        throw new StackUnderFlow();
    int x = s[top];
    top--;
    return x;
  }
}
```

- **push**: Throws `StackOverFlow` if stack is full.
- **pop**: Throws `StackUnderFlow` if stack is empty.
- Uses **array and top pointer** to manage elements.

---

## **5. Testing in Main Method**

```java
public class StackDemo {
  public static void main(String[] args) {
    Stack st = new Stack(5);

    try {
      st.push(15);
      st.push(20);
      st.push(17);
      st.push(4);
      st.push(12);
      st.push(7);  // 6th element ‚Üí triggers exception
    } catch (StackOverFlow e) {
      System.out.println(e);
    }

    try {
      int val = st.pop();
      System.out.println(val);
    } catch (StackUnderFlow e) {
      System.out.println(e);
    }
  }
}
```

- **Push 6 elements** into a stack of size 5 ‚Üí triggers **StackOverFlow**.
- **Pop from empty stack** ‚Üí triggers **StackUnderFlow**.
- Exceptions are caught and **descriptive messages printed**.

---

## **6. Key Takeaways**

- **User-defined exceptions** help handle **custom error scenarios** in data structures or programs.
- Always **override `toString()`** to provide meaningful exception messages.
- **Try-catch** is necessary to handle these exceptions in main code.
- Stack operations must respect **size boundaries** to avoid overflow/underflow.


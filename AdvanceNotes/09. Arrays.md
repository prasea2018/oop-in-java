# üìò **Java Arrays ‚Äî Clean Notes & Explanation**

## **1. What is an Array?**

An **array** is a **collection of similar data elements**, stored in **contiguous (side-by-side)** memory locations.

### ‚úî Key properties

* All elements **must be of same data type**
  e.g., all `int`, all `double`, all `String`, etc.
* Elements are accessed using an **index**
* Index starts at **0**
* Length is **fixed** when the array is created

### Mathematical analogy

In math, if we write:
`X = {5, 8, 13, 89, 5, 8}`
We refer to:

* `X[0] = 5`
* `X[1] = 8`
* ‚Ä¶ etc.

Same concept applies in Java.

---

# üìå **2. Creating Arrays in Java**

## **Syntax 1: Declare + Allocate**

```java
int[] a;
a = new int[5];
```

### Memory picture:

```
Heap memory:
Index:  0  1  2  3  4
Value:  0  0  0  0  0   (default int values)
```

* Array is created in **heap memory**
* Variable `a` holds a **reference** to the array
* `a.length` gives **5**

---

## **Syntax 2: Declare + Allocate in one line**

```java
int[] a = new int[5];
```

---

## **Syntax 3: Declare + initialize values**

```java
int[] a = {1, 2, 3, 4, 5};
```

### Memory picture:

```
Index:  0  1  2  3  4
Value:  1  2  3  4  5
Length: 5
```

* You don't specify size ‚Äî Java counts elements automatically.

---

# üìå **3. Default Values**

When you create an empty array using `new`:

| Data Type | Default Value |
| --------- | ------------- |
| int       | 0             |
| double    | 0.0           |
| boolean   | false         |
| object    | null          |

---

# üìå **4. Accessing Elements**

## **Getting a value**

```java
System.out.println(a[0]);  // prints element at index 0
```

## **Setting a value**

```java
a[0] = 15;   // store 15 in first element
```

---

# üìå **5. Traversing Arrays (visiting all elements)**

There are two ways:

---

# ‚ñ∂ **A. Using Normal For Loop (classic loop)**

### Forward direction:

```java
for (int i = 0; i < a.length; i++) {
    System.out.println(a[i]);
}
```

### Reverse direction:

```java
for (int i = a.length - 1; i >= 0; i--) {
    System.out.println(a[i]);
}
```

### What does `i` represent?

* `i` is the **index**
* `a[i]` is the **value**

---

# ‚ñ∂ **B. Using For-Each Loop (Enhanced for loop)**

Introduced in Java 5 (1.5).

### Syntax:

```java
for (int x : a) {
    System.out.println(x);
}
```

### Meaning:

* "For each **value** `x` in array `a`, print `x`."

### Important Differences:

| Classic For Loop                        | For-Each Loop                          |
| --------------------------------------- | -------------------------------------- |
| Uses **index**                          | Uses **value**                         |
| You can access `i`, go forward/backward | Only forward                           |
| You can modify array values             | Cannot modify original values directly |
| More flexible                           | More readable & simpler                |

---

## üîé **Comparison Example**

### Classic:

```
i ‚Üí 0 1 2 3 4
a[i] ‚Üí 2 4 6 8 10
```

### For-each:

```
x ‚Üí 2 4 6 8 10  (values directly)
```

---

# üìå Summary (Easy Revision)

* Arrays store **similar type** elements in contiguous memory.
* They have a fixed length: accessed by `array.length`
* Index starts at 0
* Two main traversal methods:

  * **for loop** (index-based)
  * **for-each loop** (value-based)
* Arrays are **objects stored in heap memory**
* The array variable contains a **reference** to the object.

---


# üìò **Java Arrays ‚Äî Practising 1D Array**

## 1. **Declaring and Creating Arrays**

### **Method 1: Declaration + Allocation**

```java
int[] A;           // declare reference
A = new int[10];   // create array of size 10
```

* `A` is a **reference variable**.
* `new int[10]` creates an **array object in heap memory**.
* The array has **10 elements**, all initialized to `0`.

### **Method 2: Declaration + Initialization (with values)**

```java
int[] B = {1, 2, 3, 4, 5};
```

* No need to mention size.
* Size is automatically determined ‚Üí **5 elements**.

### **Method 3: Declare first, assign later**

```java
int[] C;
C = new int[10];
```

Same as Method 1 but split into two steps.

---

## 2. **Alternative syntaxes (All valid)**

### Square brackets after data type:

```java
int A[] = new int[5];
```

### Square brackets after reference:

```java
int A[];  
A = new int[5];
```

> ‚úî In Java, you may put `[]` after the data type **or** after the variable name.
> ‚úî Both are valid.

---

# 3. **Accessing and Modifying Array Elements**

Given:

```java
int[] B = {1, 2, 3, 4, 5};
```

### Get value:

```java
int x = B[2];   // x = 3
```

### Change value:

```java
B[2] = 15;      // replaces 3 with 15
```

Index positions:

```
Index:   0  1   2  3  4
Value:   1  2  15  4  5
```

---

# 4. **Displaying Array Elements**

## A. **Using Counter-Controlled For Loop (Classic Loop)**

```java
for (int i = 0; i < B.length; i++) {
    System.out.println(B[i]);
}
```

‚úî Uses **index**
‚úî Can **modify elements**
‚úî Can traverse forward/backward

---

## B. **Using For-Each Loop (Enhanced Loop)**

```java
for (int x : B) {
    System.out.println(x);
}
```

‚úî Directly gives **elements**
‚úî Cannot modify array values
‚úî Cannot access index
‚úî Only forward traversal

### Important Note

Changing `x` does **NOT** change the array.

Example:

```java
for (int x : B) {
    x++;
}
```

Array remains the same.

---

# 5. **Modifying Array Elements Using Classic Loop**

```java
for (int i = 0; i < B.length; i++) {
    B[i] = B[i] + 1;  // increments each element
}
```

This **will** update the actual array.

---

# 6. **Trying to Print the Whole Array Directly**

```java
System.out.println(B);
```

Output:

```
[I@4617c264
```

Explanation:

* `[ I` ‚Üí indicates **array of int**
* `@4617c264` ‚Üí hash code / memory reference

### Why doesn‚Äôt Java print all elements?

Because arrays do not override `toString()` method.

To print elements, you must:

* use loop, OR
* use `Arrays.toString(B)` (from `java.util.Arrays`)

---

# 7. **Printing Length of Array**

```java
System.out.println(B.length);
```

Output:

```
5
```

---

# 8. **Key Takeaways**

### ‚úî Arrays are objects stored in **heap memory**

### ‚úî An array variable is a **reference**

### ‚úî Default values for int array = **0**

### ‚úî To display all elements ‚Üí use **for loop** or **for-each loop**

### ‚úî for-each cannot modify the actual array

### ‚úî Classic for-loop can modify array elements

### ‚úî Printing the array directly prints a **reference**, not values

---



# ‚úÖ **1. Traversing (Scanning) an Array**

Traversing an array simply means **visiting all elements one-by-one**.

Two ways:

### **(A) Normal for loop**

```java
for(int i = 0; i < a.length; i++) {
    // a[i] gives element
}
```

* `i` = index
* `a[i]` = element at that index

### **(B) For-each loop**

```java
for(int x : a) {
    // x is the element itself
}
```

* You get elements directly
* No index available

---

# ‚úÖ **2. Finding the Sum of All Elements**

### **Logic**

1. Take `sum = 0`
2. Traverse each element
3. Add to `sum`
4. Print final result

### **Code**

```java
int[] a = {3, 9, 7, 8, 12, 6, 15, 5, 4, 10};
int sum = 0;

for(int x : a) {
    sum = sum + x;
}

System.out.println("Sum = " + sum);
```

---

# ‚úÖ **3. Searching an Element (Linear Search)**

Rules:

* Check each element one-by-one
* If found ‚Üí print index and stop the program
* If loop finishes and still not found ‚Üí print "Not Found"

### **Code**

```java
Scanner sc = new Scanner(System.in);

int[] a = {3, 9, 7, 8, 12, 6, 15, 5, 4, 10};
System.out.print("Enter key: ");
int key = sc.nextInt();

for(int i = 0; i < a.length; i++) {
    if(a[i] == key) {
        System.out.println("Element found at index " + i);
        return;   // Stop program
    }
}

System.out.println("Not Found");
```

---

# ‚úÖ **4. Finding the Maximum Element**

### **Logic**

1. Assume first element is max
2. Compare every element
3. If element > max ‚Üí update max

### **Code**

```java
int[] a = {3, 9, 7, 8, 12, 6, 15, 5, 4, 10};
int max = a[0];

for(int x : a) {
    if(x > max) {
        max = x;
    }
}

System.out.println("Maximum = " + max);
```

---

# ‚úÖ **5. Finding the Second Largest Element**

This is where students get confused.
We maintain:

* `max1` = largest
* `max2` = second largest

### **Logic**

For each number:

1. If number > max1:

   * max2 = max1
   * max1 = number
2. Else if number > max2:

   * max2 = number

### **Code**

```java
int[] a = {3, 9, 7, 8, 12, 6, 15, 5, 4, 10};

int max1 = a[0];
int max2 = a[0];

for(int x : a) {
    if(x > max1) {
        max2 = max1;
        max1 = x;
    }
    else if(x > max2) {
        max2 = x;
    }
}

System.out.println("Second Largest = " + max2);
```

For the given array ‚Üí **Second largest is 12**

---

# ‚úÖ **Final Summary**

| Task       | Logic                 | Loop                           |
| ---------- | --------------------- | ------------------------------ |
| Sum        | Add each element      | for / foreach                  |
| Search     | Compare each element  | **for** (because index needed) |
| Max        | Keep updating largest | for / foreach                  |
| Second Max | Maintain max1 & max2  | for / foreach                  |

---

# üìò Lecture Notes: Array Rotation, Insertion & Deletion

(Complete, Cleaned, and Organized)

## ‚≠ê Learning Objectives

By the end of this lesson, you should be able to:

* Understand **left** and **right rotation** of arrays.
* Implement **array rotation** using loops.
* Perform **insertion** of a value at a given index in an array.
* Perform **deletion** of a value from a given index in an array.
* Understand shifting logic‚Äîthe basis of all three operations.

---

# 1. ARRAY ROTATION

Array rotation means shifting all elements in the array by one position, either **left** or **right**.

---

## üîµ 1.1 Left Rotation

**Definition:**
In a *left rotation*, every element moves **one position to the left**, and the first element moves to the last position.

### Example

Given array:
`[5, 9, 6, 10, 12, 7, 3, 8, 4, 2]`

Left rotate once ‚Üí
`[9, 6, 10, 12, 7, 3, 8, 4, 2, 5]`

### How it works:

1. Store first element in temporary variable: `temp = a[0]`.
2. Shift elements left:

   * `a[0] = a[1]`
   * `a[1] = a[2]`
   * ‚Ä¶ until `a[n-2] = a[n-1]`
3. Move `temp` to the last index:

   * `a[n-1] = temp`

### Pseudocode

```java
int temp = a[0];
for (int i = 1; i < a.length; i++) {
    a[i-1] = a[i];
}
a[a.length - 1] = temp;
```

---

## üîµ 1.2 Right Rotation

**Definition:**
In a *right rotation*, every element moves **one position to the right**, and the last element moves to the first position.

### Example

Given array:
`[5, 9, 6, 10, 12, 7]`

Right rotate once ‚Üí
`[7, 5, 9, 6, 10, 12]`

### How it works:

1. Store last element in a temporary variable: `temp = a[n-1]`.
2. Shift elements right:

   * `a[n-1] = a[n-2]`
   * `a[n-2] = a[n-3]`
   * ‚Ä¶ until `a[1] = a[0]`
3. Place the temp at first position:

   * `a[0] = temp`

### Pseudocode

```java
int temp = a[a.length-1];
for (int i = a.length - 1; i > 0; i--) {
    a[i] = a[i-1];
}
a[0] = temp;
```

---

# 2. INSERTION IN AN ARRAY

### Goal

Insert a new value **at a specified index**.

### Important:

* There must be **free space** in the array (i.e., unused indexes).
* Shifting is required to open space for the new element.

### Example

Array (size 10, 6 valid elements):

```
Index: 0  1  2  3  4  5  . . .
Value: 5  9  6 10 12  7
```

Insert **15** at index **2** ‚Üí
**Result:** `[5, 9, 15, 6, 10, 12, 7]`

### How insertion works:

1. Start from the **last filled index** (`n-1`).
2. Shift each element one step to the right:

   * `a[i] = a[i-1]`
3. Stop when you reach the index where insertion is needed.
4. Place the new value at that index.

### Pseudocode

```java
for (int i = n; i > index; i--) {
    a[i] = a[i-1];
}
a[index] = x;
n++;
```

---

# 3. DELETION FROM AN ARRAY

### Goal

Remove an element from a given index.

‚ö† **Important Note From the Lecture:**
Arrays cannot physically ‚Äúdelete‚Äù a slot. The index still exists, but we treat that position as overwritten by shifting elements.

### Example

Original:
`[5, 9, 6, 10, 12, 7]`

Delete index **1** (value 9):

Steps:

* Remove 9 logically.
* Shift everything left:

  * `a[1] = a[2]`
  * `a[2] = a[3]`
  * ...

Result:
`[5, 6, 10, 12, 7]`

### Pseudocode

```java
for (int i = index; i < n-1; i++) {
    a[i] = a[i+1];
}
n--; // reduce valid element count
```

---

# 4. WHY WE LEARN THIS?

In Java, built-in classes like `ArrayList` automatically do these operations.
But internally, **they use the same shifting logic**:

* Rotation = shifting in one direction.
* Insertion = shift right + place new value.
* Deletion = shift left + reduce size.

Understanding this gives you:
‚úî strong logic-building
‚úî better debugging skills
‚úî deeper understanding of data structures

---

# 5. Quick Summary Table

| Operation      | What Moves?             | Direction | Temp Needed?        |
| -------------- | ----------------------- | --------- | ------------------- |
| Left Rotation  | All elements            | Left      | Yes (first element) |
| Right Rotation | All elements            | Right     | Yes (last element)  |
| Insertion      | Elements from index‚Üíend | Right     | No                  |
| Deletion       | Elements from index‚Üíend | Left      | No                  |

---

# 6. Practice Questions

### 1. Left Rotation

Rotate the array `[1, 2, 3, 4, 5]` two times left.
Answer: ?

### 2. Right Rotation

Right rotate `[10, 20, 30, 40, 50]` three times.
Answer: ?

### 3. Insertion

Insert 99 at index 3 in: `[5, 8, 12, 15, 20]`.

### 4. Deletion

Delete index 2 from: `[7, 14, 21, 28, 35]`.

I can check your answers if you want.

---


# **Array Operations in Java: Copying, Reversing & Increasing Size**

In this lesson, we learn three important array-handling tasks in Java:

1. Copying one array into another
2. Reverse-copying an array
3. Increasing the size of an array by creating a new one

---

# **1. Copying an Array**

### **Problem**

You have:

```
A = [10 elements]
B = [empty array of same size]
```

Goal: Copy all elements from `A` into `B` index-by-index.

### **Concept**

To copy arrays:

* Traverse array `A` from left to right.
* Assign each element to corresponding index in `B`.

### **Code Structure**

```java
int[] A = { ‚Ä¶values‚Ä¶ };
int[] B = new int[A.length];

for (int i = 0; i < A.length; i++) {
    B[i] = A[i];
}
```

### **Explanation**

* `i` starts at `0`
* `A[i]` is copied to `B[i]`
* Loop continues until the end of array

---

# **2. Reverse Copying an Array**

### **Problem**

Given:

```
A = [1, 2, 3, 4, 5]
B = [empty]
```

Goal: Copy elements from `A` into `B` **in reverse order**.

### **Idea**

* Traverse array `A` from right to left.
* Traverse array `B` from left to right.

### **Index Logic**

```
i = A.length - 1     // starts at last index of A
j = 0                // starts at first index of B
```

### **Code Structure**

```java
int[] A = { ‚Ä¶values‚Ä¶ };
int[] B = new int[A.length];

int i = A.length - 1; // rightmost index in A
int j = 0;            // leftmost index in B

while (i >= 0) {
    B[j] = A[i];
    i--;   // move backwards in A
    j++;   // move forward in B
}
```

### **Explanation**

* First element in `B` becomes last element of `A`
* Continue until `i` becomes `‚àí1`

---

# **3. Increasing the Size of an Array**

### **Problem**

Arrays in Java have **fixed size**.
If you have:

```
A = [8, 6, 10, 9, 2]   // size = 5
```

You **cannot** increase its size directly.

### **Solution**

Create a **new bigger array**, copy everything into it, and make your reference point to the new array.

### **Steps**

1. Create bigger array `B`
   e.g., double the size:

   ```java
   int[] B = new int[A.length * 2];
   ```
2. Copy elements from `A` ‚Üí `B`
3. Make `A` refer to `B`
4. Set `B` to `null` (optional)

### **Code Structure**

```java
int[] A = {8, 6, 10, 9, 2};

int[] B = new int[A.length * 2];

// Copy elements
for (int i = 0; i < A.length; i++) {
    B[i] = A[i];
}

// Point A to new array
A = B;

// Optional: allow old array to be garbage collected
B = null;

// Now A.length is doubled
System.out.println(A.length); // prints 10
```

### **Explanation**

* Old array becomes unreachable ‚Üí garbage collector removes it.
* `A` now points to a larger array with all original values preserved.

---

# **Summary Table**

| Task                    | How To Do It                           | Key Points                        |
| ----------------------- | -------------------------------------- | --------------------------------- |
| **Copy array**          | Loop from `0` ‚Üí `length-1`             | Simple assignment                 |
| **Reverse-copy array**  | Use two index variables (`i--`, `j++`) | Left ‚Üí Right and Right ‚Üí Left     |
| **Increase array size** | Create new array, copy, reassign       | Arrays cannot be resized directly |

---

# **üìò Two-Dimensional Arrays (2D Arrays) in Java**

A **2D array** represents data in **rows and columns**, similar to:

* a **matrix**
* a **table**
* a **grid**

Example conceptually:

```
[ 1   2   3   4 ]
[ 2   4   6   8 ]
[ 3   5   7   9 ]
```

Java treats a 2D array as an:

# üëâ **‚ÄúArray of Arrays‚Äù**

That means a 2D array is NOT one big block ‚Äî it is:

* an array where **each element is itself an array**
* rows can even have different sizes (jagged arrays)

---

# **1Ô∏è‚É£ Creating a 2D Array (Regular/Matrix)**

### **Syntax**

```java
int[][] a = new int[3][4];
```

This creates:

* **3 rows**
* **4 columns**

### **Memory Structure**

```
a ‚Üí [ ref0 | ref1 | ref2 ]      // array of references

ref0 ‚Üí [0][1][2][3]
ref1 ‚Üí [0][1][2][3]
ref2 ‚Üí [0][1][2][3]
```

Everything except the reference variable is created in the **heap**.

---

# **2Ô∏è‚É£ Creating & Initializing a 2D Array (Shortcut Method)**

### **Direct init**

```java
int[][] a = {
    {1, 2, 3, 4},
    {2, 4, 6, 8},
    {3, 5, 7, 9}
};
```

This creates:

* 3 rows
* 4 columns in each row
* all elements initialized automatically

---

# **3Ô∏è‚É£ Creating a 2D Array in Two Steps**

```java
int[][] a;               // reference only
a = new int[3][4];       // create 2D array later
```

This is useful when:

* size is decided at runtime
* array is declared before initialized

---

# **4Ô∏è‚É£ Accessing & Printing 2D Arrays Using Nested Loops**

A 2D array needs:

* **outer loop ‚Üí rows**
* **inner loop ‚Üí columns**

### **Using normal for-loops**

```java
for (int i = 0; i < a.length; i++) {             // rows
    for (int j = 0; j < a[i].length; j++) {      // columns
        System.out.print(a[i][j] + " ");
    }
    System.out.println(); // new line after each row
}
```

### Why `a.length`?

* gives **number of rows**

Why `a[i].length`?

* gives **number of columns in row i**

---

# **5Ô∏è‚É£ Accessing a 2D Array Using For-Each Loop**

Remember:

* Outer loop gives **each row array**
* Inner loop gives **elements inside that row**

### **Syntax**

```java
for (int[] row : a) {         // row is 1D array
    for (int val : row) {     // individual values
        System.out.print(val + " ");
    }
    System.out.println();
}
```

### Important Point

The outer loop variable is **int[]**, not `int`, because each element of a 2D array is an **array of integers**, not an integer.

---

# **6Ô∏è‚É£ Jagged Arrays (Ragged Arrays)**

A **jagged array** is a 2D array where each row has a **different number of columns**:

Example shape:

```
[ * * ]
[ * * * * ]
[ * * * ]
```

### **How to Create**

Step 1: Create main array with row count only

```java
int[][] a = new int[3][];
```

Step 2: Create each row separately

```java
a[0] = new int[2];   // row 1 ‚Üí 2 columns
a[1] = new int[4];   // row 2 ‚Üí 4 columns
a[2] = new int[3];   // row 3 ‚Üí 3 columns
```

Memory:

```
a ‚Üí [ ref0 | ref1 | ref2 ]

ref0 ‚Üí [ _ _ ]
ref1 ‚Üí [ _ _ _ _ ]
ref2 ‚Üí [ _ _ _ ]
```

### Why Jagged Arrays?

* Flexibility
* Saves memory
* Used when rows have different lengths (e.g., triangle data, seating arrangement, etc.)

---

# **7Ô∏è‚É£ Summary Table**

| Topic              | Explanation                     |
| ------------------ | ------------------------------- |
| 2D array structure | Array of arrays                 |
| Create             | `int[][] a = new int[r][c];`    |
| Initialize         | Use `{ {..}, {..} }`            |
| Access             | Nested loops                    |
| For-each           | `int[] row : a`                 |
| Jagged arrays      | Rows can have different lengths |
| Memory             | Stored in heap                  |

---


# **üìò Two-Dimensional Arrays (2D Arrays) in Java ‚Äì Complete Explanation**

A **two-dimensional array** is an array of arrays.
It represents data in **rows and columns**, like a matrix.

---

# **1Ô∏è‚É£ Declaring 2D Arrays**

### **Standard Declaration**

```java
int[][] a = new int[5][5];   // 5 rows, 5 columns
```

This creates a 5√ó5 matrix.

---

# **2Ô∏è‚É£ Initializing a 2D Array (Static Initialization)**

```java
int[][] b = {
    {1, 2, 3},
    {2, 4, 6},
    {1, 3, 5}
};
```

Here:

* 3 rows
* each row has 3 elements
  ‚Üí This is a **3√ó3 matrix**.

---

# **3Ô∏è‚É£ Declaring First, Creating Later**

```java
int[][] c;
c = new int[3][4];   // create the object later
```

---

# **4Ô∏è‚É£ Placement of Square Brackets**

All are valid in Java:

```java
int[][] a;       // preferred
int a[][];       // valid but old style
int[] a[];       // also valid
```

Important rule:

* **Square brackets after the data type apply to all variables.**
* **Square brackets after the variable name apply only to that variable.**

### Example:

```java
int[] e, f;      // both e and f are 1D arrays
int e[], f[][];  // e = 1D, f = 2D
```

---

# **5Ô∏è‚É£ Common Mistake**

```java
int e[5];    // ‚ùå ERROR ‚Äî size cannot be given at declaration like C/C++
```

Java requires:

```java
int[] e = new int[5];  // ‚úî correct
```

---

# **6Ô∏è‚É£ Printing a 2D Array Using Nested For-Loops**

```java
for (int i = 0; i < b.length; i++) {           // rows
    for (int j = 0; j < b[i].length; j++) {    // columns
        System.out.print(b[i][j] + " ");
    }
    System.out.println();                      // next line after each row
}
```

### Output:

```
1 2 3
2 4 6
1 3 5
```

---

# **7Ô∏è‚É£ Accessing a 2D Array Using For-Each Loop**

```java
for (int[] row : b) {           // each row is a 1D array
    for (int value : row) {     // each element in row
        System.out.print(value + " ");
    }
    System.out.println();
}
```

Works the same as nested for-loops.

---

# **8Ô∏è‚É£ Printing the Array Reference**

```java
System.out.println(b);
```

Output will be something like:

```
[[I@1a2b3c4d
```

This DOES NOT print array elements.
It prints:

* `[[` ‚Üí 2D array
* `I` ‚Üí type = int
* `@...` ‚Üí memory hash code

---

# **9Ô∏è‚É£ Jagged Arrays (Ragged Arrays)**

A **jagged array** has rows of different lengths.

### Create jagged array:

```java
int[][] a = new int[3][];  // only rows created

a[0] = new int[5];         // row 0 ‚Üí 5 elements
a[1] = new int[3];         // row 1 ‚Üí 3 elements
a[2] = new int[8];         // row 2 ‚Üí 8 elements
```

Jagged means:
Row 0 size ‚â† Row 1 size ‚â† Row 2 size

---

# **üîü Printing a Jagged Array (Nested Loops)**

```java
for (int i = 0; i < a.length; i++) {
    for (int j = 0; j < a[i].length; j++) {
        System.out.print(a[i][j] + " ");
    }
    System.out.println();
}
```

This works because:

```java
a[i].length
```

gives each row's actual size.

---

# **1Ô∏è‚É£1Ô∏è‚É£ Printing Jagged Array Using For-Each Loop**

```java
for (int[] row : a) {
    for (int value : row) {
        System.out.print(value + " ");
    }
    System.out.println();
}
```

---

# **1Ô∏è‚É£2Ô∏è‚É£ Summary (Easy Table)**

| Concept               | Explanation               |
| --------------------- | ------------------------- |
| 2D array              | Array of arrays           |
| Declaration           | `int[][] a;`              |
| Creation              | `new int[r][c]`           |
| Static initialization | `{ {1,2}, {3,4} }`        |
| Bracket placement     | changes meaning           |
| For-loop traversal    | row loop + column loop    |
| For-each traversal    | `int[] row : arr`         |
| Jagged array          | rows have different sizes |
| Printing reference    | prints `[[I@hashcode`     |

---



# **üìò Java Learning Notes ‚Äî Abstract Classes, 2D Arrays, Matrix Addition & Multiplication, String Sorting**

## **1. Abstract Classes ‚Äî Rules, Do‚Äôs and Don'ts**

### **1.1 Key Rules About Abstract Classes**

1. **If a class contains an abstract method, the class must be declared abstract.**

   ```java
   abstract class Shape { ... }
   ```

2. **You can declare references of an abstract class, but you cannot create objects of it.**
   ‚ùå Not allowed:

   ```java
   Shape s = new Shape();  // Error
   ```

   ‚úÖ Allowed:

   ```java
   Shape s;  // Reference only
   ```

3. **An abstract class cannot be declared `final`.**

   * `final` means *no subclassing*
   * `abstract` requires *subclasses to implement abstract methods*
     ‚Üí Both conflict.

4. **An abstract class cannot be `static`.**

   * Static classes exist only inside other classes
   * They cannot be abstract because they are not meant for polymorphic inheritance

5. **An abstract method cannot be `final`.**

   * `final` prevents overriding
   * Abstract methods **must** be overridden
     ‚Üí Conflict.

6. **An abstract method cannot be `static`.**

   * `static` methods belong to the class
   * But abstract methods require implementation in subclasses

### **1.2 Rules for Subclasses**

If a subclass extends an abstract class:

* It **must override all abstract methods**, OR
* The subclass itself must be declared **abstract**

Example:

```java
abstract class A {
    abstract void display();
}

class B extends A {
    @Override
    void display() {   // Must override
        System.out.println("Display");
    }
}
```

---

# **2. Two-Dimensional Arrays (2D Arrays)**

A 2D array is like a matrix:
Rows ‚Üí outer loop
Columns ‚Üí inner loop

Example 3√ó3 matrix:

```java
int[][] A = {
    {3, 5, 9},
    {7, 2, 1},
    {4, 6, 8}
};
```

---

# **3. Matrix Addition (3√ó3 Example)**

### **Rule:**

Two matrices can be added only if they have **the same dimensions**.

### **Formula:**

```
C[i][j] = A[i][j] + B[i][j]
```

### **Program Logic**

* Use **nested loops** to visit each element
* Add corresponding elements from A and B

### **Program (cleaned version)**

```java
int[][] A = {
    {3, 5, 9},
    {7, 2, 1},
    {4, 6, 8}
};

int[][] B = {
    {1, 5, 2},
    {6, 3, 7},
    {4, 2, 9}
};

int[][] C = new int[3][3];

for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        C[i][j] = A[i][j] + B[i][j];
    }
}

// Print
for (int[] row : C) {
    for (int val : row) {
        System.out.print(val + " ");
    }
    System.out.println();
}
```

---

# **4. Matrix Multiplication**

### **Rules for Multiplying Two Matrices**

Matrices **A (m √ó n)** and **B (n √ó p)** can be multiplied **only if**:

```
Number of columns in A == Number of rows in B
```

### **Resulting matrix:**

```
C is m √ó p
```

### **Formula**

```
C[i][j] = (A[i][0] * B[0][j]) +
          (A[i][1] * B[1][j]) +
          (A[i][2] * B[2][j]) + ...
```

### **Requires 3 loops**

* Loop `i` ‚Üí rows of A
* Loop `j` ‚Üí columns of B
* Loop `k` ‚Üí multiplies elements

### **Clean Program**

```java
int[][] A = {
    {3, 5, 9},
    {7, 2, 1},
    {4, 6, 8}
};

// Identity matrix (for easy checking)
int[][] B = {
    {1, 0, 0},
    {0, 1, 0},
    {0, 0, 1}
};

int[][] C = new int[3][3];

for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        C[i][j] = 0;   // Initialize accumulator
        for (int k = 0; k < 3; k++) {
            C[i][j] += A[i][k] * B[k][j];
        }
    }
}

for (int[] row : C) {
    for (int val : row) {
        System.out.print(val + " ");
    }
    System.out.println();
}
```

---

# **5. Sorting an Array of Strings**

Given:

```java
String[] langs = { "Java", "C", "Python", "BASIC" };
```

We want alphabetical order:

```
BASIC
C
Java
Python
```

### **Java has built-in sorting**

Using **Arrays.sort()** from `java.util`.

```java
import java.util.Arrays;

String[] langs = { "Java", "C", "Python", "BASIC" };

Arrays.sort(langs);

for (String lang : langs) {
    System.out.println(lang);
}
```

Java sorts strings lexicographically (dictionary order).

---

# **üìå Summary**

### ‚úî Abstract Classes

* Must be declared abstract
* Cannot be final or static
* Abstract methods cannot be final/static
* Subclasses must override abstract methods

### ‚úî Matrix Addition

* Dimensions must match
* Uses **2 loops**

### ‚úî Matrix Multiplication

* Columns(A) == Rows(B)
* Uses **3 loops**
* Formula uses summation over `k`

### ‚úî Sorting Strings

* Use `Arrays.sort()`

---

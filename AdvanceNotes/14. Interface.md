# **What are Interfaces**

After studying this segment, learners will be able to:

1. Define what an **interface** is in Java
2. Understand the **difference between abstract classes and interfaces**
3. Explain how interfaces help achieve **polymorphism**
4. Use the correct **syntax** for defining and implementing interfaces
5. Understand how interfaces provide a workaround for **multiple inheritance**

---

# **Key Concepts**

### **1. Interface Definition**

* An **interface** is a special type of abstract class in Java where **all methods are abstract by default**.
* Interfaces are used **purely for polymorphism**—they do not provide implementation.
* Key points:

  * Methods are implicitly `public` and `abstract`
  * Interfaces cannot have concrete method implementations (except with default or static methods in modern Java)

---

### **2. Abstract Class vs Interface**

| Feature                   | Abstract Class                             | Interface                                                          |
| ------------------------- | ------------------------------------------ | ------------------------------------------------------------------ |
| Can have concrete methods | ✅ Yes                                      | ❌ Traditionally no (default/static methods allowed in modern Java) |
| Purpose                   | Share implementation, provide polymorphism | Achieve polymorphism only                                          |
| Keywords                  | `abstract class`                           | `interface`                                                        |
| Inheritance               | `extends`                                  | `implements`                                                       |
| Can implement multiple    | ❌ Only one superclass                      | ✅ Multiple interfaces                                              |

**Conceptual analogy:**

* Abstract class = partially defined template; can give code and rules
* Interface = pure contract; only rules, no code

---

### **3. Syntax**

**Abstract class example:**

```java
abstract class Test1 {
  abstract void method1();
  abstract void method2();
}

class Test2 extends Test1 {
  @Override
  void method1() { System.out.println("Method 1 implemented"); }

  @Override
  void method2() { System.out.println("Method 2 implemented"); }
}
```

**Interface equivalent:**

```java
interface Test1 {
  void method1(); // public & abstract by default
  void method2();
}

class Test2 implements Test1 {
  @Override
  public void method1() { System.out.println("Method 1 implemented"); }

  @Override
  public void method2() { System.out.println("Method 2 implemented"); }
}
```

**Key differences in syntax:**

* Abstract class: `extends` keyword
* Interface: `implements` keyword
* Interface methods are implicitly `public` and `abstract`

---

### **4. Polymorphism with Interfaces**

* You can use a **reference of the interface** to point to an object of a class implementing it:

```java
Test1 obj = new Test2(); // Test1 is interface, Test2 implements it
obj.method1(); // Calls implementation in Test2
```

* This is similar to using a **superclass reference** for a subclass object.

---

### **5. Multiple Inheritance in Java**

* **Java does not allow multiple inheritance for classes** (`class A extends B, C` ❌)
* **Java allows a class to implement multiple interfaces**

```java
interface A { void methodA(); }
interface B { void methodB(); }

class C implements A, B {
  public void methodA() { System.out.println("A"); }
  public void methodB() { System.out.println("B"); }
}
```

* This is how Java **achieves multiple inheritance safely** using interfaces.

---

# **Summary**

1. Interfaces are like abstract classes with **all abstract methods**.
2. Interfaces are used for **polymorphism and defining contracts**.
3. Use `implements` keyword for a class to adopt an interface.
4. Interfaces allow a class to **implement multiple contracts**, solving the multiple inheritance problem in Java.

---

# **Practical Example Exercise**

1. Define an interface `Vehicle` with methods `startEngine()` and `stopEngine()`.
2. Create two classes `Car` and `Bike` that implement the `Vehicle` interface.
3. Use interface reference to call the methods of `Car` and `Bike`.
4. Try implementing **two interfaces** in a single class to see multiple inheritance in action.

---

# **Self-Assessment Questions**

1. How is an interface different from an abstract class?
2. Why does Java allow multiple interfaces but not multiple classes?
3. What is the default access modifier for methods in an interface?
4. How does using an interface reference help achieve polymorphism?
5. Can an interface have concrete methods? Under what circumstances?

---


# **Java Interface Demonstration – Key Concepts**

### **1. Interface Definition**

```java
interface Test {
  void method1();
  void method2();
}
```

* All methods in an interface are **implicitly public and abstract**.
* You **cannot create an object** of an interface:

```java
Test t = new Test(); // ❌ Error: Test is abstract; cannot be instantiated
```

* You **can create a reference** of the interface type:

```java
Test t; // ✅ Allowed
```

---

### **2. Implementing an Interface**

* Classes **implement** interfaces, they do not extend them:

```java
class MyClass implements Test { ... }
```

* If a class **does not implement all interface methods**, it becomes abstract:

```java
class MyClass implements Test {
    @Override
    public void method1() { System.out.println("Method 1"); }
    // method2 not implemented -> MyClass is abstract
}
```

* To make it concrete, **all interface methods must be implemented**.

---

### **3. Complete Implementation Example**

```java
class MyClass implements Test {
    @Override
    public void method1() { System.out.println("Method 1 of MyClass"); }

    @Override
    public void method2() { System.out.println("Method 2 of MyClass"); }

    // Extra methods can be added
    public void method3() { System.out.println("Method 3 of MyClass"); }
}
```

---

### **4. Using Interface Reference**

* You **can assign an object** of the implementing class to an interface reference:

```java
Test t = new MyClass();  // Allowed
t.method1();  // Calls method1 of MyClass
t.method2();  // Calls method2 of MyClass
// t.method3(); ❌ Error: interface type does not know about method3
```

* The **methods called** are **based on the actual object type**, not the reference type.

  * This is called **dynamic method dispatch** (runtime polymorphism).

---

### **5. Key Takeaways**

1. **Interfaces cannot be instantiated**, but references are allowed.
2. **Classes implement interfaces**, not extend them.
3. **All interface methods must be overridden** for a class to be concrete.
4. Extra methods in the implementing class are **not visible** through the interface reference.
5. Using an interface reference to call methods achieves **runtime polymorphism**.

---

### **6. Conceptual Analogy**

* Interface = a **contract or standard**
* Implementing class = a **concrete realization** of that contract
* Interface reference = a **superclass reference** pointing to the implementing object

---

---

# **Smartphone Example – Classes & Interfaces in Java**

### **1. Class and Interfaces Definition**

#### **Base Class: Phone**

```java
class Phone {
    void call() { System.out.println("Calling..."); }
    void sms() { System.out.println("Sending SMS..."); }
}
```

* Concrete class (`Phone`) – can create objects.
* Provides basic functionality (call, SMS).

#### **Interfaces: Camera & MusicPlayer**

```java
interface Camera {
  void click();
  void record();
}

interface MusicPlayer {
  void play();
  void pause();
  void stop();
}
```

* All methods are **implicitly public and abstract**.
* **Cannot create objects** of interfaces.
* A class can **implement multiple interfaces**.

---

### **2. Smartphone Class**

```java
class Smartphone extends Phone implements Camera, MusicPlayer {
  void videoCall() { System.out.println("Video Calling..."); }

  // Camera interface methods
  @Override
  public void click() { }
  @Override
  public void record() { }

  // MusicPlayer interface methods
  @Override
  public void play() { }
  @Override
  public void pause() { }
  @Override
  public void stop() { }
}
```

* **Extends one class** (`Phone`) – inherits call and sms methods.
* **Implements multiple interfaces** (`Camera` and `MusicPlayer`) – must override all interface methods.
* Adds **extra functionality**: `videoCall()`.

---

### **3. Creating Objects & References**

```java
Smartphone s = new Smartphone(); // Concrete object
Phone p = s;                      // Phone reference
Camera c = s;                     // Camera reference
MusicPlayer m = s;                // MusicPlayer reference
```

---

### **4. Calling Methods Using References**

| Reference         | Methods accessible                                                     | Notes                    |
| ----------------- | ---------------------------------------------------------------------- | ------------------------ |
| `s` (Smartphone)  | call(), sms(), videoCall(), click(), record(), play(), pause(), stop() | Full access              |
| `p` (Phone)       | call(), sms()                                                          | Only Phone methods       |
| `c` (Camera)      | click(), record()                                                      | Only Camera methods      |
| `m` (MusicPlayer) | play(), pause(), stop()                                                | Only MusicPlayer methods |

* **Key idea**: **Reference type determines what methods are visible**, object type determines **which implementation is executed**.
* This is **runtime polymorphism / dynamic method dispatch**.

---

### **5. Conceptual Analogy**

* **Phone class** → basic functionality
* **Camera interface** → camera features
* **MusicPlayer interface** → music features
* **Smartphone class** → a complete device combining all features

**Example scenario:**

* Friend wants to take a photo:

```java
Camera c = s; // Only camera methods available
c.click();    // ✅ Allowed
c.play();     // ❌ Not allowed
```

* Friend wants to play music:

```java
MusicPlayer m = s;
m.play();     // ✅ Allowed
m.videoCall(); // ❌ Not allowed
```

---

✅ **Takeaways from this Example**

1. A class can **extend only one class** but **implement multiple interfaces**.
2. Interface references **limit access** to only interface methods.
3. **Dynamic method dispatch** is achieved through interfaces and polymorphic references.
4. Interfaces are used to **achieve multiple inheritance behavior** in Java.

---

Here’s a **structured summary of your Smartphone interface demonstration** with key points for clarity:

---

# **Java Interfaces & Classes – Smartphone Example**

### **1. Classes and Interfaces**

```java
class Phone {
    void call() { System.out.println("Phone calling..."); }
    void sms() { System.out.println("Phone sending SMS..."); }
}

interface ICamera {
    void click();
    void record();
}

interface IMusicPlayer {
    void play();
    void stop();
}
```

* `Phone` → Concrete class with call & sms methods.
* `ICamera` & `IMusicPlayer` → Interfaces with abstract methods.
* Interfaces cannot have objects; all methods are abstract by default.

---

### **2. Smartphone Class**

```java
class Smartphone extends Phone implements ICamera, IMusicPlayer {
  void videoCall() { System.out.println("Smartphone video calling..."); }

  // Camera methods
  public void click() { System.out.println("Smartphone clicking photo..."); }
  public void record() { System.out.println("Smartphone recording video..."); }

  // MusicPlayer methods
  public void play() { System.out.println("Smartphone playing music..."); }
  public void stop() { System.out.println("Smartphone stopping music..."); }
}
```

* **Extends** `Phone` → inherits call & sms methods.
* **Implements** `ICamera` & `IMusicPlayer` → must override all interface methods.
* Adds extra feature → `videoCall()`.

---

### **3. Creating Objects & References**

```java
Smartphone s = new Smartphone();   // Full access
Phone p = s;                        // Phone reference
ICamera c = s;                       // Camera reference
IMusicPlayer m = s;                  // MusicPlayer reference
```

---

### **4. Calling Methods Using References**

| Reference Type     | Methods Accessible                                            | Notes                       |
| ------------------ | ------------------------------------------------------------- | --------------------------- |
| `s` (Smartphone)   | call(), sms(), videoCall(), click(), record(), play(), stop() | Full access to all features |
| `p` (Phone)        | call(), sms()                                                 | Can only use Phone methods  |
| `c` (ICamera)      | click(), record()                                             | Only camera features        |
| `m` (IMusicPlayer) | play(), stop()                                                | Only music player features  |

* **Key concept:** The **reference type determines which methods are visible**.
* **Object type determines which implementation is executed** → **runtime polymorphism / dynamic method dispatch**.

---

### **5. Real-Life Analogy**

* Object `s` → actual smartphone in hand.
* Reference `p` → treating it like a basic phone.
* Reference `c` → treating it like a camera only.
* Reference `m` → treating it like a music player.

> This demonstrates the flexibility of **interfaces and polymorphism** in Java.

---

✅ **Takeaways**

1. A class can **extend one class** and **implement multiple interfaces**.
2. Interface references **limit access to interface methods** only.
3. Dynamic method dispatch allows **runtime polymorphism** using interfaces and references.
4. This example mirrors **real-life object usage** in a smartphone scenario.

---


# **Java Callback Using Interface – Store & Customer Example**

### **1. Interface – `Member`**

```java
interface Member {
    void callback();  // Callback method
}
```

* Any customer who is a member must **implement this interface**.
* Ensures **callback method exists** to notify members.

---

### **2. Customer Class**

```java
class Customer implements Member {
    private String name;

    Customer(String name) {
        this.name = name;
    }

    @Override
    public void callback() {
        System.out.println("I will visit, " + name);
    }
}
```

* Implements `Member` interface → must override `callback()`.
* Stores the **customer name** and prints it when notified.

---

### **3. Store Class**

```java
class Store {
    private Member[] members;
    private int count;

    Store(int capacity) {
        members = new Member[capacity];  // Limit number of members
        count = 0;
    }

    void register(Member m) {
        if (count < members.length) {
            members[count++] = m;
        }
    }

    void inviteSale() {
        for (int i = 0; i < count; i++) {
            members[i].callback();  // Call each member's callback
        }
    }
}
```

* Maintains **list of members** (`Member[]`).
* `register()` → adds a member to the store.
* `inviteSale()` → **calls callback() for all members**, notifying them.

---

### **4. Main Application**

```java
public class StoreApp {
    public static void main(String[] args) {
        Store store = new Store(100);  // Store with max 100 members

        Customer c1 = new Customer("John");
        Customer c2 = new Customer("Smith");

        // Register members
        store.register(c1);
        store.register(c2);

        // Notify members about sale
        store.inviteSale();
    }
}
```

**Expected Output:**

```
I will visit, John
I will visit, Smith
```

---

### **Key Points**

1. **Interface `Member`** ensures all customers implement `callback()`.
2. **Store holds references** of `Member` interface → can call `callback()` on any customer object.
3. **Dynamic dispatch**: The `callback()` of the actual customer object is invoked at runtime.
4. **Callback mechanism** is commonly used in **event handling**, **GUI programming**, and **listener patterns** in Java.

---


# **Java Interfaces – Rules, Do’s & Don’ts**

### **1. Methods in Interfaces**

* **By default**:

  * Methods are **`public`** and **`abstract`**.
  * No need to explicitly write `public` or `abstract`.

  ```java
  interface Test {
      void method1();  // public abstract by default
      void method2();
  }
  ```
* **Cannot be private** (except Java 9+ for internal helper methods).
* **Cannot have a body** unless it is:

  * `static` (Java 8+)
  * `default` (Java 8+)

  ```java
  interface Test {
    static void staticMethod() {
      System.out.println("Static method in interface");
    }

    default void defaultMethod() {
      System.out.println("Default method in interface");
    }
  }
  ```

---

### **2. Variables in Interfaces**

* Variables are **constants by default** → `public static final`.
* Must follow **naming conventions** (usually uppercase).

  ```java
  interface Test {
    int X = 10;  // public static final by default

    static void staticMethod() {
      System.out.println("Static method in interface");
    }

    default void defaultMethod() {
      System.out.println("Default method in interface");
    }
  }
  ```
* Access via interface name: `Test.X`

---

### **3. Extending Interfaces**

* Interfaces can **extend other interfaces**:

  ```java
  interface Test2 extends Test {
    void method4();
  }
  ```
* A class implementing `Test2` must override all inherited abstract methods (unless class is abstract).

---

### **4. Implementing Interfaces**

* A class **implements** an interface, not extends it:

  ```java
  class MyClass implements Test2 {
    @Override
    public void method1() { /* ... */ }

    @Override
    public void method2() { /* ... */ }

    @Override
    public void method4() { /* ... */ }
  }
  ```
* **If any method is not overridden** → class must be declared `abstract`.

---

### **5. Default Methods (Java 8+)**

* Allow **modifying interfaces without breaking existing classes**.
* Classes may **override default methods**, but it's optional.

  ```java
  interface Test {
    void method1();
    default void method3() {
        System.out.println("Default method3");
    }
  }
  class MyClass implements Test {
    @Override
    public void method1() { System.out.println("Method1 overridden"); }
  }
  ```
* **Usage**:

  ```java
  MyClass obj = new MyClass();
  obj.method3(); // calls default method
  ```

---

### **6. Static Methods (Java 8+)**

* Can have **method body**.
* Called using **interface name**, not object:

  ```java
  Test.staticMethod();
  ```

---

### **7. Private Methods (Java 9+)**

* Cannot be abstract.
* Used **only inside interface** for reusing code in default or static methods.
* Cannot be accessed by implementing classes.

---

### **8. Modifying Existing Interfaces**

* **Adding a new abstract method** breaks existing implementations → they become abstract.
* **Solution**: use `default` methods to safely add functionality without breaking old classes.

---

### **9. Summary Table**

| Feature                     | Allowed / Notes                                   |
| --------------------------- | ------------------------------------------------- |
| Method without body         | Allowed, public & abstract by default             |
| Method body                 | Only `default` or `static`                        |
| Variables                   | Allowed, `public static final` by default         |
| Private method              | Allowed (Java 9+), only for internal use          |
| Extending another interface | Allowed                                           |
| Implementing in class       | Must override all abstract methods                |
| Adding new abstract method  | Breaks old classes, use `default` to avoid issues |

---

✅ **Tip:**

* **Default methods** are a way to evolve interfaces without breaking existing code.
* **Static methods** are utility methods related to the interface.
* **Private methods** help reduce code duplication inside interfaces.

---


## **1. Multiple Inheritance in C++**

* **Definition:** A class can inherit features from **more than one parent class**.
* **Example:**

  ```cpp
  class Phone { /* call features */ };
  class Camera { /* click, record features */ };
  class MusicPlayer { /* play, stop features */ };

  class Smartphone : public Phone, public Camera, public MusicPlayer {
      // inherits all features from Phone, Camera, and MusicPlayer
  };
  ```
* **Pros:**

  * Can reuse functionality from multiple classes.
* **Cons / Problems:**

  * **Diamond problem**: ambiguity arises if multiple parent classes have methods with the same name.
  * Complexity in design and maintenance.
* **Other Example (Animal Domain):**

  ```cpp
  class TerrestrialAnimal { /* land features */ };
  class AquaticAnimal { /* water features */ };

  class Amphibian : public TerrestrialAnimal, public AquaticAnimal { };
  ```

---

## **2. How Java Handles This**

* **Key Rule:** **Java does not support multiple inheritance of classes.**
* **Reason:** Prevents complexity, ambiguity, and diamond problem.
* Instead, Java uses **interfaces** to achieve multiple type inheritance.
* **Philosophy:** A class is **one main thing** (e.g., `Phone`) but **can implement multiple capabilities** (e.g., camera, music player).

---

### **3. Using Interfaces for Multiple Inheritance**

* **Interface Example:**

  ```java
  interface Camera {
      void click();
      void record();
  }

  interface MusicPlayer {
      void play();
      void stop();
  }
  ```

* **Smartphone Class:**

  ```java
  class Phone {
      void call() {
          System.out.println("Calling...");
      }
  }

  class Smartphone extends Phone implements Camera, MusicPlayer {
      @Override
      public void click() { System.out.println("Smartphone clicking..."); }
      @Override
      public void record() { System.out.println("Smartphone recording..."); }
      @Override
      public void play() { System.out.println("Smartphone playing music..."); }
      @Override
      public void stop() { System.out.println("Smartphone stopped music..."); }
  }
  ```

* **Advantages in Java:**

  1. **No diamond problem**: Interfaces only define methods, not implementation.
  2. **Flexible design**: A smartphone is still a `Phone` but can also **act like a camera and music player**.
  3. **Clearer abstraction**: Interfaces represent **capabilities** rather than concrete classes.

---

### **4. Real-Life Analogy**

| Concept               | C++ Multiple Inheritance                                         | Java Interface Approach                                                                       |
| --------------------- | ---------------------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| Smartphone            | `Phone + Camera + MusicPlayer` (is a Phone, Camera, MusicPlayer) | `extends Phone, implements Camera, MusicPlayer` (is a Phone, can act like Camera/MusicPlayer) |
| Car with Music System | Car “is a” MusicPlayer (incorrect)                               | Car “has” MusicPlayer interface (correct)                                                     |
| Amphibian             | inherits from Terrestrial + Aquatic (is both)                    | inherits Terrestrial, implements Aquatic interface (is Terrestrial, can act as Aquatic)       |

---

### **5. Key Takeaways**

1. **Java prohibits multiple inheritance of classes**, but allows multiple **interfaces**.
2. **Interfaces = capabilities**, not concrete implementations.
3. **Advantages of interfaces over C++ multiple inheritance**:

   * Simpler, safer design
   * Avoids ambiguity
   * Encourages thinking in terms of what an object **can do**, not what it **is**

---

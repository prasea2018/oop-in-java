# **üìòObject Class in Java ‚Äî Complete Structured Notes**

## **Learning Objectives**

By the end of this lesson, you should be able to:

* Understand the role of `java.lang.Object` as the root of the Java class hierarchy
* Identify and explain key methods inherited from the Object class
* Understand how `equals()`, `hashCode()`, and `toString()` work
* Distinguish which Object class methods can be overridden and which cannot
* Recognize Object class behavior in user-defined classes
* Understand the relationship between Object class and multithreading methods (`wait`, `notify`, etc.)

---

## ‚úÖ **Key Concepts**

### **1. java.lang Package**

* Automatically imported into every Java program.
* Contains fundamental classes required for Java (String, Math, Object, etc.).

### **2. Object Class**

* The *root class* (mother of all classes) of Java.
* Every class in Java directly or indirectly inherits from `Object`.
* User-defined classes also inherit all Object class methods automatically.

### **3. Inheritance Structure**

```
Object
   ‚Üë
MyObject
   ‚Üë
MyObject2
```

Even without explicitly writing `extends Object`, all classes inherit from it.

---

## ‚úÖ **Detailed Breakdown (with Explanations)**

### **1. What‚Äôs inside the Object Class?**

Important methods include:

#### **Clone()**

* Creates a copy of the current object.
* Protected method.
* Requires `Cloneable` interface to work properly.

---

#### **equals(Object o)**

* Compares references by default.
* Returns **true only if both references point to the same object**.
* Default behavior = **reference equality**.

Example:

```java
Object o1 = new Object();
Object o2 = new Object();
o1.equals(o2);  // false
o1.equals(o1);  // true
```

You can override it for **logical comparison**.

---

#### **finalize()**

* Called by Garbage Collector before an object is destroyed.
* Similar to destructor in C++, but unreliable ‚Üí rarely used today.
* Deprecated in modern Java.

---

#### **getClass()**

* Returns runtime class of the object.
* Useful for reflection.

---

#### **hashCode()**

* Returns a unique integer for each object.
* Generated using the object‚Äôs internal memory address (indirectly).
* Supports **hashing structures** like HashMap, HashSet.
* You can override it, but then **you must guarantee a proper hashing algorithm**.

---

#### **toString()**

* Returns a String representation of the object.
* Default format:

  ```
  package.ClassName@hexadecimalHashCode
  ```

Example:

```java
System.out.println(o1);  
// internally calls o1.toString()
```

Overriding it is extremely common.

---

#### **wait(), notify(), notifyAll()**

* Multithreading communication methods.
* Used for thread coordination.
* **All are final** ‚Üí cannot be overridden.
* Must be used inside synchronized blocks.

---

### ‚úîÔ∏è **2. Demonstrations with Code**

#### **Creating an Object**

```java
Object o1 = new Object();
System.out.println(o1);       // calls toString()
System.out.println(o1.hashCode());
```

---

#### **equals() Example**

```java
Object o2 = new Object();
System.out.println(o1.equals(o2)); // false

o2 = o1;
System.out.println(o1.equals(o2)); // true
```

---

#### **hashCode() Example**

```java
System.out.println(o1.hashCode()); // unique number
```

Java guarantees that **no two different objects share the same hashCode by default**.

---

### **3. User-Defined Classes Inheriting From Object**

Even without writing `extends Object`, this works:

```java
class MyObject { }

MyObject o = new MyObject();
o.toString(); // method inherited from Object
```

Even subclass chains inherit Object indirectly:

```java
class MyObject2 extends MyObject { }
```

---

## ‚úîÔ∏è **4. Overriding Object Class Methods**

### **Overriding toString()**

Very common.

```java
public String toString() {
  return "MyObject";
}
```

---

### **Overriding hashCode()**

Possible but must be done carefully.

Bad example (constant hashCode):

```java
public int hashCode() {
  return 100;   // every object gets same hash ‚Äî breaks hashing
}
```

---

### **Overriding equals()**

To match custom hashCode implementation:

```java
public boolean equals(Object o) {
  return this.hashCode() == o.hashCode();
}
```

---

### ‚ùå **Cannot Override**

* `wait()`
* `notify()`
* `notifyAll()`

Reason ‚Üí they are **final**.

---

# üß© **Summary**

* `Object` is the universal superclass for all Java classes.
* It provides essential methods like `equals`, `hashCode`, `toString`, `clone`, `wait`, `notify`, etc.
* User-defined classes inherit these automatically.
* `toString` is most commonly overridden.
* `equals` and `hashCode` should be overridden together.
* Multithreading methods in Object cannot be overridden.
* HashCodes are unique identifiers generated using internal memory layout.

---

# üìù **Application (Where This Knowledge Is Used)**

* **Debugging:** toString() overrides improve meaningful output.
* **Collections:** equals() and hashCode() affect how HashMap, HashSet store and compare objects.
* **Frameworks:** Reflection uses getClass().
* **Multithreading:** wait/notify for thread communication.
* **Memory management:** Understanding finalize() and garbage collection.

---

# ‚ùì **Self-Assessment Questions**

1. Why is Object class called the "root" of Java class hierarchy?
2. What is the default behavior of equals()? When should you override it?
3. Explain the relationship between equals() and hashCode().
4. Why should you avoid overriding hashCode() with a constant return value?
5. What does getClass() return?
6. Why can‚Äôt wait() and notify() be overridden?
7. What does toString() print by default?
8. How does Java ensure every object has a unique hashCode?

---

---

# **üìòWrapper Classes in Java ‚Äî Complete Notes**

## **1. What Are Wrapper Classes?**

* Java has **primitive data types**: `byte, short, int, long, float, double, char, boolean`.
* These **primitive types are not objects**.
* Java is an **object-oriented language**, so to treat primitives as objects, Java provides **wrapper classes**.
* Wrapper classes **wrap (box)** the primitive value inside an object.

---

## ‚úÖ **2. Why Wrapper Classes Exist**

* Primitives:

  * Have no methods
  * Are not objects
  * Cannot be used in collections like `ArrayList<Integer>` (collections store *objects*)

Wrapper classes solve this by:

* Providing an **object representation** of each primitive.
* Allowing method access on values (e.g., `Integer.parseInt()`).
* Allowing use in APIs or collections that require objects.

---

## ‚úÖ **3. Wrapper Classes List**

Each primitive data type has a corresponding wrapper class (in **java.lang** package):

| Primitive | Wrapper Class |
| --------- | ------------- |
| byte      | Byte          |
| short     | Short         |
| int       | Integer       |
| long      | Long          |
| float     | Float         |
| double    | Double        |
| char      | Character     |
| boolean   | Boolean       |

All wrapper classes are in **java.lang**, so no import is needed.

---

## ‚úÖ **4. Class Hierarchy**

```
            Object
       /               \
   Number        Character, Boolean
      |
------------------------------------------------
|   Byte   Short   Integer   Long   Float   Double
```

* **Number (abstract class)** is the parent of all numeric wrapper classes.
* `Character` and `Boolean` inherit directly from `Object`.

---

## ‚úÖ **5. Number Class**

Common methods defined in `Number` and inherited by numeric wrappers:

* `byteValue()`
* `shortValue()`
* `intValue()`
* `longValue()`
* `floatValue()`
* `doubleValue()`

These allow converting any numeric wrapper object to another primitive type.

Example:

```java
Integer i = 10;
float f = i.floatValue();   // int ‚Üí float
```

---

## ‚úÖ **6. Creating Wrapper Class Objects**

### **A. Old (Deprecated) Way**

```java
Integer i = new Integer(10);  // Deprecated
```

### **B. Recommended Way ‚Äî valueOf()**

```java
Integer a = Integer.valueOf(10);
```

### **C. Auto Boxing**

```java
Integer b = 10;  // Internally calls Integer.valueOf(10)
```

---

## **Examples for Each Wrapper**

### **1. Byte**

```java
Byte c = 15;                       // Direct assignment
Byte d = Byte.valueOf("15");       // From string
byte bb = 15;
Byte e = Byte.valueOf(bb);         // Using byte variable
```

### **2. Short**

```java
Short f = Short.valueOf("123");
```

### **3. Float**

```java
Float g = 12.3F;            // Must add F (otherwise double literal)
Float h = Float.valueOf("123.5");
```

### **4. Double**

```java
Double j = Double.valueOf(123.456);
```

### **5. Character**

```java
Character k = Character.valueOf('A'); // Must use single quotes
```

### **6. Boolean**

```java
Boolean l = Boolean.valueOf(true);
```

---

## ‚úÖ **7. What Is Boxing?**

**Boxing** = Converting a primitive ‚Üí Wrapper object.

Example:

```java
int m = 10;
Integer n = Integer.valueOf(m);   // Boxing
```

**Diagram:**

```
 Primitive (10)
     ‚Üì wrap
[ Integer Object ]
```

---

## ‚úÖ **8. Auto-Boxing**

Java automatically wraps primitives when needed.

```java
int m = 10;
Integer n = m;         // Auto-boxing
```

Equivalent to:

```java
Integer n = Integer.valueOf(m);
```

---

## ‚úÖ **9. What Is Unboxing?**

**Unboxing** = Converting a wrapper object ‚Üí primitive.

Example:

```java
Integer h = Integer.valueOf(20);
int x = h.intValue();    // Unboxing
```

---

## ‚úÖ **10. Auto-Unboxing**

Java automatically extracts primitive values.

```java
Integer h = 20;
int y = h;      // Auto-unboxing
```

Equivalent to:

```java
int y = h.intValue();
```

---

## üß© **Boxing and Unboxing Summary**

### **Boxing**

Primitive ‚Üí Wrapper
`Integer n = Integer.valueOf(m);`

### **Auto-Boxing**

Primitive ‚Üí Wrapper (automatic)
`Integer n = m;`

### **Unboxing**

Wrapper ‚Üí Primitive
`int p = n.intValue();`

### **Auto-Unboxing**

Wrapper ‚Üí Primitive (automatic)
`int p = n;`

---

## üìù **11. Key Rules to Remember**

* Integer literals without a suffix are of type `int`.
* Float literals must end with **F**.
* Character wrapper requires **single quotes** (`'A'`).
* String-based valueOf() works for numeric wrappers except Character.
* Wrapper classes are **immutable**.

---

## üìö **12. Practical Uses of Wrapper Classes**

* Needed when working with:

  * Collections (`ArrayList<Integer>`)
  * Generics
  * Reflection
  * Parsing values from strings (`Integer.parseInt()`)
  * Multithreading (`AtomicInteger` uses wrappers concepts)
* Methods like `floatValue()`, `intValue()`, etc., are common in numeric computations.

---

## ‚ùì **13. Self-Assessment Questions**

1. Why does Java need wrapper classes?
2. What is the purpose of the Number class?
3. What is the difference between boxing and auto-boxing?
4. Why can't floating-point literals like `12.3` be stored in Float without suffix `F`?
5. Write code to convert:

   * primitive `short` ‚Üí Short
   * object `Integer` ‚Üí primitive `int`
6. Can `Character.valueOf("A")` work? Why not?
7. How does auto-unboxing work internally?


---

# **üìòInteger Wrapper Class ‚Äî Complete Notes**

The **Integer** class is one of Java‚Äôs most commonly used wrapper classes. It wraps a primitive `int` inside an object and provides many useful methods.

---

## **1. Creating Integer Objects**

### **Primitive ‚Üí Integer (Auto-boxing)**

```java
int m1 = 15;
Integer m2 = m1;   // auto-boxing
```

### **Using valueOf()**

```java
Integer m = Integer.valueOf(15);
```

---

## **2. Inherited Methods (From Number Class)**

Integer extends **Number**, so it has:

* `byteValue()`
* `shortValue()`
* `intValue()`
* `longValue()`
* `floatValue()`
* `doubleValue()`

These convert an Integer object to different primitive types.

---

## **3. compareTo() Method**

### **Definition**

Compares **two Integer objects**.

```java
m2.compareTo(m3)
```

### **Returns**

* `0` ‚Üí both values equal
* `1` ‚Üí caller is greater
* `-1` ‚Üí caller is smaller

Same behavior as `String.compareTo()`.

---

## **4. equals() Method**

### **Key Difference from Object.equals()**

* `Object.equals()` ‚Üí checks if **references are same**.
* `Integer.equals()` ‚Üí overridden to check **numeric value**.

### **Examples**

#### Comparing object with primitive:

```java
m2.equals(m1);   // true (values both 15)
```

#### Comparing two Integer objects:

```java
Integer m3 = 15;
m2.equals(m3);   // true
```

### **Important**

* Can compare with **primitive int**
* Checks **value**, not reference

---

## **5. Important Static Methods of Integer**

## **5.1 valueOf() Overloads**

### (A) From String

```java
Integer m2 = Integer.valueOf("123");
```

### (B) From int

```java
Integer m3 = Integer.valueOf(50);
```

### (C) From String + Radix

```java
Integer m3 = Integer.valueOf("1010", 2);   // binary ‚Üí 10
Integer m3 = Integer.valueOf("A7", 16);    // hex ‚Üí 167
```

### Examples:

* `"11111111" (base 2)` ‚Üí 255
* `"A7" (base 16)` ‚Üí 167

---

## **5.2 decode()**

Parses integer from **hex, octal, decimal** by prefix:

| Prefix       | Meaning     |
| ------------ | ----------- |
| `0x` or `0X` | Hexadecimal |
| `#`          | Hexadecimal |
| `0`          | Octal       |

### Example:

```java
Integer m4 = Integer.decode("0xA7");   // 167
```

Equivalent to valueOf with radix.

---

## **5.3 parseInt() (Very Important)**

Converts **String ‚Üí primitive int**.

```java
int num = Integer.parseInt("123");  // 123
```

### **Throws NumberFormatException**

If string is not a valid number:

```java
Integer.parseInt("123a");   // Exception
Integer.parseInt("a");      // Exception
```

---

## **6. Constants in Integer Class**

* `Integer.MAX_VALUE` ‚Üí 2147483647
* `Integer.MIN_VALUE` ‚Üí -2147483648
* `Integer.BYTES` ‚Üí 4
* `Integer.SIZE` ‚Üí 32 bits

---

## **7. Other Useful Static Methods**

## ‚úî **bitCount(int n)**

Returns count of **1 bits** in binary representation.

---

## ‚úî **reverse(int n)**

Reverse **bit order**.

## ‚úî **reverseBytes(int n)**

Reverse the four bytes of integer.

Example demonstrated in the transcript:

* Reversing bytes of a specific number produced:

  ```java
  -2147483648  (Integer.MIN_VALUE)
  ```

Useful in systems, networking, endian conversion.

---

## ‚úî **rotateLeft(int n, int distance)**

## ‚úî **rotateRight(int n, int distance)**

Bit rotation operations.

---

## ‚úî **signum(int n)**

Returns:

* `1` ‚Üí positive
* `0` ‚Üí zero
* `-1` ‚Üí negative

---

## ‚úî **toBinaryString(int n)**

Converts integer ‚Üí binary string.

```java
System.out.println(Integer.toBinaryString(40)); // 101000
```

Similar methods:

* `toHexString()`
* `toOctalString()`

---

## **8. Summary Table**

| Category                     | Methods                                                            |
| ---------------------------- | ------------------------------------------------------------------ |
| **Conversion to primitives** | byteValue(), intValue(), longValue(), floatValue(), doubleValue()  |
| **Comparison**               | equals(), compareTo(), compare(), compareUnsigned()                |
| **Parsing/creation**         | valueOf(), parseInt(), decode()                                    |
| **Binary operations**        | reverse(), reverseBytes(), rotateLeft(), rotateRight(), bitCount() |
| **String conversions**       | toBinaryString(), toHexString(), toOctalString()                   |
| **Constants**                | MAX_VALUE, MIN_VALUE, BYTES, SIZE                                  |

---

## **9. Most Commonly Used Methods (Real Projects)**

‚úî `parseInt()`
‚úî `valueOf()`
‚úî `equals()`
‚úî `compareTo()`
‚úî `toBinaryString()`
‚úî `Integer.MAX_VALUE`, `Integer.MIN_VALUE`

---

## **10. Final Notes**

* Integer class provides many powerful utilities.
* Most methods are NOT used daily, but helpful in parsing, conversion, and low-level operations.
* Learn commonly used ones deeply; explore others when required.

---

# **üìòWrapper Classes: Float, Character, Boolean ‚Äî Complete Notes**


## **1. FLOAT CLASS**

Float is a wrapper class for the primitive `float`.
It inherits from **Number**, so it shares many methods with Integer (like `floatValue()`, `intValue()`, etc.).

---

### **1.1 Creating Float Values**

### Primitive:

```java
float a = 12.5f;
```

### Object (Auto-boxing or direct):

```java
Float b = 12.5f;          // auto-boxing
Float b = new Float(12.5f);   // old, not recommended
```

---

### **1.2 equals() Method**

Compares the **value**, not the object reference.

```java
b.equals(a);   // true (values match)
```

Float‚Äôs equals() behaves like Integer‚Äôs equals() ‚Üí compares numerical value.

---

### **1.3 Checking Infinity**

Two ways to check:

## ‚úî **A. Using instance method**

```java
b.isInfinite();
```

## ‚úî **B. Using constants**

* `Float.POSITIVE_INFINITY`
* `Float.NEGATIVE_INFINITY`

### Example:

```java
Float b = 12.5f / 0;        // +infinity
b.isInfinite();             // true
b.equals(Float.POSITIVE_INFINITY);  // true
```

### Negative infinity:

```java
Float b = -12.5f / 0;
b.equals(Float.NEGATIVE_INFINITY); // true
```

### Important:

Division by zero **does NOT throw exception** for float and double.
Instead, it yields ¬±infinity or NaN.

---

### **1.4 Checking NaN (Not a Number)**

NaN occurs when result is **undefined**, such as:

```java
Float b = (float) Math.sqrt(-1);   // NaN
```

### ‚úî Correct method:

```java
b.isNaN();   // true
```

### ‚úî Wrong/unreliable method:

```java
b.equals(Float.NaN);   // false always
Float.NaN == Float.NaN // false always
```

NaN **cannot** be compared using `==` or `equals()`.

### Rule:

‚û°Ô∏è **Always use `isNaN()`** to check if a float/double is not a number.

---

## **2. CHARACTER CLASS**

Wrapper for primitive `char`.
Does NOT inherit from Number.

---

### **2.1 Basic Methods**

```java
Character c = 'A';

c.charValue()   // returns primitive char
c.compareTo('B')
c.equals('A')
c.toString()
```

---

### **2.2 Important Static Utility Methods**

Character class contains many useful static methods to classify characters.

### ‚úî **Case conversion**

```java
Character.toUpperCase(c);
Character.toLowerCase(c);
Character.toTitleCase(c);
```

### ‚úî **Character type checks**

```java
Character.isLetter(c);
Character.isDigit(c);
Character.isLetterOrDigit(c);
Character.isWhitespace(c);
Character.isUpperCase(c);
Character.isLowerCase(c);
```

These eliminate the need for ASCII code checking.

### Purpose:

Use these for input validation, parsing, form validation, etc.

---

## **3. BOOLEAN CLASS**

Wrapper for primitive `boolean`.

---

### **3.1 Basic Methods**

```java
Boolean b = true;

b.booleanValue();
b.compareTo(false);
b.equals(true);
```

---

### **3.2 Important Static Methods**

### ‚úî **Logical operations (Boolean logic)**

(Not bitwise, but similar concept)

```java
Boolean.logicalAnd(true, false);  // false
Boolean.logicalOr(true, false);   // true
Boolean.logicalXor(true, true);   // false
```

### ‚úî **parseBoolean()**

Converts String ‚Üí boolean.

```java
Boolean.parseBoolean("true");   // true
Boolean.parseBoolean("TrUe");   // true
Boolean.parseBoolean("anything else"); // false
```

Same style as:

* `Integer.parseInt()`
* `Float.parseFloat()`

---

## **4. Summary Table**

### ‚úÖ **Float**

| Feature        | Method / Constant                                        |
| -------------- | -------------------------------------------------------- |
| Check infinity | `isInfinite()`, `POSITIVE_INFINITY`, `NEGATIVE_INFINITY` |
| Check NaN      | `isNaN()`                                                |
| Compare values | `equals()`                                               |
| Not reliable   | comparing with `Float.NaN`                               |

---

### ‚úÖ **Character**

| Purpose            | Method                             |
| ------------------ | ---------------------------------- |
| Case conversion    | toUpperCase, toLowerCase           |
| Check letter/digit | isLetter, isDigit, isLetterOrDigit |
| Check case         | isUpperCase, isLowerCase           |
| Check whitespace   | isWhitespace                       |

---

### ‚úÖ **Boolean**

| Purpose                  | Method                            |
| ------------------------ | --------------------------------- |
| Logical operations       | logicalAnd, logicalOr, logicalXor |
| Convert String ‚Üí boolean | parseBoolean                      |
| Compare booleans         | compare(), compareTo()            |

---


## **5. Key Takeaways**

* Use **isNaN()** ‚Üí NEVER compare NaN using == or equals().
* Float division by zero ‚Üí no exception ‚Üí results in ¬±‚àû or NaN.
* Character class has extremely useful utility methods for validation.
* Boolean class offers logical operations and parsing from strings.
* These wrapper classes help in situations when primitives cannot be used (Collections, Generics, OOP design).

---


# **üìòJava: String vs StringBuffer vs StringBuilder**

Java provides three main classes for working with sequences of characters:

* **String**
* **StringBuffer**
* **StringBuilder**

Each serves a different purpose based on performance, mutability, and thread-safety.

---

## **1. String Class**

### **Definition**

* A `String` in Java is a **sequence of characters**.
* **Immutable** ‚Äì once created, it cannot be modified.

### **Key Concept: Immutability**

* Any modification (e.g., concatenation) **creates a new object**.
* The old object remains unchanged.

### **Example**

```java
String s = "Hello";
s.concat("World"); // returns a new String, s remains "Hello"
```

You must assign the result back if you want the updated value:

```java
s = s.concat("World"); // Now s = "HelloWorld"
```

### **Why String is Immutable?**

* Improves performance (string pool)
* Thread-safe
* Secure (important for things like class names, file paths, DB URLs)

---

## **2. StringBuffer Class**

### **Definition**

* A **mutable** sequence of characters.
* Used when **frequent modifications** are needed (append, insert, delete).
* **Thread-safe** ‚Äì all methods are synchronized.

### **Key Features**

* Default capacity = **16 characters**.
* Grows automatically if needed.
* Same methods as String, plus:

  * `append()`
  * `insert()`
  * `delete()`
  * `reverse()`

### **Thread Safety**

* Only one thread can access its methods at a time.
* Prevents data inconsistency.
* **Slightly slower** due to synchronization.

### **Example**

```java
StringBuffer sb = new StringBuffer("Hello");
sb.append("World"); 
// sb becomes "HelloWorld"
```

---

## **3. StringBuilder Class**

### **Definition**

* Same as `StringBuffer` (**mutable**), but:
* **NOT thread-safe** (methods are not synchronized)

### **Why faster?**

* No synchronization overhead.
* Best choice when:

  * Only one thread is modifying the data
  * Performance is important

### **Example**

```java
StringBuilder sb = new StringBuilder("Hello");
sb.append("World");
// sb becomes "HelloWorld"
```

---

## **4. Comparison Table**

| Feature      | String                       | StringBuffer              | StringBuilder               |
| ------------ | ---------------------------- | ------------------------- | --------------------------- |
| Mutability   | ‚ùå Immutable                  | ‚úî Mutable                 | ‚úî Mutable                   |
| Thread-safe? | ‚úî Yes                        | ‚úî Yes                     | ‚ùå No                        |
| Performance  | Fast (no changes)            | Slowest (synchronized)    | Fastest                     |
| When to use? | Fixed text, no modifications | Multithreaded environment | Single-thread modifications |

---

## **5. Capacity vs Length (StringBuffer/StringBuilder)**

* **Length** ‚Üí number of characters currently stored.
* **Capacity** ‚Üí size of the internal character array.

Default capacity = **16**

If exceeded, capacity increases automatically.

---

## **6. Important Methods**

### **Common String-like methods**

* `.charAt()`
* `.indexOf()`
* `.lastIndexOf()`
* `.substring()`
* `.toString()`

### **Specific to Buffer/Builder**

* `.append(...)`
* `.insert(index, value)`
* `.delete(start, end)`
* `.reverse()`

---

## **7. Demo Program: String vs Buffer vs Builder**

```java
String s1 = "Hello";
StringBuffer s2 = new StringBuffer("Hello");
StringBuilder s3 = new StringBuilder("Hello");

s1.concat("World");
s2.append("World");
s3.append("World");

System.out.println(s1); // Hello (unchanged)
System.out.println(s2); // HelloWorld
System.out.println(s3); // HelloWorld
```

---

## **8. Thread-Safety Explanation**

### **StringBuffer**

* All modifying methods are synchronized.
* Only one thread enters a method like `append()` or `insert()` at a time.

### **StringBuilder**

* No synchronization ‚Üí better speed.
* NOT safe for use by multiple threads simultaneously.

---

## **9. When to Use Which?**

### ‚úî **Use String when:**

* Text won't change
* Safety and immutability matter

### ‚úî **Use StringBuilder when:**

* Modifications are frequent
* Only one thread is involved
* Best performance is needed

### ‚úî **Use StringBuffer when:**

* Multiple threads modify a string
* Thread safety is required

---


# **üìòJava Enum ‚Äî Complete Notes**

## **1. What is an Enum?**

* **Enum (enumeration)** is used to define **user-defined data types** with a fixed set of constant values.
* Similar concept exists in **C/C++**.
* In Java, an enum behaves like a **special class** containing:

  * Constants (public, static, final)
  * Methods
  * Fields
  * Constructors (private/default only)

---

## **2. Enum Basics**

### **Definition Example**

```java
enum DEPT {
    CS, IT, CIVIL, ECE
}
```

### **Key Properties**

* Each identifier (`CS`, `IT`, etc.) is:

  * `public`
  * `static`
  * `final`
  * A **singleton object** of type `DEPT`

### **Using an Enum**

```java
DEPT d = DEPT.CS;
```

* `d` can only hold values defined inside the enum.
* Invalid:

```java
d = 1; // ‚ùå Not allowed
```

---

## **3. Enum Inheritance**

* Java enums **implicitly extend** `java.lang.Enum`.
* They cannot extend other classes.
* Provided methods include:

  * `name()` ‚Üí returns constant name as String
  * `ordinal()` ‚Üí index (0-based) according to declaration order
  * `valueOf(String)` ‚Üí returns enum constant matching a string
  * `toString()`

---

## **4. Built-in Methods Explained**

### **name()**

```java
DEPT.CS.name(); // "CS"
```

### **ordinal()**

```java
DEPT.CS.ordinal(); // 0
DEPT.IT.ordinal(); // 1
DEPT.CIVIL.ordinal(); // 2
```

### **valueOf()**

```java
DEPT dep = DEPT.valueOf("IT"); // OK
DEPT dep = DEPT.valueOf("it"); // ‚ùå IllegalArgumentException
```

* Must match exact constant name (case-sensitive).

### **values()**

Returns array of all constants:

```java
DEPT[] list = DEPT.values();
```

Using for-each:

```java
for (DEPT x : list) {
    System.out.println(x);
}
```

---

## **5. Enum and Switch Case**

Enums work perfectly with switch statements:

```java
DEPT d = DEPT.CIVIL;

switch(d) {
  case CS:  System.out.println("Head: John, Block A"); break;
  case IT:  System.out.println("Head: David, Block B"); break;
  case CIVIL: System.out.println("Head: Srinivas, Block C"); break;
  case ECE: System.out.println("Head: Dave, Block D"); break;
}
```

---

## **6. Enum Constructors**

### **Important Rules**

* Enum **can have constructors**.
* Constructor must be **private or default** (never public/protected).
* Called **automatically when the enum is loaded**, not when used.

### **Example to demonstrate constructor call:**

```java
enum DEPT {
  CS, IT, CIVIL, ECE;

  DEPT() {
    System.out.println(this.name());
  }
}
```

Output when the program loads:

```
CS
IT
CIVIL
ECE
```

(Not when assigning `DEPT d = DEPT.ECE;`)

---

## **7. Enum with Fields & Parameterized Constructor**

Enums can store **additional data** for each constant.

### **Example: With headName and location**

```java
enum DEPT {
  CS("John", "Block A"),
  IT("David", "Block B"),
  CIVIL("Srinivas", "Block C"),
  ECE("Dave", "Block D");

  private String head;
  private String location;

  private DEPT(String head, String location) {
    this.head = head;
    this.location = location;
  }

  public String getHeadName() { return head; }
  public String getLocation() { return location; }
}
```

### **Using it**

```java
DEPT d = DEPT.CS;

System.out.println(d.getHeadName());   // John
System.out.println(d.getLocation());   // Block A
```

> Now each enum constant acts like an object with its own fields.

---

## **8. Enum as Objects**

* Each enum constant is essentially an **object** of the enum type.
* Example:

  * `DEPT.CS` ‚Üí object with `head="John"`, `location="Block A"`
  * `DEPT.IT` ‚Üí different object with its own fields

This makes enums extremely useful for:

* Codes
* Configurations
* Predefined types with metadata

---

## **9. Summary of Key Learnings**

‚úî Enum defines constants

‚úî Enum constants are objects

‚úî Enum extends `java.lang.Enum`

‚úî Can use constructors (private/default)

‚úî Can add fields and methods

‚úî Constructor runs at **class loading**, not object creation

‚úî Useful with `switch`

‚úî `values()`, `name()`, `ordinal()`, `valueOf()`

---


# **üìòJava Math Class ‚Äî Complete Notes**

## **1. Overview**

* The `java.lang.Math` class provides **mathematical operations**.
* All methods are **`public static`**, so you call them using:

  ```java
  Math.methodName(...)
  ```
* Most methods return **double** unless otherwise specified.
* Some methods may internally use `StrictMath` (JVM-dependent).

---

## **2. `StrictMath` vs `Math`**

### **StrictMath**

* Guarantees **precise, consistent results** across all JVMs.
* May be slower (more decimal precision).
* Mostly used internally by the JVM.

### **Math**

* May use:

  * **Native CPU instructions** for performance (faster)
  * Or fall back to StrictMath (JVM decides)
* Results may differ slightly from StrictMath.

**Bottom line:**
üëâ Use **Math** class in your programs.
üëâ StrictMath is rarely used directly.

---

## **3. Important Methods of the Math Class**

---

## **A. Basic Operations**

### **1. `abs()` ‚Äî Absolute Value**

```java
Math.abs(-123); // 123
Math.abs(123); // 123
```

Converts negative numbers to positive.

---

### **2. `cbrt()` ‚Äî Cube Root**

```java
Math.cbrt(27); // 3.0
Math.cbrt(9);  // 2.08...
```

---

### **3. `decrementExact()`**

Safely decrements **without overflow**.

#### Example:

```java
Math.decrementExact(7); // 6
```

#### With underflow:

```java
Math.decrementExact(Integer.MIN_VALUE); 
// Throws ArithmeticException
```

#### Why?

Because:

```java
int i = Integer.MIN_VALUE;
i--;  
// becomes Integer.MAX_VALUE (overflow)
```

`decrementExact` prevents such wrap-around.

---

## **B. Floating Point Internals**

### **4. `getExponent()`**

Returns **exponent** of the floating-point representation (mantissa‚Äìexponent form).

Examples:

```java
Math.getExponent(12.3456); // 3
Math.getExponent(123.45);  // 6
```

Used in applications needing floating-point precision analysis.

---

## **C. Division & Logarithms**

### **5. `floorDiv()`**

Performs division and **truncates** the decimal part.

```java
Math.floorDiv(50, 9); // 5
```

Equivalent to integer division.

---

### **6. `exp()` ‚Äî e^x**

```java
Math.exp(1);       // e^1
StrictMath.exp(1); // more precise result
```

Difference shows Math does **not always** call StrictMath internally.

---

### **7. `log10()` ‚Äî Logarithm Base 10**

```java
Math.log10(100);   // 2
Math.log10(1000);  // 3
```

### **8. `log()` ‚Äî Natural Log (base e)**

```java
Math.log(2.71828); // ‚âà 1
```

---

## **D. Min/Max**

### **9. `max()` & `min()`**

```java
Math.max(10, 20); // 20
Math.min(10, 20); // 10
```

---

## **E. Trigonometric Functions**

### **10. `sin()`, `cos()`, `tan()`**

* Accept **radians**, not degrees.
* Convert degrees ‚Üí radians using:

```java
Math.toRadians(45);
```

Example:

```java
Math.tan(Math.toRadians(45));  // ~0.999999 (close to 1)
```

Floating-point precision may cause slight deviations.

---

### **11. `toRadians()` & `toDegrees()`**

```java
Math.toRadians(90); // 1.5708...
Math.toDegrees(1.5708); // ~90
```

---

### **12. `atan()` ‚Äî Inverse Tan (tan‚Åª¬π)**

Returns result in radians:

```java
double r = Math.atan(1); // œÄ/4 radians
Math.toDegrees(r);       // 45 degrees
```

---

### **13. Hyperbolic Trig: `tanh()`**

```java
Math.tanh(1); // hyperbolic tan
```

---

## **F. Random and Power Functions**

### **14. `random()`**

Returns random value between **0.0 and 1.0**.

```java
double r = Math.random(); // 0 to 1
```

### To get 3-digit random number:

```java
(int)(Math.random() * 1000);
```

---

### **15. `pow()`**

```java
Math.pow(2, 3); // 8
```

---

## **G. Exact Arithmetic**

### **16. `multiplyExact()`**

Works like decrementExact:

### Normal:

```java
Math.multiplyExact(100, 200); // 20000
```

### Overflow:

```java
Math.multiplyExact(100000, 100000);
// Throws ArithmeticException
```

---

## **H. Floating-Point Next Values**

### **17. `nextAfter(a, b)`**

Returns the **next floating-point number** after **a**, moving **towards b**.

Example:

```java
Math.nextAfter(12.5, 13); 
// 12.5000000002 ‚Üí next float UP
```

If b < a, moves backwards:

```java
Math.nextAfter(12.5, 11);
// 12.4999999997 ‚Üí next float DOWN
```

---

## **18. Summary Table of Common Math Methods**

| Category         | Methods                                       | Notes                        |
| ---------------- | --------------------------------------------- | ---------------------------- |
| Absolute         | abs                                           | Positive value               |
| Roots            | sqrt, cbrt                                    | Square & cube root           |
| Exact Arithmetic | incrementExact, decrementExact, multiplyExact | Throws exception on overflow |
| Logs             | log, log10                                    | Natural & base-10            |
| Exponential      | exp                                           | e^x                          |
| Trig             | sin, cos, tan                                 | Uses radians                 |
| Inverse Trig     | asin, acos, atan                              | Returns radians              |
| Hyperbolic       | sinh, cosh, tanh                              | Hyperbolic functions         |
| Random           | random                                        | 0.0‚Äì1.0                      |
| Rounding         | ceil, floor, round                            | Various rounding styles      |
| Min/Max          | min, max                                      | Compare numbers              |
| Convert          | toRadians, toDegrees                          | Angle conversions            |
| Next Float       | nextAfter                                     | Next representable double    |

---

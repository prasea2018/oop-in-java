# **Operators in Java â€“ Complete Lecture Notes**

Operators are symbols used to perform operations on variables and values. Using operators, we write **expressions**, and therefore it is very important to understand:

- Types of Java operators
- How expressions are evaluated
- Operator **precedence**
- **Result data type** of an expression

In this chapter, we start with **Arithmetic Operators**, then move to **Increment/Decrement**, **Relational**, **Logical**, and **Bitwise Operators**.

------

## **1. Arithmetic Operators**

Arithmetic operators perform basic mathematical operations.

| Operator | Meaning                   |
| -------- | ------------------------- |
| `+`      | Addition                  |
| `-`      | Subtraction               |
| `*`      | Multiplication            |
| `/`      | Division (gives quotient) |
| `%`      | Modulo (gives remainder)  |

### **1.1 Applicable Data Types**

Arithmetic operators work on:

- `byte`
- `short`
- `int`
- `long`
- `float`
- `double`
- `char`

They **do not work on `boolean`**.

------

### **1.2 Division and Modulo**

### **Division (`/`) gives the Quotient**

Example:

```
10 / 3 â†’ 3 (quotient)
```

### **Modulo (`%`) gives the Remainder**

Example:

```
10 % 3 â†’ 1 (remainder)
```

### **Modulo also works on floats and doubles**

Example:

```
12.7 % 3.1 â†’ 0.3  
```

Java internally performs division and returns the remainder as a floating-point value.

------

## **2. Operator Precedence**

Precedence determines which operator is executed first in an expression.

### **Arithmetic Precedence**

1. `*`  `/` `%`   (higher precedence)
2. `+`  `-`       (lower precedence)

All operators with the same level follow **left-to-right associativity**.

------

### **2.1 Need for Parentheses**

Example 1:
 Mathematical formula:

```
(a + b) / 2
```

If we write in Java:

```
x = a + b / 2;
```

Java evaluates `b / 2` first because `/` has higher precedence.

Example:

```
a = 6, b = 10
x = 6 + 10/2
x = 6 + 5 = 11   (WRONG result)
```

To correct it:

```
x = (a + b) / 2;   // correct
```

------

### **2.2 Complex Example**

Expression:

```
( a + b ) / ( 2 * c )
```

If written incorrectly:

```
a + b / 2 * c
```

Execution order (left to right among */):

1. `b / 2`
2. result * `c`
3. then add `a`

This is **NOT** the intended formula.

Correct way:

```
(a + b) / (2 * c)
```

Use parentheses to enforce correct precedence.

------

## **3. Writing Mathematical Expressions in Java**

Example:
 Expression:

```
AÂ² â€“ BÂ²
```

There is **no square operator** in Java.

Correct way:

```
a * a - b * b
```

------

## **4. Result Data Type of Expressions**

When different data types participate in an arithmetic expression, Java **promotes** smaller types to larger types.
 This is called **Type Promotion** (or **Coercion**).

### **4.1 Rule 1: `byte`, `short`, and `char` are promoted to `int`**

Examples:

- `byte + byte` â†’ `int`
- `byte + short` â†’ `int`
- `char + char` â†’ `int`

Even if both operands are `byte`, result is **always `int`**.

### **4.2 Rule 2: If any operand is `long` â†’ result is `long`**

### **4.3 Rule 3: If any operand is `float` â†’ result is `float`**

### **4.4 Rule 4: If any operand is `double` â†’ result is `double`**

------

## **Examples**

### **Example 1**

```
byte a, b;
int x = a + b;     // result is int
```

### **Example 2**

```
int + float â†’ float
```

### **Example 3**

```
long + float â†’ float
```

### **Example 4**

```
int + double â†’ double
```

### **Reason**

The smaller type is automatically converted (promoted) to the larger type before performing the operation.

------

## âœ” Final Summary (For Students)

- Arithmetic operators perform basic mathematical tasks.
- `/` gives quotient, `%` gives remainder.
- Precedence: `* / %` > `+ -`
- Use parentheses to control evaluation order.
- Expression result type depends on **largest** data type in the expression.
- `byte`, `short`, `char` â†’ automatically promoted to `int`.
- Presence of `float` â†’ result becomes `float`.
- Presence of `double` â†’ result becomes `double`.

---

# **ğŸ“˜ Practice  Arithmetic Operators**

## **1. Learning Objectives**

By the end of this module, you will be able to:

1. Perform division and modulo operations correctly on integers and floats.
2. Understand how Java handles data type promotion during arithmetic operations.
3. Predict the result of expressions involving `byte`, `short`, `int`, `long`, `float`, and `double`.
4. Identify and fix lossy conversion errors in Java.
5. Apply operator precedence rules and modify them using parentheses.
6. Verify expression evaluation step-by-step.

---

## **2. Key Concepts (Simplified)**

### **â— Integer Division**

* When two integers are divided, Java **truncates the decimal part**.
  Example: `14 / 5 = 2` (not 2.8)

### **â— Modulo Operator `%`**

* Returns the **remainder** of division.
  Example: `14 % 5 = 4`

### **â— Float & Double Modulo**

* `%` also works on floating-point numbers.
  Example: `14.3f % 3.2f â‰ˆ 1.5f`

### **â— Type Promotion in Expressions**

Whenever Java performs arithmetic:

* `byte`, `short`, `char` â†’ promoted to **int**
* If any operand is **long**, result becomes long
* If any operand is **float**, result becomes float
* If any operand is **double**, result becomes double

### **â— Type Mismatch / Lossy Conversion Errors**

Error example:

```
incompatible types: possible lossy conversion from int to byte
```

Occurs when you try to assign a larger type into a smaller one.

### **â— Operator Precedence**

Higher precedence executed first:
`*  /  %`  â†’ before â†’ `+  -`

Example:
`10 + 20 / 2 = 20` (not 15)

Use parentheses to change evaluation order:
`(10 + 20) / 2 = 15`

---

## **3. ASCII Concept Map**

```
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚   Arithmetic in Java      â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚                         â”‚                           â”‚
 Data Type Promotion     Integer vs Float Ops       Precedence Rules
      â”‚                         â”‚                           â”‚
      â–¼                         â–¼                           â–¼
 byte/short/char â†’ int   int division â†’ truncates      */% before +-
 long â†’ long              float division â†’ keeps decimals   parentheses change order
 float â†’ float            modulo works on float        left-to-right associativity
 double â†’ double
```

---

## **4. Detailed Breakdown (Step-by-Step Learning)**

### **A. Integer Division & Modulo**

Using:

```java
int a = 14;
int b = 5;
```

* `a / b` â†’ `2`
* `a % b` â†’ `4`

Because the decimal part is discarded in integer division.

---

### **B. Getting Decimal Results**

To get 2.8 instead of 2:

```java
float c = (float) a / b;
```

Or:

```java
float a = 14.0f;
float b = 5.0f;
```

---

### **C. Modulo with Floats**

Example:

```java
float a = 14.3f;
float b = 3.2f;
float r = a % b;
```

Manually,

* 3.2 Ã— 4 = 12.8
* 14.3 âˆ’ 12.8 = 1.5

Result = **1.5**

---

### **D. Type Promotion Demonstration**

#### Example with byte and char:

```java
byte a = 10;
char b = 'A'; // 65
byte c = a + b; // ERROR
```

Why?
`byte + char â†’ int`
You cannot store int into byte without casting.

Fix:

```java
int c = a + b;
```

#### Example with float and long:

```java
float a = 12.5f;
long b = 123L;

float c = a * b; // OK (result = float)
```

Rule applied:
float Ã— long â†’ float (because float is larger)

---

### **E. Double + Float**

```java
float a = 12.5f;
double b = 3.14;

double c = a * b; // OK
float c = a * b;  // ERROR (double â†’ float)
```

---

### **F. Mixing char and int**

```java
char a = 40;
int b = 30;
int c = a - b; // OK
```

Result = 10

---

### **G. Operator Precedence**

Expression:

```java
10 + 20 / 2
```

Evaluates as:

* 20 / 2 = 10
* 10 + 10 = 20

To change order:

```java
(10 + 20) / 2 = 15
```

---

Another example:

```java
10 / 2 * 5
```

NOT:

* first multiply â†’ wrong!

Correct evaluation:

* 10 / 2 = 5
* 5 * 5 = 25

Why?
`/` and `*` have equal precedence â†’ evaluated left to right

To change order:

```java
10 / (2 * 5) = 1
```

---

## **5. Summary**

* Integer division removes decimals.
* Modulo returns remainder and works for both int and float.
* Arithmetic promotes smaller types to larger ones.
* Lossy conversion errors occur when storing big-type results in smaller-type variables.
* Precedence rules determine evaluation order; parentheses override them.
* Understanding type promotion avoids many common Java errors.

---

## **6. Application (Practical Usage)**

You will use these concepts when:

* Validating financial transactions (correct numerical calculations).
* Working with timestamps or sensor readings (float/int conversion).
* Building Java APIs handling mixed data types.
* Preventing bugs caused by unexpected type promotion.
* Optimizing expressions for readability and correctness.

---

## **7. Self-Assessment Questions**

1. What is the output of `17 / 4` and why?
2. What is `17 % 4`?
3. Will this compile? Why or why not?

   ```java
   byte a = 5;
   byte b = 7;
   byte c = a + b;
   ```
4. Predict the result:

   ```java
   float a = 10.5f;
   long b = 2;
   var c = a * b;
   ```

   What is the type of `c`?
5. Evaluate:

   ```java
   8 + 12 / 4 * 2
   ```
6. Rewrite so the addition is evaluated first.

---

## **1. Area of a Triangle (Base & Height Formula)**

```java 

package expression;

import java.lang.*;
import java.util.*;


public class Expression 
{
    public static void main(String[] args) 
    {
        float base,height,area;
        System.out.println("Enter Base and Height");
        Scanner sc=new Scanner(System.in);
        base=sc.nextFloat();
        height=sc.nextFloat();
        area=base*height*0.5f;
        //area=1f/2f*base*height;
        //area=base*height/2;
        System.out.println("Area of Triangle is "+area);
    }
}
```
### **Why use float?**

* Dividing by 2 can produce decimal values.
* So `base`, `height`, and `area` should be `float`.

### **Steps in the Program**

1. Declare variables:

   ```java
   float base, height, area;
   ```

2. Take input using `Scanner`:

   ```java
   Scanner sc = new Scanner(System.in);
   base = sc.nextFloat();
   height = sc.nextFloat();
   ```

3. Calculate the area using:

   ```java
   area = base * height / 2;
   ```

   OR

   ```java
   area = base * height * 0.5f;
   ```

   **Donâ€™t do:** `1/2` â†’ gives **0** because it's integer division.

4. Print result.

---

## **2. Area of a Triangle Using Three Sides (Heron's Formula)**

### **Formula**

Given sides **A**, **B**, **C**:

1. Compute semi-perimeter:
   `S = (A + B + C)/2`

2. Compute area:
   `Area = \sqrt{S (S-A)(S-B)(S-C)}`

```java 
    public static void main(String[] args) 
    {
        Scanner sc=new Scanner(System.in);
         
        int a,b,c;
        double s,area;
        
        System.out.println("Enter 3 Sides of a Triangle");
        a=sc.nextInt();
        b=sc.nextInt();
        c=sc.nextInt();
        
        // s=(float) (a+b+c)/2;
        s=(a+b+c)/2f;
        
        area=Math.sqrt(s*(s-a)*(s-b)*(s-c));
        
        System.out.println("Area of Triangle is "+area);    
    }
```


### **Typical Mistake**

* A, B, C are integers
* `S = (A + B + C) / 2` â†’ gives integer division again
* Must ensure **float or double arithmetic**

### **Fix**

Either:

```java
S = (A + B + C) / 2.0f;
```

or:

```java
S = (float)(A + B + C) / 2;
```

### **Square Root**

Use:

```java
Math.sqrt(value);
```

### **Important**

* `Math.sqrt()` returns **double** â†’ so `area` should be `double`.

---

## **Summary**

* Java expressions must be written carefully to avoid integer-division errors.
* Area of triangle (baseâ€“height) uses:

  ```
  area = (base * height) / 2;
  ```
* Avoid `1/2` because it is integer division â†’ gives 0.
* Heron's formula needs careful data typing because intermediate results may be decimal.
* Use `Math.sqrt()` to compute the square root.
* Always select correct variable types (`int`, `float`, `double`).

---

# **Practical Applications**

* Geometry calculators
* CAD systems or architectural tools
* GIS applications (measuring land shapes)
* Game development (collision areas, mesh triangles)
* Physics/engineering simulations involving triangular components

---

# **Self-Assessment Questions**

1. Why does `1/2` produce **0** in Java?
2. What data type should you use for area when using Heronâ€™s formula and why?
3. Rewrite the formula `(A + B + C) / 2` so that it performs floating-point division.
4. What happens if you use `Math.sqrt()` but store the result in a `float` variable?
5. Write an expression for area using base and height without using `/ 2`.

---


# **4. Student Challenge  Find Roots of Quadratic Equation**

The equation `(x+r1)(x+r2)=0` generates the quadratic equation. 

r1 = (-b + Sqrt(b2 - 4ac) ) / 2a
r2 = (-b - Sqrt(b2 - 4ac) ) / 2a

```java 

package expression1;

import java.lang.*;
import java.util.*;

public class Expression1 {

   
    public static void main(String[] args) 
    {
       Scanner sc=new Scanner(System.in);
       
       int a,b,c;
       double r1,r2;
       
       System.out.println("Enter the values of a ,b and c");
       a=sc.nextInt();
       b=sc.nextInt();
       c=sc.nextInt();
       
       r1=(-b+Math.sqrt(b*b-4*a*c)) / (2*a);
       r2=(-b-Math.sqrt(b*b-4*a*c)) / (2*a);
       
       System.out.println("Roots are "+r1+" "+r2 );
    }   
}
```
**Output** 
- If you enter values of all a, b, c as 1 you get NaN (Not a Number) because Math.sqrt() can't operate on negative values
- Enter values as 1 5 6


# **Student Challenge   : Cuboid ** 

```java 
package expression2;

import java.lang.*;
import java.util.*;


public class Expression2 {

    
    public static void main(String[] args) 
    {
        Scanner sc=new  Scanner(System.in);
        int length,breadth,height;
        int totalArea,volume;
        
        System.out.println("Enter length, breadth and height");
        length=sc.nextInt();
        breadth=sc.nextInt();
        height=sc.nextInt();
        
        totalArea=2*(length*breadth+length*height+breadth*height);
        
        volume=length*breadth*height;
        
        System.out.println("Total Area "+totalArea);
        System.out.prinlt("Volume "+volume);                
    }   
}
```

# **ğŸ“˜Increment and Decrement Operators in Java**

Increment and decrement operators are among the most commonly used operators in Java. They are used to increase or decrease the value of a variable by **exactly 1**.

There are two types:

1. **Post-increment / Post-decrement**
   - `x++`
   - `x--`
2. **Pre-increment / Pre-decrement**
   - `++x`
   - `--x`

Both perform the same change to the variable, but they differ in **when** the change happens in an expression.

------

## **1. Basic Meaning**

### **1.1 Increment**

```
x++   or   ++x
```

Both mean:
 **Increase the value of x by 1.**

Example:

```
int x = 5;
x++;   // x becomes 6
++x;   // x becomes 7
```

### **1.2 Decrement**

```
x--   or   --x
```

Both mean:
 **Decrease the value of x by 1.**

------

## **2. Post-Increment vs Pre-Increment**

This is the most important part.

### **2.1 Post-Increment (x++)**

Meaning:
 **Use the current value first, then increment it.**

Example:

```
int x = 5;
int y = x++;
```

Step-by-step:

1. Assign `x` to `y` â†’ `y = 5`
2. Then increment `x` â†’ `x = 6`

Result:

```
x = 6
y = 5
```

------

### **2.2 Pre-Increment (++x)**

Meaning:
 **Increment first, then use the new value.**

Example:

```
int x = 5;
int y = ++x;
```

Steps:

1. Increment `x` â†’ `x = 6`
2. Then assign to `y` â†’ `y = 6`

Result:

```
x = 6
y = 6
```

------

## **3. How They Work Inside Expressions**

Consider:

```
a = 2
b = 5
x = 4
```

### **Using post-increment**

```
c = a * x++ + b;
```

Order of operations:

1. Multiplication happens first
2. Use `x` (current value = 4)
3. After using, increment x â†’ becomes 5
4. Then add b

So:

```
c = 2 * 4 + 5
c = 13
x = 5
```

------

### **Using pre-increment**

```
c = a * ++x + b;
```

Steps:

1. Increment x â†’ x becomes 5
2. Multiply
3. Add b

So:

```
c = 2 * 5 + 5
c = 15
x = 5
```

Pre vs Post changes the **value used** in the expression.

------

## **4. Increment on Different Data Types**

### **4.1 Float**

```
float x = 5.3f;
x++;          // x = 6.3f
```

âœ” Works perfectly.

------

### **4.2 Byte**

```
byte b = 4;
b++;          // b = 5  (still byte)
```

âœ” Still byte (no promotion to int)

Because we modify the value inside the same variable.

------

### **4.3 Char**

```
char c = 'A';   // Unicode 65
c++;            // becomes 66 â†’ 'B'
```

Printing gives:

```
B
```

âœ” Incrementing a char moves to the next Unicode character.

------

### **4.4 Boolean**

```
boolean flag = true;
flag++;   // âŒ NOT allowed
flag--;   // âŒ NOT allowed
```

âœ” Boolean does not support increment/decrement.

------

# âœ” Final Summary

| Operator | Meaning        | When Increment Happens |
| -------- | -------------- | ---------------------- |
| `x++`    | Post-increment | After using the value  |
| `++x`    | Pre-increment  | Before using the value |
| `x--`    | Post-decrement | After using the value  |
| `--x`    | Pre-decrement  | Before using the value |

**Allowed on:** int, long, float, double, byte, short, char
 **Not allowed on:** boolean

------

# **ğŸ“˜Bitwise Operators â€“ Complete Concept Map (Simplified Notes)**

Computers work internally using **bits (0 and 1)**.
 Bitwise operators allow operations on these **individual bits**.
 They are **faster** than arithmetic or logical operations, and can make programs more efficient.

# **1. Bitwise Operators in Java**

Java provides the following bitwise operators:

| Operator             | Name                   | Java Symbol |
| -------------------- | ---------------------- | ----------- |
| AND                  | Bitwise AND            | `&`         |
| OR                   | Bitwise Inclusive OR   | ` |`          |
| XOR                  | Bitwise Exclusive OR   | `^`         |
| NOT                  | Bitwise Complement     | `~`         |
| Left Shift           | Shift bits to the left | `<<`        |
| Right Shift          | Signed right shift     | `>>`        |
| Unsigned Right Shift | Zero-fill right shift  | `>>>`       |

------

## **2. Truth Tables (Very Important)**

Bitwise operators work on **each pair of bits**.

### **2.1 AND (`&`)**

| A    | B    | A & B |
| ---- | ---- | ----- |
| 0    | 0    | 0     |
| 0    | 1    | 0     |
| 1    | 0    | 0     |
| 1    | 1    | 1     |

âœ” Output is 1 **only when both bits are 1**

------

### **2.2 OR (`|`)**

| A    | B    | A \| B |
| ---- | ---- | ------ |
| 0    | 0    | 0      |
| 0    | 1    | 1      |
| 1    | 0    | 1      |
| 1    | 1    | 1      |

âœ” Output is 1 **if any bit is 1**

------

### **2.3 XOR (`^`)**

| A    | B    | A ^ B |
| ---- | ---- | ----- |
| 0    | 0    | 0     |
| 0    | 1    | 1     |
| 1    | 0    | 1     |
| 1    | 1    | 0     |

âœ” Output is 1 **only when bits are different**
 âœ” Also called **exclusive OR**

------

## **3. Important Rules**

- Bitwise operations can be performed only on **integer types**
   (`byte`, `short`, `int`, `long`, `char`)
- Not allowed on: **float**, **double**, **boolean**
- If you operate on `byte`/`short`, Java **converts them to int** internally.

------

## **4. Example with AND, OR, XOR**

Given:

```
X = 10
Y = 6
```

Binary (8-bit sample for understanding):

```
10 â†’ 00001010
 6 â†’ 00000110
```

------

### **4.1 Bitwise AND: `X & Y`**

```
00001010
00000110
---------
00000010
```

`00000010` in decimal = **2**

âœ” So, `10 & 6 = 2`

------

### **4.2 Bitwise OR: `X | Y`**

```
00001010
00000110
---------
00001110
```

`00001110` in decimal = **14**

âœ” So, `10 | 6 = 14`

------

### **4.3 Bitwise XOR: `X ^ Y`**

```
00001010
00000110
---------
00001100
```

`00001100` in decimal = **12**

âœ” So, `10 ^ 6 = 12`

------



#  **ğŸ“˜Bitwise Operators (Part 2 â€“ Shifts, Sign Handling, NOT Operator)**

# **4. Left Shift Operator (`<<`)**

### **Usage:**

```
z = x << n;
```

Shifts the bits of **x** to the **left** by **n positions**.
 New empty positions are always filled with **0**.

------

## **Example**

Let:

```
x = 10
Binary (1 byte): 00001010
```

### **Left shift by 1**

```
00001010 << 1
= 00010100
```

Decimal value:

```
16 + 4 = 20
```

âœ” So **10 << 1 = 20**

------

## â­ Key Rule (Very Important)

Left shift multiplies the number by a power of 2:

```
x << k  =  x * (2^k)
```

Examples:

- `x << 1` â†’ multiply by 2
- `x << 2` â†’ multiply by 4
- `x << 3` â†’ multiply by 8

------

## **5. Right Shift Operator (`>>`)**

(This is **signed** right shift)

### **Usage:**

```
z = x >> n;
```

Shifts bits to the **right**, **preserving the sign bit** (MSB).
 This is also called **arithmetic right shift**.

Leading spaces are filled with:

- `0` for positive numbers
- `1` for negative numbers

------

## Example

```
x = 10  
Binary: 00001010
```

### Right shift by 1:

```
00001010 >> 1
= 00000101
```

Decimal:
 `4 + 1 = 5`

âœ” So **10 >> 1 = 5**

------

### â­ Key Rule

Right shift divides the number by powers of 2:

```
x >> k  =  x / (2^k)   (integer division)
```

Examples:

- `10 >> 1 = 5`
- `10 >> 2 = 2`
- `10 >> 3 = 1`

------

## **6. Unsigned Right Shift (`>>>`)**

This is the **zero-fill right shift**.

### **Usage:**

```
z = x >>> n;
```

âœ” Always fills empty left bits with **0**
 âœ” Does **not** preserve sign
 âœ” Converts negative binary patterns into positive numbers

------

## Example with a Negative Number

```
x = -10
```

Negative numbers are stored in **2â€™s complement**.

### Step 1 â€” Find binary of +10

```
00001010
```

### Step 2 â€” 1â€™s complement

```
11110101
```

### Step 3 â€” Add 1 â†’ 2â€™s complement (-10)

```
11110110
```

Now perform unsigned right shift by 1:

```
11110110 >>> 1
= 01111011
```

Decimal value:

```
64 + 32 + 16 + 8 + 2 + 1 = 123
```

âœ” **-10 >>> 1 = 123**
 (Because unsigned shift **removes the sign bit**)

------

## â­ Difference: `>>` vs `>>>`

| Operator | Meaning              | Sign Bit  | Fills With           |
| -------- | -------------------- | --------- | -------------------- |
| `>>`     | Signed right shift   | Preserved | 0 for +ve, 1 for -ve |
| `>>>`    | Unsigned right shift | Lost      | Always 0             |

------

## **7. Bitwise NOT (`~`)**

### **Usage:**

```
z = ~x
```

This flips **every bit** (1 â†’ 0, 0 â†’ 1)

------

## Example

```
x = 10
Binary: 00001010
```

Perform NOT:

```
~00001010
= 11110101
```

This is a negative number (because MSB = 1).

### Convert to decimal:

1. 1â€™s complement

   ```
   00001010
   ```

2. Add 1

   ```
   00001011  =  11
   ```

So:

```
~10 = -11
```

### âœ” General Rule

```
~x = -(x + 1)
```

Examples:

- `~0 = -1`
- `~1 = -2`
- `~5 = -6`
- `~10 = -11`

------

## **8. Key Takeaways / Exam Summary**

### Bitwise Operators

- `&` â†’ Both bits 1 â†’ 1
- `|` â†’ Any bit 1 â†’ 1
- `^` â†’ Bits different â†’ 1
- `~` â†’ Flips all bits

### Shifts

- `<<` â†’ Multiply by `2^k`
- `>>` â†’ Divide by `2^k` (keeps sign)
- `>>>` â†’ Zero-fill right shift (loses sign)

### Negative Numbers

Always stored in **2â€™s complement**

------

# **Learning Objectives**

* Perform bitwise **AND**, **OR**, **XOR**, **NOT**, and **shift** operations in Java.
* Understand how binary literals (`0b...`) behave and how they map to decimal.
* Predict results of bitwise operations before running the code.
* Understand how Java handles **negative numbers**, **shifts**, and **twoâ€™s complement**.
* Display the **bit pattern** of integers using `Integer.toBinaryString()`.
* Analyze how assignment shifts (`>>=`, `<<=`, `>>>=`) modify both value and sign bits.

---

# **Key Concepts**

* **Binary Literals (`0b1010`)**: A direct way to assign integers in binary form.
* **AND (`&`)**: Bit-by-bit comparison â†’ 1 only if both bits are 1.
* **OR (`|`)**: Bit-by-bit â†’ 1 if at least one bit is 1.
* **XOR (`^`)**: Bit-by-bit â†’ 1 if bits differ.
* **NOT (`~`)**: Flips every bit â†’ result = `-(n + 1)`.
* **Left Shift (`<<`)**: Moves bits left, inserts 0 â†’ multiply by 2â¿.
* **Right Shift (`>>`)**: Moves bits right, sign bit preserved â†’ divide by 2â¿ with sign.
* **Unsigned Right Shift (`>>>`)**: Moves bits right, fills left with 0 â†’ result always non-negative.
* **Twoâ€™s Complement**:
  Used for negative numbers: invert bits â†’ add 1.
* **Displaying Bit Patterns**:
  `Integer.toBinaryString(x)` prints full bit representation.

---

# **Structured Explanation**

## **1. Bitwise AND (`&`)**

Example:

```
X = 10  â†’ 1010
Y =  6  â†’ 0110
X & Y   â†’ 0010 = 2
```

Only positions where both bits are `1` remain `1`.

You can also write:

```java
int x = 0b1010;
int y = 0b0110;
int z = x & y;   // 2
System.out.println(String.format("%s", Integer.toBinaryString(z)));
```

---

## **2. Bitwise OR (`|`)**

```
1010
0110
----
1110 = 14
```

---

## **3. Bitwise XOR (`^`)**

```
1010
0110
----
1100 = 12
```

XOR is 1 only when bits differ.

---

## **5. Left Shift (`<<`)**

Shifts bits to the left and fills right side with 0.
Equivalent to multiplying by **2â¿**.

Examples:

* `1 << 1 = 2`
* `8 << 1 = 16`
* `8 << 2 = 32`

In code:

```java
int x = 8;
int y = x << 1;   // 16
int y = x << 2;   // 32
```

---

## **6. Right Shift (`>>`) (Arithmetic)**

Right shift preserves **sign bit**.

Example:
 
```
8  â†’  00001000
8>>1 â†’ 00000100 = 4
```

With negative numbers:

```
-10 (binary: 11110110)
-10 >> 1 â†’ 11111011 = -5
```

Sign bit (1) stays, so result remains negative.

---

## **7. Unsigned Right Shift (`>>>`)**

Shifts bits right and fills left side with **0**.

Example:

```
-10 >>> 1 â†’ very large positive integer
```

Reason: the sign bit is discarded.

```java 
int x = -0b1010;
int y = x>>>1 ;

System.out.println(String.format("%s", Integer.toBinaryString(x)));
System.out.println(String.format("%32s", Integer.toBinaryString(y)));
```
---

## **8. Viewing Bit Patterns**

Java utility:

```java
Integer.toBinaryString(value);
```

Example:

```java
System.out.println(Integer.toBinaryString(x));
System.out.println(Integer.toBinaryString(y));
```

For `-5`, it prints all 32 bits of the twoâ€™s complement form.

---

## **9. Shift with Assignment (`>>=` , `<<=` , `>>>=`)**

Example:

```java
y >>= 1;
```

This modifies the variable in-place and shifts its bits.

Demonstration shows how the sign bit or zero gets inserted and how the binary pattern changes.

---

## **10. Bitwise NOT (`~`)**

Flips all bits.

Example with X = 10:

```
X =  00000000000000000000000000001010
~X = 11111111111111111111111111110101
```

Decimal result:

```
~10 = -11
```

Rule:

```
~n = -(n + 1)
```

---

# **Summary**

* Bitwise operations use binary representation to compute AND, OR, XOR, NOT.
* Shifts move bits and change numeric values:

  * left shift multiplies,
  * right shift divides,
  * unsigned right shift clears sign.
* Negative numbers use twoâ€™s complement, so their bit patterns begin with `1`.
* `Integer.toBinaryString()` helps visualize bit patterns.
* Practicing with different numbers builds intuition for how bits move and flip.

---

## **Practical Applications**

* Writing efficient low-level code (crypto, compression).
* Manipulating permission flags and masks.
* Fast arithmetic optimizations.
* Checking parity, toggling bits, and clearing bits.
* Embedded systems and device-driver logic.

---

# **Self-Assessment Questions**

1. What is the binary result of `0b1010 & 0b0110`?
2. Predict the value of `0b1010 | 0b0110`.
3. What does XOR (`^`) represent logically?
4. Why does `8 << 2` produce `32`?
5. What happens to the sign bit in `>>`?
6. Why does `-10 >>> 1` become a large positive number?
7. What is the result of `~6`?
8. How does `Integer.toBinaryString(-5)` differ from `Integer.toBinaryString(5)`?
9. What is the decimal equivalent of `~10`?
10. Why is practicing bitwise operations on paper helpful before coding?

---

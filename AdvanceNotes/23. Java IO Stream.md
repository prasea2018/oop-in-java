
# **ðŸ“˜ Java Streams**

### **Topic: Introduction to Java I/O and Stream Concepts**

---

## **ðŸŽ¯ Learning Objectives**

By the end of this lesson, you should be able to:

1. Define what Input and Output (I/O) mean in Java.
2. Understand how a Java program interacts with external resources.
3. Explain what a stream is and why Java uses streams for I/O.
4. Understand the role and necessity of buffers in data transfer.
5. Describe how data moves between programs and resources (byte-by-byte flow).
6. Know the two major categories of Java I/O classes (Byte Streams & Character Streams).

---

## **1ï¸âƒ£ What is Input/Output (I/O)?**

### **Input**

Data **coming INTO** the Java program
Examples:

* Keyboard input
* Reading from a file
* Receiving data over the network

### **Output**

Data **going OUT** of the Java program
Examples:

* Printing to the monitor
* Writing to a file
* Sending data over the network

---

## **2ï¸âƒ£ Java Program Memory Context (Simplified JVM Memory Model)**

A Java program operates inside its own memory sections:

| Memory Area     | Purpose                                              |
| --------------- | ---------------------------------------------------- |
| **Method Area** | Contains class-level data, static members, bytecode. |
| **Stack**       | Stores local variables & function call frames.       |
| **Heap**        | Stores objects created by `new`.                     |

Everything **outside** Method Area + Stack is considered a **resource**:

* File system
* Keyboard
* Monitor
* Network program
* Heap object (in some explanations)

A Java program communicates with these resources by **transferring data** â†’ This is where **I/O** comes in.

---

## **3ï¸âƒ£ What is a Stream?**

### **Stream = Flow of Data**

Data flows either:

* **From resource â†’ program (Input Stream)**
* **From program â†’ resource (Output Stream)**

### Analogy:

Water flowing through a pipe = data flowing through a stream.

### Example:

Typing keys â†’ `A`, `S`, `D`
Each character travels as a stream of bytes from keyboard â†’ program.

---

## **4ï¸âƒ£ Why is it called â€œStreamâ€?**

Because data flows **continuously**, like water:

* Keyboard â†’ program
* Program â†’ file
* Program â†’ remote server
* File â†’ program

Java treats all these as **streams of bytes/characters**.

---

## **5ï¸âƒ£ Important Concept #1 â€” Buffer**

### **What is a Buffer?**

A **temporary memory storage** used to handle speed differences between:

* Sender and receiver
* Program and file
* Client and server

### **Why Buffer is Required?**

Because sender and receiver rarely operate at the **same speed**.

### Real-world example:

You throw tennis balls one-by-one.
If you throw too fast â†’ receiver drops them.
If too slow â†’ receiver wastes time.

So you place balls in a bucket first (buffer).

### Software example:

Watching videos online â†’ â€œBufferingâ€¦â€
The player stores upcoming video data in a buffer so playback is smooth.

### In Java I/O:

* Program writes data to a **buffer** â†’ Disc writes slowly.
* File loads data to a **buffer** â†’ Program reads when buffer is ready.

Buffer = smoother performance + efficient data transfer.

---

## **6ï¸âƒ£ Important Concept #2 â€” How Data Actually Flows**

Java NEVER sends:

* whole strings
* whole objects
* full numbers

Everything is broken into **bytes**.

#### Example:

String `"John"`

Sent as:

```
J
O
H
N
```

Number `126` is sent as:

```
1
2
6
```

No matter how large the data is, it flows **byte-by-byte**.

---

## **7ï¸âƒ£ Javaâ€™s I/O Class Categories**

Java provides many built-in classes for handling streams.

### **A. Byte Streams**

Used to handle raw binary data (images, files, audio, etc.)

* Input: `InputStream`
* Output: `OutputStream`

Operate on **1 byte** at a time.

---

### **B. Character Streams**

Used for text data (Unicode)

* Input: `Reader`
* Output: `Writer`

Operate on **2 bytes** at a time (Java uses UTF-16 for characters).

---

### Summary Table

| Stream Type          | Unit    | Input Class   | Output Class   |
| -------------------- | ------- | ------------- | -------------- |
| **Byte Stream**      | 1 byte  | `InputStream` | `OutputStream` |
| **Character Stream** | 2 bytes | `Reader`      | `Writer`       |

Learning Java I/O = learning how to use these classes correctly.

---

## **ðŸ“Œ Key Takeaways (Memory Booster)**

* **I/O = Data moving IN or OUT of a program.**
* **Streams = flow of data between program and resources.**
* **Buffer = slows down fast senders or speeds up slow receivers to match speed.**
* **All data travels byte-by-byte, even characters.**
* Java has:

  * **Byte Streams:** `InputStream`, `OutputStream`
  * **Character Streams:** `Reader`, `Writer`

---

## **ðŸ“ Self-Assessment Questions**

### **Conceptual**

1. Why canâ€™t a Java program interact directly with resources like files or keyboards?
2. What is the difference between Input and Output in Java?
3. Define a stream in your own words.
4. Why does Java provide separate classes for byte streams and character streams?
5. What problem does a buffer solve?

### **Multiple Choice**

**1. Which is TRUE about buffers?**
A. They speed up slow devices
B. They slow down fast devices
C. They match data transfer speeds
D. All of the above âœ”ï¸

**2. Which Java class handles character input?**
A. InputStream
B. Reader âœ”ï¸
C. Writer
D. ByteArrayStream

**3. Data is transferred in I/O as:**
A. Whole strings
B. Whole objects
C. Bytes âœ”ï¸
D. Packets


---

# **ðŸ“˜Java I/O â€” InputStream & OutputStream**

These are the **base classes** for all byte streams in Java. Understanding these thoroughly makes learning their subclasses much easier.

---

## **1ï¸âƒ£ InputStream â€” Reading Data INTO Program**

Represents:
**Resource â†’ InputStream â†’ Program**

### **Common Resources**

* File
* Keyboard
* Network socket
* Byte array

---

### **1.1 Methods of InputStream**

| Method                                       | Description                                        | Example / Notes                        | Usage Frequency |
| -------------------------------------------- | -------------------------------------------------- | -------------------------------------- | --------------- |
| `int read()`                                 | Reads 1 byte from stream                           | Returns byte as int, -1 if end reached | Very common     |
| `int read(byte[] b)`                         | Reads bytes into array `b`                         | Reads up to `b.length` bytes at once   | Very common     |
| `int read(byte[] b, int offset, int length)` | Reads into part of array                           | Custom start index and length          | Less common     |
| `int available()`                            | Returns number of bytes available without blocking | Useful for array allocation            | Common          |
| `long skip(long n)`                          | Skips/discards `n` bytes from stream               | Bytes are removed from resource        | Rare            |
| `void mark(int limit)`                       | Marks current position in stream                   | Requires buffered stream               | Rare            |
| `void reset()`                               | Returns to the mark                                | Works only if mark supported           | Rare            |
| `boolean markSupported()`                    | Checks if mark/reset is supported                  | Only buffered streams support it       | Rare            |
| `void close()`                               | Closes the stream                                  | Releases resources                     | Very important  |

**Key Points**

* Reading **consumes** bytes.
* `mark/reset` allows revisiting a position in the stream (only buffered streams).
* Always **close** the stream after use.

---

## **2ï¸âƒ£ OutputStream â€” Writing Data FROM Program**

Represents:
**Program â†’ OutputStream â†’ Resource**

### **Common Resources**

* File
* Console
* Network socket

---

### **2.1 Methods of OutputStream**

| Method                                         | Description                      | Example / Notes                     | Usage Frequency       |
| ---------------------------------------------- | -------------------------------- | ----------------------------------- | --------------------- |
| `void write(int b)`                            | Writes 1 byte to stream          | Loop to write multiple bytes        | Common                |
| `void write(byte[] b)`                         | Writes full byte array           | Sends all bytes at once             | Very common           |
| `void write(byte[] b, int offset, int length)` | Writes part of byte array        | Custom start and length             | Less common           |
| `void flush()`                                 | Forces buffered data to resource | Works only with buffered streams    | Important if buffered |
| `void close()`                                 | Closes the stream                | Automatically flushes buffered data | Very important        |

**Key Points**

* `flush()` pushes data from buffer to resource immediately.
* Always **close** the stream to free resources.

---

## **3ï¸âƒ£ Summary**

* InputStream and OutputStream are **abstract base classes**; direct use is rare.
* Subclasses like `FileInputStream`, `BufferedInputStream`, `FileOutputStream`, `BufferedOutputStream` are used in practice.
* **Most important methods to remember**:

  * InputStream: `read()`, `read(byte[])`, `available()`, `close()`
  * OutputStream: `write()`, `flush()`, `close()`
* Optional / rare methods: `mark()`, `reset()`, `skip()`, `markSupported()`

---

âœ… Understanding these two classes is **enough to handle all byte stream subclasses** in Java.

---

# **ðŸ“˜java.io Class - Java Stream, Reader, and Writer Classes**

Java provides several **stream and character-handling classes**. Understanding their hierarchy helps in knowing which class to use for which purpose.

---

## **1ï¸âƒ£ Base Class**

* **`Object`** â€” Topmost class; parent of all Java classes.

---

## **2ï¸âƒ£ Byte Stream Classes (InputStream & OutputStream)**

### **InputStream Hierarchy**

* **Purpose:** Read **byte-type data** into a program.
* **Common Classes:**

  1. `ByteArrayInputStream` â€“ Reads data from a byte array.
  2. `FileInputStream` â€“ Reads data from a file.
  3. `FilterInputStream` â€“ Adds extra functionality to streams.

     * `BufferedInputStream` â€“ Adds buffering for speed.
     * `DataInputStream` â€“ Reads Java primitive data types.
  4. `LineNumberInputStream` â€“ Reads bytes with line numbers.
  5. `PushbackInputStream` â€“ Allows bytes to be "pushed back" into the stream.
  6. `ObjectInputStream` â€“ Reads serialized objects.
  7. `PipedInputStream` â€“ Connects to `PipedOutputStream` for piping data.
  8. `SequenceInputStream` â€“ Reads from multiple InputStreams sequentially.
  9. `StringBufferInputStream` â€“ Reads data from a String.

---

### **OutputStream Hierarchy**

* **Purpose:** Write **byte-type data** from a program to a resource.
* **Common Classes:**

  1. `ByteArrayOutputStream` â€“ Writes data into a byte array.
  2. `FileOutputStream` â€“ Writes data into a file.
  3. `FilterOutputStream` â€“ Adds extra functionality to streams.

     * `BufferedOutputStream` â€“ Uses buffering.
     * `DataOutputStream` â€“ Writes primitive Java data types.
     * `PrintStream` â€“ Used for printing (e.g., `System.out.println`).
  4. `ObjectOutputStream` â€“ Writes serialized objects.
  5. `PipedOutputStream` â€“ Connects to `PipedInputStream`.

**Tip:** Most InputStream classes have a corresponding OutputStream class.

---

## **3ï¸âƒ£ Character Stream Classes (Reader & Writer)**

* **Purpose:** Handle **character-type data** (supports Unicode; 2 bytes per char).

### **Reader Hierarchy**

* `Reader` â€“ Base class for character input.

  * `BufferedReader` â€“ Adds buffering.
  * `CharArrayReader` â€“ Reads from a character array.
  * `FilterReader` â€“ Adds filtering functionality.
  * `InputStreamReader` â€“ Converts byte stream to character stream.
  * `PushbackReader` â€“ Allows characters to be "pushed back".
  * `PipedReader` â€“ Connects to `PipedWriter`.

### **Writer Hierarchy**

* `Writer` â€“ Base class for character output.

  * `BufferedWriter` â€“ Adds buffering.
  * `CharArrayWriter` â€“ Writes into a character array.
  * `OutputStreamWriter` â€“ Converts character stream to byte stream.
  * `FilterWriter` â€“ Adds filtering functionality.
  * `PipedWriter` â€“ Connects to `PipedReader`.
  * `PrintWriter` â€“ Provides convenient printing methods.
  * `StringWriter` â€“ Writes into a String.

---

## **4ï¸âƒ£ Other Useful Classes**

1. **`StreamTokenizer`** â€“ Tokenizes strings.
2. **`RandomAccessFile`** â€“ Allows random access to file contents.

---

## **5ï¸âƒ£ Exceptions in Stream/Reader/Writer Classes**

* Most methods throw **`IOException`**, which is the base class for:

  * `EOFException`
  * `FileNotFoundException`
  * `ObjectStreamException`
  * `InterruptedIOException`
* **Tip:** For simplicity, you can catch the general `Exception` while practicing.

---

## **6ï¸âƒ£ Key Takeaways**

* Byte streams (`InputStream`/`OutputStream`) â†’ Handle raw bytes.
* Character streams (`Reader`/`Writer`) â†’ Handle characters (Unicode-aware).
* Subclasses provide:

  * Buffering (`BufferedReader/BufferedInputStream`)
  * Object serialization (`ObjectInputStream/ObjectOutputStream`)
  * Piping (`PipedReader/PipedWriter`)
  * Print convenience (`PrintWriter/PrintStream`)
* If you remember **InputStream classes**, you can infer the corresponding OutputStream classes easily.
* Important practical classes: `FileInputStream`, `FileOutputStream`, `BufferedReader`, `BufferedWriter`, `PrintWriter`, `ObjectInputStream/ObjectOutputStream`.


---

# **ðŸ“˜Java File I/O: FileOutputStream**

## **1ï¸âƒ£ Purpose**

* **`FileOutputStream`** â†’ Used to **write bytes** to a file.
* **`FileInputStream`** â†’ Used to **read bytes** from a file.

**Scenario in Video:**

1. Create a file `Test.txt`.
2. Write content into it using `FileOutputStream`.
3. Later, read from it using `FileInputStream` (explained in next video).

---

## **2ï¸âƒ£ Writing to a File Using FileOutputStream**

### **Steps:**

1. **Import necessary classes:**

```java
import java.io.FileOutputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
```

2. **Create FileOutputStream object:**

```java
FileOutputStream fos = new FileOutputStream("C:/MyJava/Test.txt");
```

* Use **forward slashes** (`/`) in the path.
* If the file is in the same directory as your `.class` file, just use the filename.

3. **Handle Exceptions:**

* `FileNotFoundException` â†’ if the file cannot be created.
* `IOException` â†’ general I/O errors.

```java
try {
    // File writing code
} catch (FileNotFoundException e) {
  e.printStackTrace();
} catch (IOException e) {
  e.printStackTrace();
}
```

---

### **Writing a String to a File**

* Convert a string to a **byte array**:

```java
String str = "Learn Java Programming";
byte[] b = str.getBytes(); // Convert string to bytes
fos.write(b); // Write all bytes at once
```

* **Writing byte by byte**:

```java
for (byte x : b) {
    fos.write(x);
}
```

* **Writing with offset** (write only a part of the array):

```java
int offset = 6; // start from index 6
int length = str.length() - 6;
fos.write(b, offset, length); // writes only "Java Programming"
```

---

## **3ï¸âƒ£ Closing the File**

* Always **close the stream** to release resources:

```java
fos.close();
```

* Alternative: **try-with-resources** (recommended):

```java
try (FileOutputStream fos = new FileOutputStream("C:/MyJava/Test.txt")) {
  fos.write(str.getBytes());
} catch (IOException e) {
  e.printStackTrace();
}
```

* Automatically closes the stream at the end of the block.

---

## **4ï¸âƒ£ Key Points**

* `FileOutputStream.write()` has **three forms**:

  1. `write(int b)` â†’ writes one byte.
  2. `write(byte[] b)` â†’ writes entire byte array.
  3. `write(byte[] b, int offset, int length)` â†’ writes part of the byte array.
* You can write **all bytes at once** or **byte by byte**.
* **Try-with-resources** simplifies code and avoids manual closing.

---

## **5ï¸âƒ£ Next Steps**

* Reading from a file using **FileInputStream** will be covered in the next video.
* Concepts will be similar:

  * Create a `FileInputStream` object.
  * Use `read()` methods to fetch bytes.
  * Handle exceptions.
  * Close the stream (or use try-with-resources).

---

âœ… **Summary:**

* **FileOutputStream** is for **writing bytes** to a file.
* Convert **Strings â†’ bytes** using `.getBytes()`.
* Use **try-with-resources** for clean code.
* Offset allows writing **part of data**.
* Always **close streams** to free resources.


---

# **ðŸ“˜Java File I/O: FileInputStream & FileReader**

## **1ï¸âƒ£ Purpose**

* **FileInputStream** â†’ Used to **read bytes** from a file.
* Similar to FileOutputStream, but for **input**.

---

## **2ï¸âƒ£ Reading a File**

### **Step 1: Import Required Classes**

```java
import java.io.FileInputStream;
import java.io.IOException;
```

### **Step 2: Open the File Using Try-With-Resources**

```java
try (FileInputStream fis = new FileInputStream("C:/MyJava/Test.txt")) {
  // Reading logic
} catch (IOException e) {
  e.printStackTrace();
}
```

---

### **Step 3: Reading Methods**

#### **A. Read All Bytes at Once**

```java
byte[] b = new byte[fis.available()]; // allocate array of file size
fis.read(b); // read all bytes into array
String str = new String(b); // convert bytes to String
System.out.println(str);
```

**Explanation:**

* `fis.available()` â†’ returns number of bytes available in the file.
* `fis.read(byte[] b)` â†’ reads all bytes into the array.
* Convert byte array â†’ String â†’ print.

---

#### **B. Read Byte by Byte**

```java
int x;
while ((x = fis.read()) != -1) { // read each byte until EOF (-1)
  System.out.print((char)x);    // convert byte to character and print
}
```

**Explanation:**

* `fis.read()` â†’ reads **one byte** and returns its ASCII value.
* Returns **-1** when the end of file (EOF) is reached.
* Print each byte as a character.

> âœ… Alternative with do-while loop also works, but `while` loop is cleaner.

---

### **Step 4: Using FileReader Instead of FileInputStream**

* Works **similarly**, but handles **characters** instead of bytes.

```java
FileReader fr = new FileReader("C:/MyJava/Test.txt");
int x;
while ((x = fr.read()) != -1) {
  System.out.print((char)x);
}
fr.close();
```

* Only minor changes: `FileInputStream â†’ FileReader`
* Reading logic remains the same.

---

## **3ï¸âƒ£ Key Points**

1. **FileInputStream vs FileReader**

   * `FileInputStream` â†’ reads **bytes**.
   * `FileReader` â†’ reads **characters** (Unicode-friendly).

2. **Reading Options**

   * **All bytes at once** â†’ `read(byte[] b)`
   * **Byte by byte** â†’ `read()`
   * Use **available()** to allocate array size if reading all bytes at once.

3. **EOF Handling**

   * `read()` returns `-1` at the end of file.

4. **Try-with-Resources**

   * Automatically closes the file â†’ no need for explicit `close()`.

---

## **4ï¸âƒ£ Next Steps**

* FileWriter works similarly to FileOutputStream.
* Using FileReader/FileWriter â†’ same logic as FileInputStream/FileOutputStream but works with **characters**.

---

âœ… **Summary:**

* **FileInputStream** â†’ reads bytes.
* **FileReader** â†’ reads characters.
* Two reading styles: **all bytes at once** or **byte-by-byte**.
* Always use **EOF (-1)** to terminate loops.
* Try-with-resources simplifies exception handling and closes the file automatically.

---


# **ðŸ“˜Java File I/O Challenge - Copy a File**

## **Task 1: Copy a File and Convert Uppercase to Lowercase**

**Goal:**

* Read from `Source1.txt` (all uppercase letters)
* Write to `Source2.txt` (convert letters to lowercase)

### **Code Example**

```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class CopyToLowerCase {
  public static void main(String[] args) throws IOException {
    FileInputStream fis = new FileInputStream("Source1.txt");
    FileOutputStream fos = new FileOutputStream("Source2.txt");

    int b;
    while ((b = fis.read()) != -1) {
      // Convert uppercase letters (ASCII 65-90) to lowercase
      if (b >= 65 && b <= 90) {
        b += 32;
      }
      fos.write(b);
    }

    fis.close();
    fos.close();
    System.out.println("File copied with lowercase conversion.");
  }
}
```

**Key Points:**

* FileInputStream reads bytes from a file.
* FileOutputStream writes bytes to a file.
* ASCII conversion: `A-Z` (65â€“90) â†’ add 32 â†’ `a-z` (97â€“122).
* Non-alphabet characters remain unchanged.

---

## **Task 2: Combine Two Files into One Using SequenceInputStream**

**Goal:**

* Read from `Source1.txt` and `Source2.txt`
* Write both contents sequentially into `Destination.txt`

### **Code Example**

```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.SequenceInputStream;
import java.io.IOException;

public class CombineFiles {
  public static void main(String[] args) throws IOException {
    FileInputStream fis1 = new FileInputStream("Source1.txt");
    FileInputStream fis2 = new FileInputStream("Source2.txt");
    FileOutputStream fos = new FileOutputStream("Destination.txt");

    SequenceInputStream sis = new SequenceInputStream(fis1, fis2);

    int b;
    while ((b = sis.read()) != -1) {
      fos.write(b);
    }

    sis.close();
    fos.close();
    fis1.close();
    fis2.close();
    System.out.println("Files combined into Destination.txt.");
  }
}
```

**Key Points:**

* `SequenceInputStream` allows reading from multiple streams **sequentially**.
* First stream is read completely, then the second.
* Useful for appending files in order.

---

âœ… **Summary:**

1. **Task 1** â†’ Copy file and convert uppercase letters to lowercase.
2. **Task 2** â†’ Merge two files sequentially using `SequenceInputStream`.
3. Both tasks use **byte streams** (`FileInputStream`, `FileOutputStream`).
4. ASCII values are used for letter conversion.

---

# **ðŸ“˜Buffered Streams & Buffered Reader**

## **1ï¸âƒ£ BufferedInputStream**

**Purpose:**

* Wraps another input stream (like `FileInputStream`) and adds a buffer to improve reading efficiency.
* Supports `mark()` and `reset()`, which lets you read data, go back to a mark, and read again.

**Key Concept:**

* The buffer temporarily stores data from the source stream so your program can access it faster.
* Without buffer, every `read()` would go directly to the source (file), which is slower.

### **Example: Read byte-by-byte**

```java
import java.io.*;

public class BufferedInputStreamDemo {
  public static void main(String[] args) throws IOException {
    FileInputStream fis = new FileInputStream("test.txt");
    BufferedInputStream bis = new BufferedInputStream(fis);

    int x;
    while ((x = bis.read()) != -1) {
      System.out.print((char)x);
    }
    System.out.println();

    // Check mark support
    System.out.println("FileInputStream markSupported: " + fis.markSupported());
    System.out.println("BufferedInputStream markSupported: " + bis.markSupported());

    bis.close();
    fis.close();
  }
}
```

### **Example: Using mark() and reset()**

```java
bis.mark(10);   // mark current position, valid for 10 bytes
System.out.print((char)bis.read()); // read 1 byte
System.out.print((char)bis.read()); // read next byte
bis.reset();    // go back to mark
System.out.print((char)bis.read()); // re-read first byte after mark
```

âœ… **Notes:**

* `mark()` sets a bookmark.
* `reset()` moves the stream back to the mark.
* File streams alone do **not** support mark/reset.

---

## **2ï¸âƒ£ BufferedOutputStream**

**Purpose:**

* Wraps another output stream (like `FileOutputStream`) and adds a buffer to improve writing efficiency.
* Data is first written to the buffer and then flushed to the destination.

### **Example: Write bytes**

```java
FileOutputStream fos = new FileOutputStream("output.txt");
BufferedOutputStream bos = new BufferedOutputStream(fos);

bos.write("Hello Buffered Output Stream".getBytes());
bos.flush();   // send buffered data to file

bos.close();
fos.close();
```

**Key Benefit:**

* Improves performance for large writes.
* Reduces the number of actual write operations to the file/device.

---

## **3ï¸âƒ£ BufferedReader**

**Purpose:**

* Wraps a `Reader` (like `FileReader`) and adds a buffer to read characters efficiently.
* Supports `readLine()` to read entire lines of text.

### **Example: Read line-by-line**

```java
FileReader fr = new FileReader("test.txt");
BufferedReader br = new BufferedReader(fr);

String line;
while ((line = br.readLine()) != null) {
  System.out.println("Read line: " + line);
}

br.close();
fr.close();
```

**Notes:**

* Only works with character streams.
* `readLine()` is unique to buffered readers; byte streams do not have it.
* Useful for reading text files line by line.

---

## **4ï¸âƒ£ BufferedWriter**

**Purpose:**

* Wraps a `Writer` (like `FileWriter`) and adds a buffer to write characters efficiently.
* Can write strings or individual characters to files.

### **Example: Write line-by-line**

```java
FileWriter fw = new FileWriter("output.txt");
BufferedWriter bw = new BufferedWriter(fw);

bw.write("This is a line.");
bw.newLine();  // add newline
bw.write("This is another line.");
bw.flush();    // flush buffer to file

bw.close();
fw.close();
```

---

## **5ï¸âƒ£ Summary Table**

| Class                | Wraps        | Works With | Key Feature                              |
| -------------------- | ------------ | ---------- | ---------------------------------------- |
| BufferedInputStream  | InputStream  | byte       | mark/reset, faster byte reading          |
| BufferedOutputStream | OutputStream | byte       | buffer improves writing efficiency       |
| BufferedReader       | Reader       | char       | readLine(), mark/reset, buffered reading |
| BufferedWriter       | Writer       | char       | buffer improves writing efficiency       |

---

**ðŸ’¡ Key Takeaways:**

1. **Buffered streams/readers/writers** add temporary memory to smooth reading/writing.
2. `mark()` and `reset()` only supported in buffered streams.
3. Use `BufferedReader` for text files when you want to read lines efficiently.
4. Always close streams after use (`close()`), or use **try-with-resources**.

---

# **ðŸ“˜Piped Streams**
## **1ï¸âƒ£ Concept of Piped Streams**

**Purpose:**

* `PipedInputStream` and `PipedOutputStream` are **used for inter-thread communication** in Java.
* A producer thread can write data into a pipe (`PipedOutputStream`), and a consumer thread can read that data from the connected pipe (`PipedInputStream`).

**Key Points:**

* Each thread has its own stream reference.
* Streams must be connected using `connect()` before starting threads.
* Pipes do **not automatically synchronize** threads; producer may run faster than consumer unless you explicitly control it (e.g., `Thread.sleep()`).

**Analogy:**
Think of it as a **water pipe**:

* Producer â†’ pushes water (data) into the pipe
* Consumer â†’ reads water from the pipe

---

## **2ï¸âƒ£ Program Structure**

### **Producer Thread**

```java
import java.io.*;

class Producer extends Thread {
  private PipedOutputStream os;

  Producer(PipedOutputStream o) {
      this.os = o;
  }

  public void run() {
    int count = 1;
    try {
      while(true) {
        System.out.println("Producer is producing: " + count);
        os.write(count);   // write to pipe
        os.flush();        // ensure data is sent
        Thread.sleep(10);  // slow down producer
        count++;
      }
    } catch(Exception e) {}
  }
}
```

### **Consumer Thread**

```java
class Consumer extends Thread {
  private PipedInputStream is;

  Consumer(PipedInputStream s) {
    this.is = s;
  }

  public void run() {
    int x;
    try {
      while(true) {
        x = is.read();    // read from pipe
        System.out.println("Consumer consumed: " + x);
        System.out.flush();
      }
    } catch(Exception e) {}
  }
}
```

---

## **3ï¸âƒ£ Main Method: Connecting Pipes**

```java
public class PipeDemo {
  public static void main(String[] args) throws Exception {
    PipedInputStream pis = new PipedInputStream();
    PipedOutputStream pos = new PipedOutputStream();

    // Connect the pipes
    pis.connect(pos); // or pos.connect(pis);

    // Create Producer and Consumer
    Producer producer = new Producer(pos);
    Consumer consumer = new Consumer(pis);

    // Start threads
    producer.start();
    consumer.start();
  }
}
```

âœ… **Notes:**

* `pis.connect(pos)` links the two streams so data written by Producer is read by Consumer.
* Without `sleep` or inter-thread communication, Producer can outpace Consumer.
* Pipes are designed for **thread-to-thread data transfer** only; cannot be shared across processes.

---

## **4ï¸âƒ£ Key Takeaways**

1. **Piped Streams** are byte-based (like `InputStream`/`OutputStream`).
2. They allow **direct communication between two threads** without an intermediate shared object.
3. Producer writes data using `PipedOutputStream.write()`.
4. Consumer reads data using `PipedInputStream.read()`.
5. **Threads must be synchronized** manually (sleep, wait/notify, or blocking queues).
6. Always connect the streams **before starting the threads**.

---

**ðŸ’¡ Visualization of Data Flow:**

```
Producer Thread
    |
    | write() 
    v
PipedOutputStream
    |
    v
PipedInputStream
    |
    | read()
    v
Consumer Thread
```

---

# **ðŸ“˜Random Access File**
                                                                         
## **1ï¸âƒ£ What are Random Access Files?**

In Java, files can be accessed in **two ways**:

### **A. Sequential Access**

* Works like a **tape recorder**: the file pointer moves **only forward**.
* If reading: after reading a byte, the pointer moves to the next byte.
* If writing: starts at the beginning, overwrites existing data.
* Cannot read or write at arbitrary positions without reopening the file.
* Most commonly used method.

### **B. Random Access**

* Allows moving the file pointer **anywhere in the file**.
* Can **read and write from the same pointer**.
* Pointer movement can be:

  * From the beginning (`seek(position)`)
  * Relative to the current pointer (using `getFilePointer()` + offset)
* Useful when you know the **structure of the file** and want to access or update specific positions.

---

## **2ï¸âƒ£ Java Class for Random Access**

* `java.io.RandomAccessFile`
* Modes:

  * `"r"` â†’ read-only
  * `"rw"` â†’ read and write
* Implements **DataInput** and **DataOutput**:

  * Allows reading/writing **primitive data types** directly:

    ```java
    readInt(), writeInt()
    readFloat(), writeFloat()
    readUTF(), writeUTF()
    ```
* Provides key methods:

  * `seek(long position)` â†’ move pointer to a specific byte
  * `getFilePointer()` â†’ get current pointer position
  * `length()` â†’ get file size

---

## **3ï¸âƒ£ Example Program**

Suppose we have a file `data.txt` with alphabets:

```
A B C D E F G H I J
```

### **Read and Write Using RandomAccessFile**

```java
import java.io.*;

public class RandomAccessDemo {
  public static void main(String[] args) throws Exception {
    RandomAccessFile rf = new RandomAccessFile("data.txt", "rw");

    // Read first three bytes
    System.out.println((char) rf.read()); // A
    System.out.println((char) rf.read()); // B
    System.out.println((char) rf.read()); // C

    // File pointer is now at 4th byte (D)
    rf.write('d'); // Overwrite D with lowercase d

    // Next read will be E
    System.out.println((char) rf.read()); // E

    // Skip 3 bytes (F, G, H)
    rf.skipBytes(3);

    // Pointer is now at I
    System.out.println((char) rf.read()); // I

    // Move pointer to 4th byte (index 3)
    rf.seek(3);
    System.out.println((char) rf.read()); // d

    // Get current file pointer
    System.out.println("Current pointer: " + rf.getFilePointer()); // 4 (points to E)
    
    // Move pointer relative to current
    rf.seek(rf.getFilePointer() + 2); // move forward 2 bytes
    System.out.println((char) rf.read()); // G
  }
}
```

---

## **4ï¸âƒ£ Key Points**

1. **Single pointer** is used for both reading and writing.
2. After every operation, pointer moves forward automatically.
3. You can:

   * Move pointer absolutely: `seek(position)`
   * Move pointer relative to current position: `seek(getFilePointer() + offset)`
   * Skip bytes: `skipBytes(n)`
4. Allows **direct modification of file content** without rewriting the whole file.
5. Supports reading and writing **primitive data types**, not just bytes.

---

## **5ï¸âƒ£ Visual Representation**

```
File: A B C D E F G H I J
Pointer â†’ initially at 0

Read 3 bytes:
Pointer â†’ moves to 3 (D)

Write 'd':
File â†’ A B C d E F G H I J
Pointer â†’ moves to 4 (E)

Skip 3 bytes:
Pointer â†’ moves to 7 (I)

Seek to 3:
Pointer â†’ moves to 3 (d)
```

---

**ðŸ’¡ Summary:**
Random Access Files are powerful when you need **non-sequential reading/writing** and know the fileâ€™s internal structure. They are ideal for **databases, indexed files, or any file requiring frequent updates at specific positions**.

---

# **ðŸ“˜File Class**

## **1ï¸âƒ£ What is the `File` class in Java?**

The **`java.io.File`** class is used to **represent a file or directory** in Java.
It does **not handle the content** of the file but allows you to **access file properties, manage files, and directories**.

---

## **2ï¸âƒ£ Creating a File Object**

```java
import java.io.*;

public class FileDemo {
  public static void main(String[] args) throws Exception {
    // Represent a folder
    File folder = new File("C:\\MyJava");

    // Represent a file
    File file = new File("C:\\MyJava\\Data.txt");
  }
}
```

---

## **3ï¸âƒ£ Key Methods in `File` Class**

### **A. Check File Properties**

| Method          | Description                       |
| --------------- | --------------------------------- |
| `isDirectory()` | Checks if the path is a directory |
| `isFile()`      | Checks if the path is a file      |
| `isAbsolute()`  | Checks if the path is absolute    |
| `canRead()`     | Can the file be read?             |
| `canWrite()`    | Can the file be written?          |
| `canExecute()`  | Can the file be executed?         |
| `isHidden()`    | Checks if the file is hidden      |

---

### **B. File Creation and Deletion**

| Method            | Description                             |
| ----------------- | --------------------------------------- |
| `createNewFile()` | Creates a new empty file                |
| `delete()`        | Deletes the file immediately            |
| `deleteOnExit()`  | Deletes the file when the program exits |

---

### **C. Get File Information**

| Method               | Description                                              |
| -------------------- | -------------------------------------------------------- |
| `getName()`          | Returns the name of the file/folder                      |
| `getPath()`          | Returns the path provided when creating the object       |
| `getAbsolutePath()`  | Returns the absolute path of the file                    |
| `getCanonicalPath()` | Returns the real path (resolves shortcuts)               |
| `getParent()`        | Returns the parent directory                             |
| `length()`           | Returns file size in bytes                               |
| `lastModified()`     | Returns last modified time of the file (in milliseconds) |

---

### **D. Modify File Attributes**

| Method                       | Description                         |
| ---------------------------- | ----------------------------------- |
| `setReadOnly()`              | Make the file read-only             |
| `setWritable(boolean flag)`  | Make the file writable or read-only |
| `setLastModified(long time)` | Change the last modified timestamp  |

---

## **4ï¸âƒ£ Listing Files in a Directory**

```java
File folder = new File("C:\\MyJava");

// List file names as String array
String[] files = folder.list();
for (String f : files) {
  System.out.println(f);
}

// List files as File objects
File[] fileList = folder.listFiles();
for (File f : fileList) {
  System.out.print(f.getName() + " ");
  System.out.println(f.getPath());
}
```

* `list()` â†’ returns **names** of files/folders.
* `listFiles()` â†’ returns **File objects**, so you can get more info like path, type, etc.

---

## **5ï¸âƒ£ Example: Handling Read-Only Files**

```java
File file = new File("C:\\MyJava\\Data.txt");

// Make file read-only
file.setReadOnly();

// Try writing to read-only file
try (FileOutputStream fos = new FileOutputStream(file)) {
  fos.write(65); // 'A'
} catch (Exception e) {
  System.out.println("Error: " + e.getMessage());
}

// Make it writable again
file.setWritable(true);
```

* When a file is **read-only**, writing to it causes a `FileNotFoundException` with â€œAccess is deniedâ€.

---

## **6ï¸âƒ£ Summary**

* The **`File` class** is used to access **file metadata and manage files/directories**, not their content.
* You can:

  * Check properties: `isDirectory()`, `canRead()`, `isHidden()`
  * Create/delete files: `createNewFile()`, `deleteOnExit()`
  * Modify attributes: `setReadOnly()`, `setWritable()`, `setLastModified()`
  * List files in directories: `list()`, `listFiles()`
* Combining `File` with **streams** allows full file manipulation (reading/writing).

---

# **ðŸ“˜Serialisation Storing Data in a File**
---

#12. Serialisation Storing Data in a File **1ï¸âƒ£ The Problem**

You have a class:

```java
class Student {
  int rollNumber;
  String name;
  String department;
}
```

**Goal:**
Store an object of `Student` in a file (`My.txt`) and retrieve it later **exactly as it is**.

**Challenges:**

* How do we store an object in a file?
* How do we read it back and reconstruct the object?
* Can we preserve the data types (int, String) without converting everything to a string?

---

#12. Serialisation Storing Data in a File **2ï¸âƒ£ First Solution: Store Object as Text (Strings)**

**Idea:** Write each property of the object as a string to a file. Read each line and reconstruct the object.

### **Writing the object to file using `PrintStream`:**

```java
import java.io.*;

public class MyWrite {
  public static void main(String[] args) throws Exception {
    FileOutputStream fo = new FileOutputStream("My.txt");
    PrintStream ps = new PrintStream(fo);

    Student s = new Student();
    s.rollNumber = 10;
    s.name = "John";
    s.department = "CSE";

    ps.println(s.rollNumber);   // writes "10" as a string
    ps.println(s.name);         // writes "John"
    ps.println(s.department);   // writes "CSE"

    ps.close();
  }
}
```

### **Reading the object back from file:**

```java
import java.io.*;

public class MyRead {
  public static void main(String[] args) throws Exception {
    FileInputStream fi = new FileInputStream("My.txt");
    BufferedReader br = new BufferedReader(new InputStreamReader(fi));

    Student s = new Student();
    s.rollNumber = Integer.parseInt(br.readLine());  // convert string to int
    s.name = br.readLine();
    s.department = br.readLine();

    System.out.println(s.rollNumber + " " + s.name + " " + s.department);
    br.close();
  }
}
```

---

#12. Serialisation Storing Data in a File **3ï¸âƒ£ Problems with the First Solution**

1. **Data type is lost:**

   * Everything is stored as a string in the file.
   * Even integers or floats are converted to strings.

2. **Manual type conversion needed:**

   * While reading, you must manually parse integers, floats, etc.

3. **Not scalable:**

   * For larger objects with many fields, writing and reading each property manually is tedious.

---

## **4ï¸âƒ£ Goal for the Next Step**

* Store each member of the object in its **own data type** directly.
* Avoid converting integers, floats, etc., to strings.
* Read them back **without type casting**.

**Solution Preview:**
This is where **DataInputStream / DataOutputStream** comes in (second solution).
Eventually, the **third solution is Serialization**, which allows you to **store the whole object in its original form**, and read it back easily.

---

âœ… **Key Concept:** Serialization is basically the process of **writing an object into a file in its entirety** so it can be read back later without losing data types.

---

# **ðŸ“˜PrintStream**

---

## **1ï¸âƒ£ Overview**

The goal is to **store and read an object of a `Student` class** using **text-based file I/O**:

```java
class Student {
  int rollNumber;
  String name;
  String department;
}
```

The demonstration uses **`PrintStream`** for writing and **`BufferedReader`** for reading.

---

## **2ï¸âƒ£ Writing the Object to a File**

**Steps:**

1. Create a `FileOutputStream` to connect to the file:

```java
FileOutputStream fos = new FileOutputStream("MyJava\\Student1.txt");
```

2. Attach a `PrintStream` to it:

```java
PrintStream ps = new PrintStream(fos);
```

3. Create and initialize a `Student` object:

```java
Student s = new Student();
s.rollNumber = 10;
s.name = "John";
s.department = "CSE";
```

4. Write each property using `PrintStream.println()`:

```java
ps.println(s.rollNumber);  // calls println(int)
ps.println(s.name);        // calls println(String)
ps.println(s.department);  // calls println(String)
```

5. Close the streams:

```java
ps.close();
fos.close();
```

âœ… **Result:** The file contains three lines: `"10"`, `"John"`, `"CSE"`.
Note: All values are stored as **strings**, even integers.

---

## **3ï¸âƒ£ Reading the Object from a File**

**Steps:**

1. Create a `FileInputStream`:

```java
FileInputStream fis = new FileInputStream("MyJava\\Student1.txt");
```

2. Wrap it with `InputStreamReader` and `BufferedReader`:

```java
BufferedReader br = new BufferedReader(new InputStreamReader(fis));
```

3. Create an empty `Student` object and read values from the file:

```java
Student s = new Student();
s.rollNumber = Integer.parseInt(br.readLine()); // convert string to int
s.name = br.readLine();                         // string
s.department = br.readLine();                   // string
```

4. Print the values:

```java
System.out.println(s.rollNumber);
System.out.println(s.name);
System.out.println(s.department);
```

âœ… **Output on screen:**

```
10
John
CSE
```

---

## **4ï¸âƒ£ Key Points from the Demonstration**

* **PrintStream** can print various data types (int, String, boolean, etc.) using overloaded `println()` methods.
* `System.out` is actually a `PrintStream` object.
* **BufferedReader** reads everything as a **string**, so you need to parse integers or floats manually.
* This method works, but **data types are lost in storage**, which is a limitation.
* **Serialization** (covered later) solves this problem by storing objects in their original form, preserving types.

---

# **ðŸ“˜Serialisation using DataInput and DataOutput Streams**

## **1ï¸âƒ£ Problem Recap**

* Goal: Store a **`Student` object** in a file.
* **First solution:** Used `PrintStream` â†’ stored everything as **strings**, even integers.
* **Problem with first solution:** Data types are lost. Integers, floats, etc., are converted to strings, requiring parsing when reading.

---

## **2ï¸âƒ£ Second Solution: Using Data Streams**

Instead of storing everything as strings, we store **each property in its own data type**:

* **Integer:** stored as integer
* **String:** stored as string
* **Float/Double:** stored as float/double

This uses **`DataOutputStream`** and **`DataInputStream`**.

---

### **2.1 Writing the Object**

```java
// Open file for writing
FileOutputStream fos = new FileOutputStream("MyJava\\My.txt");

// Attach DataOutputStream
DataOutputStream dos = new DataOutputStream(fos);

// Create Student object
Student s = new Student();
s.rollNumber = 10;
s.name = "John";
s.department = "CSE";

// Write properties in their own types
dos.writeInt(s.rollNumber);  // integer
dos.writeUTF(s.name);        // string
dos.writeUTF(s.department);  // string

// Close streams (good practice)
dos.close();
fos.close();
```

**Notes:**

* `writeInt()` writes an integer in binary format.
* `writeUTF()` writes a string in UTF format (Unicode).
* The file may **not be human-readable** because data is stored in binary format.

---

### **2.2 Reading the Object**

```java
// Open file for reading
FileInputStream fis = new FileInputStream("MyJava\\My.txt");

// Attach DataInputStream
DataInputStream dis = new DataInputStream(fis);

// Create empty Student object
Student s = new Student();

// Read properties in same order and type
s.rollNumber = dis.readInt();
s.name = dis.readUTF();
s.department = dis.readUTF();

// Display
System.out.println(s.rollNumber);
System.out.println(s.name);
System.out.println(s.department);

// Close streams
dis.close();
fis.close();
```

**Important:**

* Must **read in the same order** as written: integer first, then strings.
* Otherwise, data will be corrupted or throw an exception.

---

## **3ï¸âƒ£ Key Advantage Over First Solution**

* Each property retains **its original data type**.
* No need for parsing or type conversion when reading.
* Data is stored in a **binary format**, not plain text.

---

## **4ï¸âƒ£ Remaining Problem**

* Even with `DataOutputStream`, we are still writing **each property individually**.
* Problem: If the `Student` class has many properties, writing and reading them manually becomes tedious.
* **Desired solution:** Store the **entire object** at once and retrieve it â€” without accessing internal members individually.

---

## **5ï¸âƒ£ Next Step**

* **Serialization** solves this problem.
* Using serialization, you can save a **complete object** and read it back as the same object, preserving data types and structure.

---

# **ðŸ“˜Data Streams**
---

## **1ï¸âƒ£ Overview**

* Goal: Store and retrieve a `Student` object in its **own data types** rather than converting everything to strings.
* Streams used:

  * **DataOutputStream** â†’ for writing data
  * **DataInputStream** â†’ for reading data

---

## **2ï¸âƒ£ Writing Data with DataOutputStream**

1. **Create `FileOutputStream`** â†’ connects to a file.

```java
FileOutputStream fos = new FileOutputStream("MyJava\\Student2.txt");
```

2. **Create `DataOutputStream`** â†’ attach to `FileOutputStream`.

```java
DataOutputStream dos = new DataOutputStream(fos);
```

3. **Create Student object** and initialize properties:

```java
Student s = new Student();
s.rollNumber = 10;
s.name = "John";
s.department = "CSE";
s.average = 80.5f; // float property
```

4. **Write properties in their own data types:**

```java
dos.writeInt(s.rollNumber);    // integer
dos.writeUTF(s.name);          // string
dos.writeFloat(s.average);     // float
dos.writeUTF(s.department);    // string
```

5. **Close streams:**

```java
dos.close();
fos.close();
```

**Key Points:**

* Each data type has its own write method: `writeInt`, `writeFloat`, `writeDouble`, `writeUTF`, etc.
* Data is stored in **binary format** â†’ not human-readable.
* Text files are readable because data is converted to strings; binary files are stored in raw bytes.

---

## **3ï¸âƒ£ Reading Data with DataInputStream**

1. **Create `FileInputStream`** â†’ connects to the same file:

```java
FileInputStream fis = new FileInputStream("MyJava\\Student2.txt");
```

2. **Create `DataInputStream`** â†’ attach to `FileInputStream`:

```java
DataInputStream dis = new DataInputStream(fis);
```

3. **Create empty Student object**:

```java
Student s = new Student();
```

4. **Read data in the same order and type as written**:

```java
s.rollNumber = dis.readInt();
s.name = dis.readUTF();
s.average = dis.readFloat();
s.department = dis.readUTF();
```

5. **Print the values**:

```java
System.out.println(s.rollNumber);
System.out.println(s.name);
System.out.println(s.average);
System.out.println(s.department);
```

6. **Close streams:**

```java
dis.close();
fis.close();
```

---

## **4ï¸âƒ£ Important Notes**

* **Order matters:** You **must read in the same order** as written; otherwise:

  * You may get **junk values**
  * Or an **exception** like `EOFException`.
* **Binary vs Text Files:**

  * Text file â†’ human-readable, stored as strings.
  * Binary file â†’ stored in raw bytes, may not be readable in a text editor.
* DataInputStream and DataOutputStream **must be paired**: the same type that writes the data must read it.

---

## **5ï¸âƒ£ Next Step**

* Even with Data Streams, we are still **writing each property individually**.
* What if we want to **save and retrieve the entire object at once**?
* Thatâ€™s where **Serialization** comes in â†’ allows storing the **whole object**.

---


# **ðŸ“˜Serialisation Final**
---

## **1ï¸âƒ£ What is Serialization?**

* **Serialization** is the process of **storing the state of an object** so it can be retrieved later.
* **Deserialization** is the process of **reading that object back** into memory.
* Key idea: You donâ€™t have to store or retrieve individual properties manually. The entire object, with all its data, is saved and restored automatically.

---

## **2ï¸âƒ£ How to Serialize an Object**

1. **Create a `Student` class** (or any class you want to serialize):

```java
import java.io.Serializable;

class Student implements Serializable {
  int rollNumber;
  String name;
  String department;

  // default constructor is mandatory
  public Student() {}
}
```

**Important:**

* Must **implement `Serializable`** (a marker interface; it has no methods).
* Must have a **default (non-parameterized) constructor**.

2. **Write the object to a file using `ObjectOutputStream`:**

```java
FileOutputStream fos = new FileOutputStream("student.ser");
ObjectOutputStream oos = new ObjectOutputStream(fos);

Student s = new Student();
s.rollNumber = 10;
s.name = "John";
s.department = "CSE";

oos.writeObject(s);  // writes the entire object at once
oos.close();
fos.close();
```

* `writeObject()` handles the **entire object**; no need to write each property manually.

---

## **3ï¸âƒ£ How to Deserialize an Object**

```java
FileInputStream fis = new FileInputStream("student.ser");
ObjectInputStream ois = new ObjectInputStream(fis);

Student s = (Student) ois.readObject();  // must type cast
ois.close();
fis.close();

System.out.println(s.rollNumber);
System.out.println(s.name);
System.out.println(s.department);
```

* The object is **fully restored** with the same values as when it was written.

---

## **4ï¸âƒ£ Important Rules for Serialization**

1. **Implement `Serializable`**:

   * Marker interface â†’ no methods to override.
   * Tells JVM that this class can be serialized.

2. **Default Constructor Required**:

   * Must have a non-parameterized constructor.
   * Reading (deserialization) fails without it.

3. **Static and Transient Members**:

   * **Static members** â†’ belong to the class, not object â†’ **not serialized**
   * **Transient members** â†’ explicitly marked not to serialize â†’ **not saved**

---

## **5ï¸âƒ£ Benefits of Serialization**

* **Save and retrieve entire objects** easily.
* **No need to manage individual properties** like in DataOutputStream.
* Useful for:

  * Saving object state to files
  * Sending objects over a network
  * Caching objects

---

## **6ï¸âƒ£ File Format**

* Serialized objects are stored in **binary format**, not human-readable.
* File extension can be `.ser` (convention), but any extension works.

---

# **ðŸ“˜Object Streams & Serialisation**

---

## **1ï¸âƒ£ What is Serialization?**

* **Serialization** is the process of **converting an object into a byte stream** so that it can be **stored in a file, sent over a network, or saved for later use**.
* **Deserialization** is the process of **converting the byte stream back into an object** with the same state as when it was serialized.
* Key advantage: You donâ€™t need to manually write/read each property; the **entire object** is handled automatically.

---

## **2ï¸âƒ£ The Student Class for Serialization**

```java
import java.io.Serializable;

class Student implements Serializable {
  int rollNumber;
  String name;
  float average;
  String department;

  static int staticValue;       // Not serialized
  transient int t;              // Not serialized

  // Default constructor (good practice)
  public Student() {}

  // Parameterized constructor
  public Student(int rollNumber, String name, float average, String department) {
    this.rollNumber = rollNumber;
    this.name = name;
    this.average = average;
    this.department = department;
    staticValue = 500;
    t = 500; // These will not be serialized
  }

  @Override
  public String toString() {
      return "Roll: " + rollNumber + ", Name: " + name +
              ", Average: " + average + ", Dept: " + department +
              ", Static: " + staticValue + ", Transient: " + t;
  }
}
```

**Notes:**

1. **`implements Serializable`** â†’ required for object serialization. Itâ€™s a marker interface; no methods to override.
2. **Transient & Static members** â†’ not serialized.
3. **Default constructor** â†’ good practice, especially for inheritance.

---

## **3ï¸âƒ£ Serializing an Object**

```java
import java.io.*;

public class SerializeDemo {
  public static void main(String[] args) throws Exception {
    FileOutputStream fos = new FileOutputStream("Student3.txt");
    ObjectOutputStream oos = new ObjectOutputStream(fos);

    Student s = new Student(10, "John", 80.5f, "CSE");

    oos.writeObject(s);  // Serialize the object
    oos.close();
    fos.close();

    System.out.println("Object Serialized Successfully!");
  }
}
```

* **`writeObject()`** handles the entire object.
* The file `Student3.txt` becomes **binary**; humans cannot read it properly.

---

## **4ï¸âƒ£ Deserializing an Object**

```java
import java.io.*;

public class DeserializeDemo {
  public static void main(String[] args) throws Exception {
    FileInputStream fis = new FileInputStream("Student3.txt");
    ObjectInputStream ois = new ObjectInputStream(fis);

    Student s = (Student) ois.readObject(); // Typecast is mandatory

    ois.close();
    fis.close();

    System.out.println("Deserialized Object:");
    System.out.println(s);
  }
}
```

* Only `ObjectInputStream` can read the serialized object.
* **Order or structure mismatch** will cause exceptions (`InvalidClassException`).

---

## **5ï¸âƒ£ Important Points from the Video**

1. **Transient & Static Members:**

   * Not serialized.
   * Example: `t` (transient) and `staticValue` â†’ values are not saved in file.

2. **Class Versioning (serialVersionUID):**

   * If the class structure changes after serialization (e.g., constructor removed), deserialization fails.
   * Java assigns a **serialVersionUID** to each class to track versions.
   * Best practice: explicitly declare a `serialVersionUID` to maintain compatibility.

```java
private static final long serialVersionUID = 1L;
```

3. **Binary Nature:**

   * Serialized files are binary; human-readable editing is not possible.
   * Always use `ObjectInputStream` to retrieve objects.

4. **Parameterized Constructor:**

   * Used to initialize object before serialization.
   * During deserialization, the **parameterized constructor is NOT called**; object is reconstructed from byte stream.

---

## **6ï¸âƒ£ Key Takeaways**

* **Serialization**: Save entire object state automatically.
* **Deserialization**: Restore entire object state.
* **Requirements**:

  1. `implements Serializable`
  2. Default constructor (good practice)
  3. Be aware of transient/static members.
* **Versioning matters**: Class structure must match between serialization and deserialization.

---

# **ðŸ“˜Student Challenge  Serialize a Customer**
---

## **1ï¸âƒ£ Task 1: Store and Retrieve Float Numbers**

### **Problem**

* You have an array of float numbers, e.g., `[10.5f, 2.9f, 6.4f, 3.7f]`.
* You need to **store them in a file** and later **read them back**.

### **Key Considerations**

1. Use `FileOutputStream` + `DataOutputStream` for writing floats.
2. Use `FileInputStream` + `DataInputStream` for reading floats.
3. Java does not have an end-of-file marker for non-byte types, so you need to **store the number of floats first**.

### **Code Example**

```java
import java.io.*;

public class FloatStorageDemo {
  public static void main(String[] args) throws IOException {
    float[] list = {10.5f, 2.9f, 6.4f, 3.7f};

    // Writing floats to file
    FileOutputStream fos = new FileOutputStream("Data.txt");
    DataOutputStream dos = new DataOutputStream(fos);

    dos.writeInt(list.length);           // Write number of floats
    for (float f : list) {
        dos.writeFloat(f);               // Write each float
    }
    dos.close();
    fos.close();

    // Reading floats from file
    FileInputStream fis = new FileInputStream("Data.txt");
    DataInputStream dis = new DataInputStream(fis);

    int length = dis.readInt();          // Read number of floats
    for (int i = 0; i < length; i++) {
        float f = dis.readFloat();
        System.out.println(f);           // Display float
    }
    dis.close();
    fis.close();
  }
}
```

**Output:**

```
10.5
2.9
6.4
3.7
```

**Notes:**

* The file is **binary**, so you cannot read it as plain text.
* Always close the **wrapper stream** (`DataOutputStream`) before the underlying stream (`FileOutputStream`).

---

## **2ï¸âƒ£ Task 2: Serialize and Retrieve Customer Objects**

### **Problem**

* Define a `Customer` class with:

  * `customerID` (auto-generated: C1, C2, â€¦)
  * `name`
  * `phoneNumber`
* Serialize multiple `Customer` objects into a file (`customer.txt`) and retrieve them.
* You can optionally **search for a customer by name**.

### **Customer Class**

```java
import java.io.Serializable;

class Customer implements Serializable {
  private static final long serialVersionUID = 1L;
  
  private static int count = 0;       // For auto ID generation
  private String customerID;
  private String name;
  private String phoneNumber;

  // Non-parameterized constructor
  public Customer() {}

  // Parameterized constructor
  public Customer(String name, String phoneNumber) {
      count++;
      this.customerID = "C" + count;  // Auto-generate ID
      this.name = name;
      this.phoneNumber = phoneNumber;
  }

  @Override
  public String toString() {
      return "CustomerID: " + customerID + ", Name: " + name + ", Phone: " + phoneNumber;
  }
}
```

---

### **Serializing Customers to File**

```java
import java.io.*;

public class SerializeCustomer {
  public static void main(String[] args) throws IOException {
    Customer[] customers = {
      new Customer("Smith", "9876543210"),
      new Customer("John", "9876501234"),
      new Customer("Ajay", "9876512345")
    };

    FileOutputStream fos = new FileOutputStream("customer.txt");
    ObjectOutputStream oos = new ObjectOutputStream(fos);

    oos.writeInt(customers.length);    // Write number of objects
    for (Customer c : customers) {
        oos.writeObject(c);            // Serialize each object
    }

    oos.close();
    fos.close();
    System.out.println("Customers serialized successfully.");
  }
}
```

---

### **Deserializing Customers from File and Searching**

```java
import java.io.*;
import java.util.Scanner;

public class DeserializeCustomer {
  public static void main(String[] args) throws IOException, ClassNotFoundException {
    FileInputStream fis = new FileInputStream("customer.txt");
    ObjectInputStream ois = new ObjectInputStream(fis);

    int length = ois.readInt();               // Read number of objects
    Customer[] customers = new Customer[length];

    for (int i = 0; i < length; i++) {
        customers[i] = (Customer) ois.readObject();
    }

    ois.close();
    fis.close();

    // Searching by name
    Scanner sc = new Scanner(System.in);
    System.out.print("Enter name to search: ");
    String searchName = sc.nextLine();

    for (Customer c : customers) {
      if (c.toString().contains(searchName)) {
        System.out.println(c);
      }
    }
    sc.close();
  }
}
```

**Notes:**

* Always **typecast** when using `readObject()`.
* The `customerID` is automatically generated.
* You can store the **number of objects first** for easier deserialization.
* Objects are stored in **binary format**, readable only via `ObjectInputStream`.

---

âœ… **Key Concepts Covered:**

1. `DataOutputStream` & `DataInputStream` for primitive types like floats.
2. `ObjectOutputStream` & `ObjectInputStream` for object serialization.
3. Auto-generated IDs using a static counter.
4. Storing the number of elements/objects in the file to know how many to read.
5. Transient/static members are **not serialized** (relevant for advanced object handling).

---
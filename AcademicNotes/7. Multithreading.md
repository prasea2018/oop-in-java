# Unit: Multithreading in Java

## 1. Introduction to Multithreading

**Multithreading** is a core feature of Java that allows a program to execute multiple tasks concurrently. Each task runs in a **thread**, which is a lightweight sub-process.

### Why Multithreading?

* Improves **CPU utilization**
* Enables **responsive applications** (e.g., GUI, servers)
* Allows **parallel execution** of tasks
* Essential for **banking systems, servers, and real-time applications**

### Real-World Example

In a banking application:

* One thread handles **user requests**
* Another thread processes **transaction validation**
* Another thread logs **audit information**

---

## 2. Understanding Threads in Java

### What is a Thread?

A **thread** is an independent path of execution within a program.

Java provides built-in support for multithreading through:

* `java.lang.Thread` class
* `java.lang.Runnable` interface

---

## 3. Creating Threads in Java

Java provides **two primary ways** to create threads:

---

## 3.1 Extending `java.lang.Thread`

### Concept

A class can extend the **Thread** class and override its `run()` method.

### Syntax Example

```java
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread is running");
    }
}

public class TestThread {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start();  // starts a new thread
    }
}
```

### Key Points

* `run()` → contains the task
* `start()` → creates a new thread and calls `run()`
* Calling `run()` directly does **not** start a new thread

### Limitations

* Java does **not support multiple inheritance**
* Extending `Thread` restricts class extensibility

---

## 3.2 Implementing `java.lang.Runnable` Interface

### Concept

A class implements the **Runnable** interface and passes the object to a `Thread` instance.

### Syntax Example

```java
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Thread is running using Runnable");
    }
}

public class TestRunnable {
    public static void main(String[] args) {
        MyRunnable r = new MyRunnable();
        Thread t = new Thread(r);
        t.start();
    }
}
```

### Advantages

* Supports **multiple inheritance**
* Better **object-oriented design**
* Preferred in **real-world applications**

---

## 4. Thread Execution and Life Cycle

### Thread Life Cycle States

1. **New** – Thread object created
2. **Runnable** – Ready to run
3. **Running** – Executing `run()` method
4. **Blocked/Waiting** – Waiting for resources or signals
5. **Terminated** – Execution completed

### Diagram Concept

```
New → Runnable → Running → Terminated
           ↓
        Waiting / Blocked
```

### Example

```java
Thread t = new Thread();
t.start(); // Runnable
```

---

## 5. Thread Priorities

### What is Thread Priority?

**Thread priority** determines the importance of a thread to the scheduler.

### Priority Range

* **MIN_PRIORITY** = 1
* **NORM_PRIORITY** = 5 (default)
* **MAX_PRIORITY** = 10

### Example

```java
class PriorityThread extends Thread {
  private String threadName;

  PriorityThread(String name) {
    this.threadName = name;
  }

  public void run() {
    // The loop is just to give the scheduler a chance to show the priority effect
    for (int i = 0; i < 5; i++) {
      System.out.println(threadName + " running with priority: " + getPriority() + ", iteration: " + i);
    }
  }
}

public class ThreadPriorityExample {
  public static void main(String[] args) {
    PriorityThread t1 = new PriorityThread("HighPriorityThread");
    PriorityThread t2 = new PriorityThread("LowPriorityThread");

    // Set priorities using predefined constants or integer values (1-10)
    t1.setPriority(Thread.MAX_PRIORITY); // Value 10
    t2.setPriority(Thread.MIN_PRIORITY); // Value 1

    System.out.println(t1.threadName + " priority: " + t1.getPriority());
    System.out.println(t2.threadName + " priority: " + t2.getPriority());

    // Start the threads
    t2.start();
    t1.start();
  }
}

```

### Key Notes

* Higher priority threads **may** execute first
* Execution order is **not guaranteed**
* OS-dependent behavior

---

## 6. Thread Synchronization

### What is Synchronization?

**Synchronization** is the process of controlling access to shared resources to prevent data inconsistency.

### Problem: Race Condition

Occurs when multiple threads access shared data simultaneously.

### Example Without Synchronization

```java
class Counter {
    int count = 0;

    void increment() {
        count++;
    }
}
```

Multiple threads may produce incorrect results.

---

## 6.1 Synchronized Method

```java
synchronized void increment() {
    count++;
}
```

* Locks the object
* Only one thread executes at a time

---

## 6.2 Synchronized Block

```java
synchronized(this) {
    count++;
}
```

* More efficient
* Locks only critical code

---

## 7. Inter-Thread Communication

### Definition

**Inter-thread communication** allows threads to communicate and coordinate execution.

Java provides methods:

* `wait()`
* `notify()`
* `notifyAll()`

These methods belong to the **Object class**.

---

## 7.1 Producer–Consumer Problem (Case Study)

### Scenario

* **Producer** produces data
* **Consumer** consumes data
* Both share a common resource

### Example

```java
class Shared {
  int data;
  boolean available = false;

  synchronized void produce(int value) throws InterruptedException {
    while (available)
      wait();
    data = value;
    available = true;
    notify();
  }

  synchronized int consume() throws InterruptedException {
    while (!available)
      wait();
    available = false;
    notify();
    return data;
}
}
```

### Key Points

* `wait()` releases the lock
* `notify()` wakes up waiting thread
* Prevents unnecessary CPU usage

---

## 8. Deadlock

### What is Deadlock?

A **deadlock** occurs when two or more threads are waiting indefinitely for resources held by each other.

### Conditions for Deadlock

1. **Mutual Exclusion**
2. **Hold and Wait**
3. **No Preemption**
4. **Circular Wait**

---

## 8.1 Deadlock Example

```java
class DeadlockExample {
    static final Object A = new Object();
    static final Object B = new Object();

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            synchronized (A) {
                synchronized (B) {
                    System.out.println("Thread 1");
                }
            }
        });

        Thread t2 = new Thread(() -> {
            synchronized (B) {
                synchronized (A) {
                    System.out.println("Thread 2");
                }
            }
        });

        t1.start();
        t2.start();
    }
}
```

### Result

Both threads wait forever.

---

## 8.2 Deadlock Prevention Techniques

* **Avoid nested locks**
* Lock resources in **fixed order**
* Use **timeouts**
* Minimize synchronized blocks

---

## 9. Summary

### Key Takeaways

* **Threads** enable concurrent execution
* Threads can be created using:

  * `Thread` class
  * `Runnable` interface (preferred)
* **Thread life cycle** governs execution flow
* **Thread priority** influences scheduling
* **Synchronization** ensures data consistency
* **Inter-thread communication** coordinates threads
* **Deadlock** is a critical issue requiring careful design

---

## 10. Examination-Oriented Points

* Difference between `start()` and `run()`
* Thread vs Runnable
* Advantages of synchronization
* Producer–Consumer problem
* Causes and prevention of deadlock

---
